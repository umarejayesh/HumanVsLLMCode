<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CodeComparison — Submissions</title>
<style>
  :root {
    --header: #ff8c2a;
    --border: #e6e6e6;
    --row-alt: #fafafa;
    --link: #1a73e8;
    --text: #1f2937;
  }
  body {
    font-family: Arial, Helvetica, sans-serif;
    color: var(--text);
    margin: 24px;
    background: white;
  }
  header {
    text-align: center;
    margin-bottom: 18px;
  }
  header h1 {
    margin: 0 0 8px 0;
    font-size: 24px;
  }
  .meta {
    font-size: 13px;
    color: #6b7280;
  }
  nav {
    display: flex;
    justify-content: center;
    gap: 10px;
    flex-wrap: wrap;
    margin: 14px 0 24px 0;
  }
  nav a {
    display: inline-block;
    padding: 8px 12px;
    border: 1px solid var(--border);
    border-radius: 999px;
    text-decoration: none;
    color: var(--text);
    background: #fff;
  }
  nav a:hover {
    border-color: #cfcfcf;
  }
  h2 {
    text-align: center;
    margin: 28px 0 12px 0;
    font-size: 20px;
  }
  .table-wrap {
    margin: 0 auto 30px auto;
    max-width: 1600px;
  }
  .search {
    width: 100%;
    max-width: 520px;
    display: block;
    margin: 0 auto 10px auto;
    padding: 10px 12px;
    border: 1px solid var(--border);
    border-radius: 10px;
    font-size: 14px;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
    font-size: 13px;
  }
  thead th {
    position: sticky;
    top: 0;
    background: var(--header);
    color: white;
    padding: 10px 8px;
    border: 1px solid var(--header);
    z-index: 1;
  }
  td {
    padding: 8px 8px;
    border: 1px solid var(--border);
    vertical-align: top;
    word-wrap: break-word;
  }
  tbody tr:nth-child(even) {
    background: var(--row-alt);
  }
  a {
    color: var(--link);
    text-decoration: none;
    font-weight: 700;
  }
  a:hover {
    text-decoration: underline;
  }
  details.code summary {
    cursor: pointer;
    font-weight: 700;
    color: #111827;
  }
  details.code pre {
    margin: 8px 0 0 0;
    padding: 10px;
    background: #0b1020;
    color: #e5e7eb;
    border-radius: 12px;
    overflow-x: auto;
    max-height: 280px;
  }
  details.code code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 12px;
    white-space: pre;
  }
  .foot {
    text-align: center;
    color: #6b7280;
    font-size: 12px;
    margin-top: 22px;
  }
</style>
<script>
function filterTable(tableId, query) {
  query = (query || "").toLowerCase().trim();
  const table = document.getElementById(tableId);
  if (!table) return;
  const rows = table.querySelectorAll("tbody tr");
  rows.forEach(tr => {
    const text = tr.innerText.toLowerCase();
    tr.style.display = text.includes(query) ? "" : "none";
  });
}
</script>
</head>
<body>
<header>
  <h1>CodeComparison – Submissions Across Platforms</h1>
  <div class="meta">
    Supplementary artifact for the study <br>
    <em>Human-written vs. LLM-generated Code</em><br>
  \\  Authors: Mohit Krishna, Jayesh Umre, Ashish Singh Parihar
  </div>
</header>


<nav>
  <a href="#tbl_code_forces_sec">Code forces</a><a href="#tbl_leet_code_sec">Leet code</a>
</nav>

<section id="tbl_code_forces_sec"><h2>Code forces - Submissions</h2>
    <div class="table-wrap">
      <input class="search" type="search" placeholder="Search Problem ID / Domain / Level..." oninput="filterTable('tbl_code_forces', this.value)">
      <table id="tbl_code_forces">
        <thead><tr><th>Problem ID</th><th>Problem</th><th>Domain</th><th>Level</th><th>Runtime H (ms)</th><th>Mem H (MB)</th><th>TC H</th><th>SC H</th><th>LOC H</th><th>Human Code</th><th>Runtime LLM (ms)</th><th>Mem LLM (MB)</th><th>TC LLM</th><th>SC LLM</th><th>LOC LLM</th><th>LLM Code</th></tr></thead>
        <tbody>
        <tr><td>1400A</td><td><a href="https://codeforces.com/problemset/problem/1400/A" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Easy</td><td>31.0</td><td>0</td><td>O(n)</td><td>O(1)</td><td>4</td><td><details class="code"><summary>View</summary><pre><code>
#include&lt;iostream&gt;
using namespace std;
main(){
	int t,x,f,n,i;
	string s,p;
	for(cin&gt;&gt;t;t--;cout&lt;&lt;&#x27;\n&#x27;)
		for(cin&gt;&gt;n&gt;&gt;s,i=0;i&lt;n;++i) cout&lt;&lt;s[i*2];
}</code></pre></details></td><td>61</td><td>0</td><td>O(n)</td><td>O(n)</td><td>17</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
 
    int t;
    cin &gt;&gt; t;
    while (t--) {
        int n;
        string s;
        cin &gt;&gt; n &gt;&gt; s; // s has length 2n - 1
 
        char mid = s[n - 1];          // middle character of s (0-based)
        string w(n, mid);             // repeat it n times
 
        cout &lt;&lt; w &lt;&lt; &#x27;\n&#x27;;
    }
 
    return 0;
}</code></pre></details></td></tr>
<tr><td>1400B</td><td><a href="https://codeforces.com/problemset/problem/1400/B" target="_blank" rel="noopener">Link</a></td><td>Greedy</td><td>Easy</td><td>108.0</td><td>3.4</td><td>O(n)</td><td>O(1)</td><td>15</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
int t,p,f,cs,cw,s,w;
cin&gt;&gt;t;
while(t--){
cin&gt;&gt;p&gt;&gt;f&gt;&gt;cs&gt;&gt;cw&gt;&gt;s&gt;&gt;w;
if (s&gt;w){swap(s,w);swap(cs,cw);}
int ans=0;
for (int s1=0;s1*s&lt;=p &amp;&amp; s1&lt;=cs;s1++){
int w1=(p-s1*s)/w;
int s2=min(cs-s1,f/s);
int w2=min((f-s2*s)/w,cw-w1);
ans=max(ans,s1+s2+w1+w2);
}
cout&lt;&lt;ans&lt;&lt;endl;
}
}
</code></pre></details></td><td>62</td><td>0.1</td><td>O(n)</td><td>O(1)</td><td>25</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
 
    int t;
    cin &gt;&gt; t;
    while (t--) {
        long long p, f;
        cin &gt;&gt; p &gt;&gt; f;
        long long cnts, cntw;
        cin &gt;&gt; cnts &gt;&gt; cntw;
        long long s, w;
        cin &gt;&gt; s &gt;&gt; w;
 
        // always treat swords as lighter or equal
        if (s &gt; w) {
            swap(s, w);
            swap(cnts, cntw);
        }
 
        long long ans = 0;
 
        // iterate over how many swords the protagonist takes
        long long maxSwordsP = min(cnts, p / s);
        for (long long x = 0; x &lt;= maxSwordsP; ++x) {
            long long P = p - x * s;        // remaining capacity of protagonist
            long long remS = cnts - x;      // remaining swords
            long long remW = cntw;          // remaining axes
 
            // protagonist takes axes
            long long y = min(remW, P / w);
            long long takenP = x + y;
 
            long long remW2 = remW - y;     // axes left for follower
 
            // follower takes swords first
            long long maxSwordsF = min(remS, f / s);
            long long F = f - maxSwordsF * s;
 
            // follower then takes axes
            long long maxAxesF = min(remW2, F / w);
 
            long long total = takenP + maxSwordsF + maxAxesF;
            ans = max(ans, total);
        }
 
        cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;
    }
 
    return 0;
}</code></pre></details></td></tr>
<tr><td>1401A</td><td><a href="https://codeforces.com/problemset/problem/1401/A" target="_blank" rel="noopener">Link</a></td><td>Constructive Algorithm</td><td>Easy</td><td>46.0</td><td>0</td><td>O(n)</td><td>O(1)</td><td>2</td><td><details class="code"><summary>View</summary><pre><code>
#include&lt;iostream&gt;
int T,N,K;main(){for(std::cin&gt;&gt;T;T--;std::cout&lt;&lt;(K&gt;N?K-N:K+N&amp;1)&lt;&lt;&#x27; &#x27;)std::cin&gt;&gt;N&gt;&gt;K;}</code></pre></details></td><td>62</td><td>0</td><td>O(n)</td><td>O(1)</td><td>23</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
 
    int t;
    cin &gt;&gt; t;
    while (t--) {
        long long n, k;
        cin &gt;&gt; n &gt;&gt; k;
 
        if (n &lt; k) {
            cout &lt;&lt; k - n &lt;&lt; &#x27;\n&#x27;;
        } else {
            long long diff = n - k;
            if (diff % 2 == 0) {
                cout &lt;&lt; 0 &lt;&lt; &#x27;\n&#x27;;
            } else {
                cout &lt;&lt; 1 &lt;&lt; &#x27;\n&#x27;;
            }
        }
    }
 
    return 0;
}</code></pre></details></td></tr>
<tr><td>1401B</td><td><a href="https://codeforces.com/problemset/problem/1401/B" target="_blank" rel="noopener">Link</a></td><td>Greedy</td><td>Easy</td><td>109.0</td><td>0</td><td>O(n)</td><td>O(1)</td><td>8</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;iostream&gt;
using namespace std;
int T,a,b,c,d,e;
main(){
    for(cin&gt;&gt;T; T-- ; cout&lt;&lt;min(min(c,e),d+e-b)*2&lt;&lt;&#x27; &#x27;) cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;a;
}</code></pre></details></td><td>61</td><td>0</td><td>O(n)</td><td>O(1)</td><td>32</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
 
    int t;
    if (!(cin &gt;&gt; t)) return 0;
    while (t--) {
        long long x1, y1, z1;
        long long x2, y2, z2;
        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1;
        cin &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; z2;
 
        long long ans = 0;
 
        // 1) Make as many (2,1) pairs as possible: (a=2, b=1) gives +2
        long long take = min(z1, y2);
        ans += 2 * take;
        z1 -= take;
        y2 -= take;
 
        // 2) Now try to neutralize b&#x27;s 2s (z2) using a&#x27;s 0s and 2s
        // First pair (0,2): a=0, b=2; c = -2 (bad), but this step is rearranged in known solution
        // Known greedy from editorial: use a&#x27;s 0s and 2s to absorb b&#x27;s 2s before they meet a&#x27;s 1s.
 
        // Absorb with a&#x27;s 0s: pairs (0,2) are bad, but this neutralization pattern
        // translates in codeforces editorial to:
        long long tmp = min(x1, z2);
        x1 -= tmp;
        z2 -= tmp;
 
        // Absorb with a&#x27;s 2s: (2,2) gives 0
        tmp = min(z1, z2);
        z1 -= tmp;
        z2 -= tmp;
 
        // 3) Any remaining z2 must pair with y1: (1,2) gives -2
        tmp = min(y1, z2);
        ans -= 2 * tmp;
 
        cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;
    }
 
    return 0;
}</code></pre></details></td></tr>
<tr><td>1626A</td><td><a href="https://codeforces.com/problemset/problem/1626/A" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Easy</td><td>15.0</td><td>0</td><td>O(nlogn)</td><td>O(n)</td><td>8</td><td><details class="code"><summary>View</summary><pre><code>
#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){int t;cin&gt;&gt;t;while(t--){string s;cin&gt;&gt;s;sort(s.begin(),s.end());cout&lt;&lt;s&lt;&lt;&#x27;\n&#x27;;}}</code></pre></details></td><td>46</td><td>0</td><td>O(n)</td><td>O(1)</td><td>22</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t; cin &gt;&gt; t;
    while (t--) {
        string s; cin &gt;&gt; s;

        map&lt;char, int&gt; freq;
        for (char c : s) freq[c]++;

        vector&lt;char&gt; once, twice;
        for (auto &amp;p : freq) {
            if (p.second == 1) once.push_back(p.first);
            else twice.push_back(p.first);
        }

        string result;
        // Add first occurrence of letters appearing twice
        for (char c : twice) result.push_back(c);
        // Add letters appearing once
        for (char c : once) result.push_back(c);
        // Add second occurrence of letters appearing twice
        for (char c : twice) result.push_back(c);

        cout &lt;&lt; result &lt;&lt; &quot;\n&quot;;
    }

    return 0;
}
</code></pre></details></td></tr>
<tr><td>1628D1</td><td><a href="https://codeforces.com/problemset/problem/1628/D1" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Easy</td><td>78.0</td><td>0</td><td>O(n)</td><td>O(1)</td><td>17</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	int a;
	cin&gt;&gt;a;
	while(a--){
		int k,m,s1=0,s2=0,x;
		cin&gt;&gt;k;
		for(int i=1;i&lt;=k;i++) cin&gt;&gt;x,s1=max(x,s1);
		cin&gt;&gt;m;
		for(int i=1;i&lt;=m;i++) cin&gt;&gt;x,s2=max(x,s2);
		puts(s1&gt;=s2?&quot;Alice&quot;:&quot;Bob&quot;);
		puts(s1&gt;s2?&quot;Alice&quot;:&quot;Bob&quot;);
	}
}</code></pre></details></td><td>46</td><td>0</td><td>O(n)</td><td>O(n)</td><td>30</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin &gt;&gt; t;
    while (t--) {
        int n, m;
        cin &gt;&gt; n;
        vector&lt;int&gt; a(n);
        for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i];
        cin &gt;&gt; m;
        vector&lt;int&gt; b(m);
        for (int i = 0; i &lt; m; ++i) cin &gt;&gt; b[i];

        int maxA = *max_element(a.begin(), a.end());
        int maxB = *max_element(b.begin(), b.end());

        // First line: winner when Alice starts
        if (maxA &gt;= maxB) {
            cout &lt;&lt; &quot;Alice\n&quot;;
        } else {
            cout &lt;&lt; &quot;Bob\n&quot;;
        }

        // Second line: winner when Bob starts
        if (maxB &gt;= maxA) {
            cout &lt;&lt; &quot;Bob\n&quot;;
        } else {
            cout &lt;&lt; &quot;Alice\n&quot;;
        }
    }

    return 0;
}
</code></pre></details></td></tr>
<tr><td>1657A</td><td><a href="https://codeforces.com/problemset/problem/1657/A" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Easy</td><td>15.0</td><td>0</td><td>O(n)</td><td>O(1)</td><td>9</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int t,x,y,z;
int main()
{
	cin&gt;&gt;t;
	while(t--&amp;&amp;cin&gt;&gt;x&gt;&gt;y)
		z=sqrt(x*x+y*y),puts(x+y==0?&quot;0&quot;:(z*z==x*x+y*y?&quot;1&quot;:&quot;2&quot;));
}</code></pre></details></td><td>46</td><td>0</td><td>O(n)</td><td>O(1)</td><td>23</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin &gt;&gt; t;
    while (t--) {
        long long x, y;
        cin &gt;&gt; x &gt;&gt; y;
        long long d2 = x * x + y * y;

        if (x == 0 &amp;&amp; y == 0) {
            cout &lt;&lt; 0 &lt;&lt; &#x27;\n&#x27;;
        } else {
            long long r = llround(sqrt((long double)d2));
            if (r * r == d2) {
                cout &lt;&lt; 1 &lt;&lt; &#x27;\n&#x27;;
            } else {
                cout &lt;&lt; 2 &lt;&lt; &#x27;\n&#x27;;
            }
        }
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>1671A</td><td><a href="https://codeforces.com/problemset/problem/1671/A" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Easy</td><td>30.0</td><td>0.2</td><td>O(n)</td><td>O(1)</td><td>8</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
 
using namespace std;
 
int main()
{
int t; cin &gt;&gt; t;
while(t--){
string s;cin&gt;&gt;s;
if(regex_match(s,regex(&quot;(aa|aaa|bb|bbb)+&quot;))) cout&lt;&lt;&quot;YES\n&quot;;
else cout&lt;&lt;&quot;NO\n&quot;;
}
}</code></pre></details></td><td>46</td><td>0</td><td>O(n)</td><td>O(1)</td><td>27</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    if (!(cin &gt;&gt; t)) return 0;
    while (t--) {
        string s;
        cin &gt;&gt; s;
        int n = (int)s.size();
        bool ok = true;
        int i = 0;
        while (i &lt; n) {
            int j = i;
            while (j &lt; n &amp;&amp; s[j] == s[i]) j++;
            int len = j - i;
            if (len == 1) {      // only length 1 is forbidden
                ok = false;
                break;
            }
            i = j;
        }
        cout &lt;&lt; (ok ? &quot;YES\n&quot; : &quot;NO\n&quot;);
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>1671B</td><td><a href="https://codeforces.com/problemset/problem/1671/B" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Easy</td><td>327.0</td><td>3.9</td><td>O(n)</td><td>O(n)</td><td>8</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int t,n,a[1000005];
int main(){
cin&gt;&gt;t;while(t--){
cin&gt;&gt;n;for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];cout&lt;&lt;(a[n]-a[1]-n&lt;2?&quot;YES&quot;:&quot;NO&quot;)&lt;&lt;endl;};
}</code></pre></details></td><td>Error</td><td>Error</td><td>Error</td><td>Error</td><td>Error</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    if (!(cin &gt;&gt; t)) return 0;
    while (t--) {
        int n;
        cin &gt;&gt; n;
        vector&lt;long long&gt; x(n);
        for (int i = 0; i &lt; n; ++i) cin &gt;&gt; x[i];

        if (n == 1) {
            cout &lt;&lt; &quot;YES\n&quot;;
            continue;
        }

        int cnt3 = 0;
        bool bad = false;
        for (int i = 0; i + 1 &lt; n; ++i) {
            long long diff = x[i + 1] - x[i];
            if (diff &gt; 3) {
                bad = true;
                break;
            }
            if (diff == 3) ++cnt3;
        }

        if (bad || cnt3 &gt; 1) cout &lt;&lt; &quot;NO\n&quot;;
        else cout &lt;&lt; &quot;YES\n&quot;;
    }

    return 0;
}
</code></pre></details></td></tr>
<tr><td>1680A</td><td><a href="https://codeforces.com/problemset/problem/1680/A" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Easy</td><td>62.0</td><td>0</td><td>O(1)</td><td>O(1)</td><td>12</td><td><details class="code"><summary>View</summary><pre><code>
#include&lt;bits/stdc++.h&gt;
using namespace std;int main(){int t,a,b,c,d;cin&gt;&gt;t;while(t--){cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;cout&lt;&lt;(b&gt;=c&amp;&amp;d&gt;=a?max(a,c):a+c)&lt;&lt;endl;}}</code></pre></details></td><td>46</td><td>0</td><td>O(1)</td><td>O(1)</td><td>27</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    if (!(cin &gt;&gt; t)) return 0;
    while (t--) {
        int l1, r1, l2, r2;
        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;

        int ans_diff = l1 + l2;  // different min and max
        int ans = ans_diff;

        // Check if intervals [l1,r1] and [l2,r2] intersect
        int left = max(l1, l2);
        int right = min(r1, r2);
        if (left &lt;= right) {
            int ans_same = left;       // constant array of length left
            ans = min(ans_diff, ans_same);
        }
        cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>1697A</td><td><a href="https://codeforces.com/problemset/problem/1697/A" target="_blank" rel="noopener">Link</a></td><td>Greedy</td><td>Easy</td><td>15.0</td><td>0</td><td>O(n)</td><td>O(1)</td><td>12</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int t,n,m,a;
int main(){
  cin&gt;&gt;t;
  while(t--){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=0;i&lt;n;i++) {cin&gt;&gt;a; m-=a;}
    cout&lt;&lt;max(0,-m)&lt;&lt;endl;
  }
  return 0;
}</code></pre></details></td><td>61</td><td>0</td><td>O(1)</td><td>O(1)</td><td>22</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin &gt;&gt; t;
    while (t--) {
        int n, m;
        cin &gt;&gt; n &gt;&gt; m;
        long long sum = 0;
        for (int i = 0; i &lt; n; ++i) {
            int x;
            cin &gt;&gt; x;
            sum += x;
        }
        long long ans = max(0LL, sum - m);
        cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    }

    return 0;
}
</code></pre></details></td></tr>
<tr><td>1739A</td><td><a href="https://codeforces.com/problemset/problem/1739/A" target="_blank" rel="noopener">Link</a></td><td>Algorithm</td><td>Easy</td><td>42.0</td><td>0</td><td>O(n)</td><td>O(1)</td><td>2</td><td><details class="code"><summary>View</summary><pre><code>
#include &lt;iostream&gt;
int main(){int t,a;std::cin&gt;&gt;t;for(t*=2;t--;){std::cin&gt;&gt;a;std::cout&lt;&lt;(a+1)/2&lt;&lt;&#x27;\n&#x27;;}}</code></pre></details></td><td>31</td><td>0</td><td>O(n)</td><td>O(1)</td><td>30</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

bool isValid(int x, int y, int n, int m) {
    return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m;
}

bool isIsolated(int x, int y, int n, int m) {
    // Possible knight moves
    static const int dx[] = {2, 2, 1, 1, -2, -2, -1, -1};
    static const int dy[] = {1, -1, 2, -2, 1, -1, 2, -2};
    for (int i = 0; i &lt; 8; i++) {
        int nx = x + dx[i], ny = y + dy[i];
        if (isValid(nx, ny, n, m))
            return false;  // A valid move exists, so not isolated
    }
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t; cin &gt;&gt; t;
    while (t--) {
        int n, m; cin &gt;&gt; n &gt;&gt; m;
        pair&lt;int, int&gt; ans = {1, 1}; // default answer if no isolated cell found
        bool found = false;

        for (int i = 1; i &lt;= n &amp;&amp; !found; i++) {
            for (int j = 1; j &lt;= m; j++) {
                if (isIsolated(i, j, n, m)) {
                    ans = {i, j};
                    found = true;
                    break;
                }
            }
        }

        cout &lt;&lt; ans.first &lt;&lt; &quot; &quot; &lt;&lt; ans.second &lt;&lt; &quot;\n&quot;;
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>1849A</td><td><a href="https://codeforces.com/problemset/problem/1849/A" target="_blank" rel="noopener">Link</a></td><td>Greedy</td><td>Easy</td><td>15.0</td><td>0</td><td>O(n)</td><td>O(1)</td><td></td><td><details class="code"><summary>View</summary><pre><code>
#include &lt;bits/stdc++.h&gt; 
using namespace std;int main(){int t;cin&gt;&gt;t;while(t--){int b,c,h; cin&gt;&gt;b&gt;&gt;c&gt;&gt;h;cout&lt;&lt;2*(min(b-1,c+h))+1&lt;&lt;endl;}}</code></pre></details></td><td>62</td><td>0</td><td>O(n)</td><td>O(1)</td><td>18</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    if (!(cin &gt;&gt; t)) return 0;
    while (t--) {
        int b, c, h;
        cin &gt;&gt; b &gt;&gt; c &gt;&gt; h;
        int fillings = c + h;
        int k = min(fillings, b - 1);    // max fillings we can place
        int layers = 2 * k + 1;          // total layers: bread-filling-...-bread
        cout &lt;&lt; layers &lt;&lt; &#x27;\n&#x27;;
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>2163A</td><td><a href="https://codeforces.com/problemset/problem/2163/A" target="_blank" rel="noopener">Link</a></td><td>Greedy </td><td>Easy</td><td>31.0</td><td>0</td><td>O(nlogn)</td><td>O(1)</td><td>o</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=110;
int T,n,a[N];
int main() {
	cin&gt;&gt;T;
	while(T--) {
		cin&gt;&gt;n;
		for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
		sort(a+1,a+n+1);
		bool flag=1;
		for(int i=2;i+1&lt;=n;i+=2) 
			if(a[i]!=a[i+1]) flag=0;
		cout&lt;&lt;(flag?&quot;YES&quot;:&quot;NO&quot;)&lt;&lt;endl;
	}
}</code></pre></details></td><td>error</td><td>error</td><td>error</td><td>error</td><td>error</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    if (!(cin &gt;&gt; T)) return 0;
    while (T--) {
        int n;
        cin &gt;&gt; n;
        vector&lt;int&gt; a(n);
        for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i];

        sort(a.begin(), a.end());

        // Count frequencies of each distinct value
        vector&lt;int&gt; freq;
        for (int i = 0; i &lt; n; ) {
            int j = i;
            while (j &lt; n &amp;&amp; a[j] == a[i]) ++j;
            freq.push_back(j - i);
            i = j;
        }

        bool hasDup = false;
        bool hasFreqAtLeast3 = false;
        for (int f : freq) {
            if (f &gt;= 2) hasDup = true;
            if (f &gt;= 3) hasFreqAtLeast3 = true;
        }
        int distinct = (int)freq.size();

        bool ok = false;
        if (!hasDup) {
            ok = false;                    // all distinct -&gt; NO
        } else if (n % 2 == 0) {
            ok = true;                     // even n, any duplicate suffices
        } else {
            // odd n: need stronger structure
            if (hasFreqAtLeast3 || distinct &lt;= 2)
                ok = true;
            else
                ok = false;
        }

        cout &lt;&lt; (ok ? &quot;YES\n&quot; : &quot;NO\n&quot;);
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>1400E</td><td><a href="https://codeforces.com/problemset/problem/1400/E" target="_blank" rel="noopener">Link</a></td><td>Dynamic programming</td><td>Hard</td><td>98.0</td><td>98</td><td>O(n^2)</td><td>O(n^2)</td><td>7</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
int i,j=1,a[5010],f[5010][5010];
main(){
for(std::cin&gt;&gt;i;j&lt;=i;j++)std::cin&gt;&gt;a[j];
for(;i;i--)for(j=0;j&lt;i;j++)f[i-1][j]=a[j]&lt;a[i]?std::min(f[i][j]+1,f[i][i]+a[i]-a[j]):f[i][i];
std::cout&lt;&lt;**f;
}</code></pre></details></td><td>54</td><td>0</td><td>O(n^2)</td><td>O(n)</td><td>35</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
long long solve_segment(vector&lt;int&gt; &amp;a, int l, int r) {
    if (l &gt; r) return 0;
 
    // Find minimum in [l, r]
    int mn = INT_MAX;
    for (int i = l; i &lt;= r; ++i) {
        mn = min(mn, a[i]);
    }
 
    // Option 1: remove each element individually by type-2
    long long res = r - l + 1;
 
    // Option 2: use mn type-1 operations to reduce entire segment,
    // then recurse on positive subsegments
    for (int i = l; i &lt;= r; ++i) {
        a[i] -= mn;
    }
 
    long long cost = mn;  // cost of doing mn full-segment operations
 
    int i = l;
    while (i &lt;= r) {
        // skip zeros
        while (i &lt;= r &amp;&amp; a[i] == 0) ++i;
        if (i &gt; r) break;
        int j = i;
        while (j &lt;= r &amp;&amp; a[j] &gt; 0) ++j;
        // recurse on subsegment [i, j-1]
        cost += solve_segment(a, i, j - 1);
        i = j;
    }
 
    // Restore array if needed is not necessary because we always pass
    // the same reference and only care about current reduced state
    // within recursion; we do not reuse original values above.
 
    return min(res, cost);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
 
    int n;
    if (!(cin &gt;&gt; n)) return 0;
    vector&lt;int&gt; a(n);
    for (int i = 0; i &lt; n; ++i) {
        cin &gt;&gt; a[i];
    }
 
    cout &lt;&lt; solve_segment(a, 0, n - 1) &lt;&lt; &#x27;\n&#x27;;
    return 0;
}</code></pre></details></td></tr>
<tr><td>1400F</td><td><a href="https://codeforces.com/problemset/problem/1400/F" target="_blank" rel="noopener">Link</a></td><td>Dynamic programming</td><td>Hard</td><td>1098.0</td><td>116</td><td>O(2^n)</td><td>O(2^n)</td><td>30</td><td><details class="code"><summary>View</summary><pre><code>#pragma GCC optimize(&quot;O3&quot;)
#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll=long long;
const int nax=1007;
char wcz[nax];
int tab[nax],dzmas,n,k;
unordered_map&lt;int,int&gt; mapa[nax];
int spoko(int mas){if (!(mas&amp;(1&lt;&lt;k)))return 1;if (mas&amp;dzmas)return 1;return 0;}
void skroc(int &amp;mas){mas&amp;=((1&lt;&lt;k)-1);int x=(mas&amp;dzmas);if (!x)return;x&amp;=-x;mas&amp;=(x-1);}
int rek(int v, int mas){if (v==n)return 0;skroc(mas);if (mapa[v].count(mas))return mapa[v][mas];int ret=rek(v+1, mas)+1;int wte=mas;mas=(mas&lt;&lt;tab[v+1])|1;if (spoko(mas))ret=min(ret, rek(v+1, mas));return mapa[v][wte]=ret;}
int main(){scanf(&quot;%s%d&quot;, wcz+1, &amp;k);for (int i=1; i&lt;k; i++)if (!(k%i))dzmas|=(1&lt;&lt;i);n=strlen(wcz+1);for (int i=1; i&lt;=n; i++)tab[i]=wcz[i]-&#x27;0&#x27;;printf(&quot;%d\n&quot;, rek(0, 1));return 0;}
</code></pre></details></td><td>109</td><td>15.8</td><td>O(n)</td><td>O(n)</td><td>140</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
struct Node {
    int next[10];      // digits 1..9 (index = digit)
    int link;          // failure link
    bool bad;          // this node reaches an x-prime pattern
    Node() {
        fill(next, next + 10, -1);
        link = -1;
        bad = false;
    }
};
 
int xVal;
vector&lt;string&gt; patterns;
vector&lt;Node&gt; aho;
 
// check if a given digit string is x-prime
bool is_x_prime(const string &amp;s) {
    int n = (int)s.size();
    int sum = 0;
    for (char c : s) sum += c - &#x27;0&#x27;;
    if (sum != xVal) return false;
 
    // check all substrings
    for (int l = 0; l &lt; n; ++l) {
        int cur = 0;
        for (int r = l; r &lt; n; ++r) {
            cur += s[r] - &#x27;0&#x27;;
            if (cur != xVal &amp;&amp; cur &gt; 0 &amp;&amp; xVal % cur == 0) {
                return false;
            }
        }
    }
    return true;
}
 
// generate all x-prime strings (digits 1..9, sum == xVal)
void gen_all(int cur_sum, string &amp;cur) {
    if (cur_sum == xVal) {
        if (is_x_prime(cur))
            patterns.push_back(cur);
        return;
    }
    for (int d = 1; d &lt;= 9; ++d) {
        if (cur_sum + d &gt; xVal) break;
        cur.push_back(char(&#x27;0&#x27; + d));
        gen_all(cur_sum + d, cur);
        cur.pop_back();
    }
}
 
void build_aho() {
    aho.clear();
    aho.emplace_back(); // root
 
    // insert patterns into trie
    for (const string &amp;pat : patterns) {
        int v = 0;
        for (char c : pat) {
            int d = c - &#x27;0&#x27;;
            if (aho[v].next[d] == -1) {
                aho[v].next[d] = (int)aho.size();
                aho.emplace_back();
            }
            v = aho[v].next[d];
        }
        aho[v].bad = true;
    }
 
    // build failure links with BFS
    queue&lt;int&gt; q;
    // root&#x27;s children
    aho[0].link = 0;
    for (int d = 1; d &lt;= 9; ++d) {
        int to = aho[0].next[d];
        if (to != -1) {
            aho[to].link = 0;
            q.push(to);
        } else {
            aho[0].next[d] = 0;  // compress transitions
        }
    }
 
    while (!q.empty()) {
        int v = q.front(); q.pop();
        int link = aho[v].link;
        aho[v].bad = aho[v].bad || aho[link].bad;
        for (int d = 1; d &lt;= 9; ++d) {
            int to = aho[v].next[d];
            if (to != -1) {
                aho[to].link = aho[link].next[d];
                q.push(to);
            } else {
                aho[v].next[d] = aho[link].next[d];
            }
        }
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
 
    string s;
    if (!(cin &gt;&gt; s)) return 0;
    cin &gt;&gt; xVal;
 
    // generate all x-prime strings
    patterns.clear();
    string cur;
    gen_all(0, cur);
 
    if (patterns.empty()) {
        // no x-prime strings exist at all
        cout &lt;&lt; 0 &lt;&lt; &#x27;\n&#x27;;
        return 0;
    }
 
    // build AhoCorasick automaton
    build_aho();
    int states = (int)aho.size();
    int n = (int)s.size();
 
    const int INF = 1e9;
    // dp[pos][state] = min deletions to process first pos characters
    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(states, INF));
    dp[0][0] = 0;
 
    for (int i = 0; i &lt; n; ++i) {
        int digit = s[i] - &#x27;0&#x27;;
        for (int v = 0; v &lt; states; ++v) {
            if (dp[i][v] == INF) continue;
 
            // Option 1: delete s[i]
            dp[i + 1][v] = min(dp[i + 1][v], dp[i][v] + 1);
 
            // Option 2: keep s[i], move in automaton
            int u = aho[v].next[digit];
            if (!aho[u].bad) {
                dp[i + 1][u] = min(dp[i + 1][u], dp[i][v]);
            }
            // if aho[u].bad, this path is forbidden (would create an x-prime substring)
        }
    }
 
    int ans = INF;
    for (int v = 0; v &lt; states; ++v) {
        ans = min(ans, dp[n][v]);
    }
    cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;
 
    return 0;
}</code></pre></details></td></tr>
<tr><td>1400G</td><td><a href="https://codeforces.com/problemset/problem/1400/G" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Hard</td><td>2827.0</td><td>65</td><td>O(n)</td><td>O(n)</td><td>50</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
 
const int N=3e5+10,mod=998244353;
int n,m,l[N],r[N],s[N][50],ans,f[N],a[N],b[N],inv[N];
 
int qpow(int x,int y){
	int ret=1;
	while(y){
		if(y&amp;1)ret=1ll*ret*x%mod;
		y&gt;&gt;=1;x=1ll*x*x%mod;
	}
	return ret;
}
int C(int x,int y){
	if(x&lt;y||x&lt;0||y&lt;0)return 0;
	return 1ll*f[x]*inv[x-y]%mod*inv[y]%mod;
}
 
signed main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	f[0]=1;inv[0]=1;
	for(int i=1;i&lt;=n;i++)f[i]=1ll*f[i-1]*i%mod,inv[i]=qpow(f[i],mod-2);
	for(int i=1;i&lt;=n;i++)scanf(&quot;%d%d&quot;,&amp;l[i],&amp;r[i]);
	for(int i=1;i&lt;=n;i++)s[l[i]][0]++,s[r[i]+1][0]--;
	for(int i=1;i&lt;=n;i++)s[i][0]+=s[i-1][0];
	for(int i=1;i&lt;=n;i++)
		for(int j=m*2;j&gt;=0;j--)s[i][j]=(s[i-1][j]+C(s[i][0]-j,i-j))%mod;
	for(int i=1;i&lt;=m;i++)scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]);
	for(int i=0;i&lt;(1&lt;&lt;m);i++){
		set&lt;int&gt;t;
		int L,R;L=1;R=n;
		for(int j=1;j&lt;=m;j++)if(i&gt;&gt;j-1&amp;1){
			L=max(L,l[a[j]]);L=max(L,l[b[j]]);
			R=min(R,r[a[j]]);R=min(R,r[b[j]]);
			t.insert(a[j]);t.insert(b[j]);
		}
		if(L&gt;R)continue;
		int cnt=t.size();
		if(__builtin_popcount(i)&amp;1)ans=((ans-s[R][cnt]+s[L-1][cnt])%mod+mod)%mod;
		else ans=((ans+s[R][cnt]-s[L-1][cnt])%mod+mod)%mod;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}</code></pre></details></td><td>Error</td><td>Error</td><td>Error</td><td>Error</td><td>Error</td><td><details class="code"><summary>View</summary><pre><code>Error</code></pre></details></td></tr>
<tr><td>1401E</td><td><a href="https://codeforces.com/problemset/problem/1401/E" target="_blank" rel="noopener">Link</a></td><td>Tree</td><td>Hard</td><td>186.0</td><td>32.8</td><td>O(nlogn)</td><td>O(n)</td><td>35</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int l=1,r=1e6+1;
int i,j,k,n,m,t,x,y,f[1005000];
ll res;
#define rd() scanf(&quot;%d%d%d&quot;,&amp;k,&amp;x,&amp;y);k++;x++;y++
void add(int x,int y){for(;x&lt;=r;x+=(-x&amp;x)){f[x]+=y;}}
int get(int x,int y=0){for(;x;x-=(-x&amp;x)){y+=f[x];}return y;}
vector&lt;pair&lt;int,int&gt; &gt; q[1005000],v[1005000];
 
int main() {
	add(l,1);add(r,1);
	q[1].push_back({l,r});
	q[r].push_back({l,r});
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(i=1;i&lt;=n;i++){
    	rd();
    	q[k].push_back({x,y});
	}
	for(i=1;i&lt;=m;i++){
		rd();
		v[x].push_back({k,1});
		v[y+1].push_back({k,-1});
	}
	for(i=1;i&lt;=1000001;i++){
		for(auto [j,k]:v[i]){add(j,k);}
		for(auto [j,k]:q[i]){res+=get(k)-get(j-1);}
	}
	printf(&quot;%lld&quot;,res-n-m-3);
}</code></pre></details></td><td>Error</td><td>Error</td><td>Error</td><td>Error</td><td>Error</td><td><details class="code"><summary>View</summary><pre><code>Error</code></pre></details></td></tr>
<tr><td>1657D</td><td><a href="https://codeforces.com/problemset/problem/1657/d" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Hard</td><td>3619.0</td><td>78.3</td><td>O(nlogn)</td><td>O(n)</td><td>19</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
int n,c,x,y,z,f[9999999],m;
signed main()
{
	cin&gt;&gt;n&gt;&gt;c;
	for(int i=1;i&lt;=n;i++)
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z,f[x]=max(f[x],y*z);
	for(int i=1;i&lt;=c;i++)
	{
		for(int j=i;j&lt;=c;j+=i)
			f[j]=max(f[j],f[i]*j/i);
		f[i]=max(f[i],f[i-1]);
	}
	cin&gt;&gt;m;
	while(m--&amp;&amp;cin&gt;&gt;x&gt;&gt;y)
		cout&lt;&lt;((z=upper_bound(f+1,f+c+1,x*y)-f)&gt;c?-1:z)&lt;&lt;&#x27; &#x27;;
}</code></pre></details></td><td>624</td><td>11.8</td><td>O(nlogn)</td><td>O(n)</td><td>95</td><td><details class="code"><summary>View</summary><pre><code> #include &lt;bits/stdc++.h&gt;
using namespace std;
 
/*
Idea:
 
For a unit type (c, d, h) and k units of this type:
- Total damage per second = k * d
- Total health pool = k * h
Monster (D, H):
- Monster dies in time t_m = H / (k * d)
- Any one of our units dies in    t_u = h / D
 
We need t_m &lt; t_u:
  H / (k * d) &lt; h / D
  H * D &lt; k * d * h
So the minimal integer k is:
  k_min = floor((H*D) / (d*h)) + 1    (since strict inequality)
 
Cost with this type: coins = k_min * c.
 
But picking k units is allowed only if coins &lt;= C and k &gt;= 1.
 
Brute force over k for every query is impossible.
 
Reformulate:
For each type, and every possible total cost x (1..C), we can compute the
maximum &quot;effective power&quot; we can get with cost exactly x if we only use
this one unit type.
 
From inequality:
  H*D &lt; k*d*h
Let p = d*h.
Then requirement becomes:
  k*p &gt; H*D
 
For a fixed type, its per-unit &quot;power&quot; is p. With k units and total cost x=k*c:
- k = x / c
- total_power = (x / c) * p.
 
So for each type and each multiple of its cost not exceeding C, we know
a candidate total_power value:
  candPower[x] = max( candPower[x], (x/c)*p )
 
Then we can take prefix maximum:
  bestPower[x] = maximum total_power achievable using ANY single type
                 with total cost &lt;= x.
 
Then for a monster with (D,H), we need to find minimal x (1..C) such that:
  bestPower[x] &gt; H*D
 
This can be asked with binary search on x using the precomputed bestPower.
 
Complexities:
- Precompute powers: for each type,
    for (int cost = c; cost &lt;= C; cost += c)
        powerForCost[cost] = max(powerForCost[cost], (long long)(cost/c)*p);
  This is sum_{i=1..n} (C / c_i) operations, which is acceptable since c_i&gt;=1
  and C&lt;=1e6, n&lt;=3e5, but sum(C/c_i) can be large. However typical Codeforces
  solutions for this problem rely on exactly this sieve-like processing and
  it passes in 4 seconds in optimized C++.
 
To optimize, we can notice that if multiple unit types share the same c,
we just need the one with maximum p = d*h for that cost c, because at
multiples of c, cost/c is fixed and we multiply by the same (cost/c).
So:
  bestPerUnitPower[c] = max over all types having this c of (d*h).
Then:
  for each c where bestPerUnitPower[c]&gt;0:
      long long p = bestPerUnitPower[c];
      for (int cost = c; cost &lt;= C; cost += c)
          powerForCost[cost] = max(powerForCost[cost], (long long)(cost/c)*p);
 
This reduces complexity significantly because we now iterate over distinct c.
 
Steps:
1. Read n, C.
2. For each unit type read (c, d, h), compute p = 1LL*d*h.
   bestPerUnitPower[c] = max(bestPerUnitPower[c], p).
3. powerForCost[1..C] = 0.
4. For c in 1..C:
       if bestPerUnitPower[c]&gt;0:
           long long p = bestPerUnitPower[c];
           for (int cost = c, k = 1; cost &lt;= C; cost += c, ++k)
               powerForCost[cost] = max(powerForCost[cost], 1LL*k*p);
5. Make prefix max:
       for (int x=1; x&lt;=C; ++x)
           powerForCost[x] = max(powerForCost[x], powerForCost[x-1]);
 
Now for each monster (D,H):
   need minimal x such that powerForCost[x] &gt; H*D
   If powerForCost[C] &lt;= H*D, answer is -1.
   Otherwise binary search on [1..C].
 
Careful:
- H up to 1e12, D up to 1e6, product up to 1e18 -&gt; use long long (signed 64).
- p = d*h with d,h up to 1e6 -&gt; p up to 1e12.
- k up to C/c, max C=1e6, so k*p up to 1e18 -&gt; long long ok.
 
Complexities:
- Preprocessing ~ sum_{c : bestPerUnitPower[c]&gt;0} (C/c) &lt;= C * (1 + 1/2 + ... + 1/C)
  ~ C*logC ~ 1e6*~14 ~ 1.4e7 iterations, fine.
- Each monster query: binary search over [1..C] =&gt; logC ~ 20, with m&lt;=3e5:
  about 6e6 steps. Fits.
 
*/
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
 
    int n;
    int C;
    if (!(cin &gt;&gt; n &gt;&gt; C)) {
        return 0;
    }
 
    vector&lt;long long&gt; bestPerUnitPower(C + 1, 0);
    for (int i = 0; i &lt; n; ++i) {
        int c, d, h;
        cin &gt;&gt; c &gt;&gt; d &gt;&gt; h;
        long long p = 1LL * d * h;
        if (p &gt; bestPerUnitPower[c]) bestPerUnitPower[c] = p;
    }
 
    // powerForCost[x] = max total_power achievable using some single type with total cost exactly x.
    vector&lt;long long&gt; powerForCost(C + 1, 0);
 
    for (int c = 1; c &lt;= C; ++c) {
        long long p = bestPerUnitPower[c];
        if (p == 0) continue;
        long long k = 1;
        for (int cost = c; cost &lt;= C; cost += c, ++k) {
            long long totalPower = k * p;  // (cost / c) * p where cost = k*c
            if (totalPower &gt; powerForCost[cost]) {
                powerForCost[cost] = totalPower;
            }
        }
    }
 
    // Prefix maximum: with cost &lt;= x, what&#x27;s the best power?
    for (int x = 1; x &lt;= C; ++x) {
        if (powerForCost[x] &lt; powerForCost[x - 1]) {
            powerForCost[x] = powerForCost[x - 1];
        }
    }
 
    int m;
    cin &gt;&gt; m;
    while (m--) {
        long long D, H;
        cin &gt;&gt; D &gt;&gt; H;
        long long need = D * H;
 
        if (powerForCost[C] &lt;= need) {
            cout &lt;&lt; -1 &lt;&lt; &#x27; &#x27;;
            continue;
        }
 
        int lo = 1, hi = C, ans = C;
        while (lo &lt;= hi) {
            int mid = (lo + hi) &gt;&gt; 1;
            if (powerForCost[mid] &gt; need) {
                ans = mid;
                hi = mid - 1;
            } else {
                lo = mid + 1;
            }
        }
        cout &lt;&lt; ans &lt;&lt; &#x27; &#x27;;
    }
 
    return 0;
}</code></pre></details></td></tr>
<tr><td>1680C</td><td><a href="https://codeforces.com/contest/1680/problem/C" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Hard</td><td>62.0</td><td>2</td><td>O(n)</td><td>O(n)</td><td>10</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
 
using namespace std;
#define N 200005
int n,num[N];
char s[N];
int main(){
	int t;
	scanf(&quot;%d&quot;,&amp;t);
	while (t--){
		cin&gt;&gt;s;
		for (n=0;s[n];n++)
			num[n+1]=num[n]+(s[n]==&#x27;1&#x27;);
		int ans=num[n];
		for (int i=0;i+num[n]&lt;=n;i++)
			ans=min(ans,num[n]-num[i+num[n]]+num[i]);
		printf(&quot;%d\n&quot;,ans);
	}
} </code></pre></details></td><td>77</td><td>0</td><td>O(nlogn)</td><td>O(n)</td><td>45</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin &gt;&gt; T;
    while (T--) {
        string s;
        cin &gt;&gt; s;
        int n = (int)s.size();

        vector&lt;int&gt; pref(n+1, 0);
        for (int i = 0; i &lt; n; ++i) {
            pref[i+1] = pref[i] + (s[i] == &#x27;1&#x27;);
        }
        int totalOnes = pref[n];

        auto can = [&amp;](int x) -&gt; bool {
            // We need a subarray [l, r) (0-based, r &gt; = l) that can be the remaining part.
            // ones_in &gt;= totalOnes - x
            int need = max(0, totalOnes - x);

            int r = 0;
            for (int l = 0; l &lt;= n; ++l) {
                if (r &lt; l) r = l;
                // increase r until ones_in &gt;= need or r == n
                while (r &lt;= n &amp;&amp; pref[r] - pref[l] &lt; need) {
                    ++r;
                }
                if (r &gt; n) break;
                int len = r - l;
                int ones_in = pref[r] - pref[l];
                int zeros_in = len - ones_in;
                if (zeros_in &lt;= x) return true;
            }
            return false;
        };

        int lo = 0, hi = n, ans = n;
        while (lo &lt;= hi) {
            int mid = (lo + hi) / 2;
            if (can(mid)) {
                ans = mid;
                hi = mid - 1;
            } else {
                lo = mid + 1;
            }
        }
        cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>1681C</td><td><a href="https://codeforces.com/problemset/problem/1681/C" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Hard</td><td>109.0</td><td>0.1</td><td>O(n^2)</td><td>O(n^2)</td><td>20</td><td><details class="code"><summary>View</summary><pre><code>
#include&lt;bits/stdc++.h&gt;
using namespace std;
int _,n,i,j,cnt,t;
pair&lt;int,int&gt;a[101],ans[10001];
int main(){
ios::sync_with_stdio(0);cin.tie(0);
cin&gt;&gt;_;
while(_--){
cin&gt;&gt;n;cnt=0;t=0;
for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i].first;
for(i=1;i&lt;=n;i++)cin&gt;&gt;a[i].second;
for(i=1;i&lt;=n;i++)for(j=1;j&lt;=n;j++)if(a[i]&lt;a[j])ans[++t]={i,j},swap(a[i],a[j]);
for(i=1;i&lt;n;i++)if(a[i].first&lt;=a[i+1].first&amp;&amp;a[i].second&lt;=a[i+1].second)cnt++;
if(cnt==n-1){
cout&lt;&lt;t&lt;&lt;&quot;\n&quot;;
for(i=1;i&lt;=t;i++)cout&lt;&lt;ans[i].first&lt;&lt;&quot; &quot;&lt;&lt;ans[i].second&lt;&lt;&quot;\n&quot;;
}else cout&lt;&lt;-1&lt;&lt;&quot;\n&quot;;
}
}</code></pre></details></td><td>124</td><td>0</td><td>O(n^2)</td><td>O(n)</td><td>40</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    if (!(cin &gt;&gt; t)) return 0;
    while (t--) {
        int n;
        cin &gt;&gt; n;
        vector&lt;int&gt; a(n), b(n);
        for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i];
        for (int i = 0; i &lt; n; ++i) cin &gt;&gt; b[i];

        vector&lt;pair&lt;int,int&gt;&gt; ops;  // store swaps (i, j) 1-based

        // Bubble-sort-like process on key (a[i], b[i])
        for (int i = 0; i &lt; n; ++i) {
            for (int j = i + 1; j &lt; n; ++j) {
                if (a[i] &gt; a[j] || (a[i] == a[j] &amp;&amp; b[i] &gt; b[j])) {
                    swap(a[i], a[j]);
                    swap(b[i], b[j]);
                    ops.emplace_back(i + 1, j + 1);
                }
            }
        }

        // Check if b is non-decreasing
        bool ok = true;
        for (int i = 1; i &lt; n; ++i) {
            if (b[i] &lt; b[i - 1]) {
                ok = false;
                break;
            }
        }

        if (!ok || (int)ops.size() &gt; 10000) {
            cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;
        } else {
            cout &lt;&lt; ops.size() &lt;&lt; &quot;\n&quot;;
            for (auto &amp;p : ops) {
                cout &lt;&lt; p.first &lt;&lt; &quot; &quot; &lt;&lt; p.second &lt;&lt; &quot;\n&quot;;
            }
        }
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>1697B</td><td><a href="https://codeforces.com/problemset/problem/1697/B" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Hard</td><td>62.0</td><td>0</td><td>O(n^2)</td><td>O(n)</td><td>25</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,x;
char c;
string s;
vector&lt;int&gt; v;
int main(){
    cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		int l=-1,r=v.size();
		r--;
		while(l&lt;r){
			int m=(l+r+1)/2;
			cout&lt;&lt;&quot;? 2 &quot;&lt;&lt;v[m]+1&lt;&lt;&#x27; &#x27;&lt;&lt;i+1&lt;&lt;endl;
			cin&gt;&gt;x;
			if(x==v.size()-m+1){
				r=m-1;
			}else{
				l=m;
			}
		}
		if(l==-1){
			cout&lt;&lt;&quot;? 1 &quot;&lt;&lt;i+1&lt;&lt;endl;
			cin&gt;&gt;c;
			s+=c;
			v.push_back(i);
		}else{
			s+=s[v[l]];
			v[l]=i;
			sort(v.begin(),v.end());
		}
	}
	cout&lt;&lt;&quot;! &quot;&lt;&lt;s&lt;&lt;endl;
	return 0;
}</code></pre></details></td><td>108</td><td>0</td><td>O(n)</td><td>O(n)</td><td>70</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    if (!(cin &gt;&gt; n)) return 0;

    string ans(n + 1, &#x27;?&#x27;); // 1-indexed
    vector&lt;int&gt; last_pos;   // last positions of distinct characters, in some fixed order

    auto ask_char = [&amp;](int i) -&gt; char {
        cout &lt;&lt; &quot;? 1 &quot; &lt;&lt; i &lt;&lt; endl;
        cout.flush();
        char c;
        cin &gt;&gt; c;
        return c;
    };

    auto ask_distinct = [&amp;](int l, int r) -&gt; int {
        cout &lt;&lt; &quot;? 2 &quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl;
        cout.flush();
        int x;
        cin &gt;&gt; x;
        return x;
    };

    // distinct count up to previous position
    int prev_distinct = 0;

    for (int i = 1; i &lt;= n; ++i) {
        // number of distinct characters in prefix [1, i]
        int cur_distinct = ask_distinct(1, i);

        if (cur_distinct &gt; prev_distinct) {
            // new character at position i
            char c = ask_char(i);
            ans[i] = c;
            last_pos.push_back(i);
            prev_distinct = cur_distinct;
        } else {
            // character already seen before; determine which one
            // We maintain last_pos in an order that allows binary search.
            // Standard solution: sort current last_pos by their positions
            // at each step when needed (but they are naturally increasing).

            // Binary search over last_pos to find smallest index &#x27;pos&#x27;
            // such that the distinct count over [last_pos[pos], i]
            // equals (size - pos), i.e., all different from that suffix.
            int m = (int)last_pos.size();

            int L = 0, R = m - 1;
            int chosen_index = -1;

            // To apply a consistent logic, we process from right to left.
            // However, well-known solution sorts by character groups,
            // but here last_pos is always increasing, so we can binary search.
            //
            // We want to find the rightmost last position j such that
            // the number of distinct letters in [last_pos[j], i] equals 1
            // plus &quot;how many different last positions from j to end&quot;.
            //
            // But simpler, known trick:
            // Maintain characters ordered by last_pos ascending.
            // While binary searching, consider middle segment [mid, m-1].
            // Ask distinct in [ last_pos[mid], i ].
            // If that equals (m - mid + 1), then s[i] is among those;
            // else it&#x27;s in the left half.
            //
            while (L &lt;= R) {
                int mid = (L + R) / 2;
                int d = ask_distinct(last_pos[mid], i);
                int expect = m - mid; // number of candidates in [mid, m-1]
                if (d == expect) {
                    chosen_index = mid;
                    L = mid + 1; // try to find later one
                } else {
                    R = mid - 1;
                }
            }

            // chosen_index points to the correct character index in last_pos
            int pos = last_pos[chosen_index];
            char c = ans[pos];
            ans[i] = c;

            // update last_pos: move this index to the end (new last occurrence)
            last_pos.erase(last_pos.begin() + chosen_index);
            last_pos.push_back(i);
        }
    }

    cout &lt;&lt; &quot;! &quot;;
    for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; ans[i];
    cout &lt;&lt; endl;
    cout.flush();

    return 0;
}
</code></pre></details></td></tr>
<tr><td>1697B</td><td><a href="https://codeforces.com/problemset/problem/1697/B" target="_blank" rel="noopener">Link</a></td><td>Dynamic programming</td><td>Hard</td><td>15.0</td><td>0</td><td>O(n^3)</td><td>O(n^2)</td><td>55</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=105;
const int mo=998244353;
int n,x[N],y[N],mi[N],f[N],g[N];
vector&lt;int&gt;a[N];
int main()
{
ios::sync_with_stdio(false);
cin.tie(0),cout.tie(0);
cin&gt;&gt;n;
for (int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i];
for (int i=1;i&lt;=n;i++)
{
mi[i]=1e9;
for (int j=1;j&lt;=n;j++)
if (i^j)
{
mi[i]=min(mi[i],abs(x[i]-x[j])+abs(y[i]-y[j]));
}
for (int j=1;j&lt;=n;j++) if (abs(x[i]-x[j])+abs(y[i]-y[j])&lt;=mi[i]) a[i].emplace_back(j);
sort(a[i].begin(),a[i].end());
}
sort(a+1,a+n+1);
f[0]=1;
for (int i=1;i&lt;=n;)
{
int j=i;
while (a[i]==a[j]) j++;
memcpy(g,f,sizeof(g));
for (int l=0;l&lt;j-i;l++)
{
for (int k=i+l;k;k--) f[k]=1ll*f[k-1]*(n-k+1)%mo;
f[0]=0;
}
if (j-i==a[i].size())
{
for (int k=j-1;k;k--) f[k]=(f[k]+1ll*g[k-1]*(n-k+1))%mo;
}
i=j;
}
int ans=0;
for (int i=1;i&lt;=n;i++) ans=(ans+f[i])%mo;
cout&lt;&lt;ans;
return 0;
}</code></pre></details></td><td>Error</td><td>Error</td><td>Error</td><td>Error</td><td>Error</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

const int MOD = 998244353;

long long mod_pow(long long a, long long e) {
    long long r = 1;
    while (e &gt; 0) {
        if (e &amp; 1) r = r * a % MOD;
        a = a * a % MOD;
        e &gt;&gt;= 1;
    }
    return r;
}

int addmod(int a, int b) {
    a += b;
    if (a &gt;= MOD) a -= MOD;
    return a;
}

int mulmod(long long a, long long b) {
    return int(a * b % MOD);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    if (!(cin &gt;&gt; n)) return 0;
    vector&lt;long long&gt; x(n), y(n);
    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; x[i] &gt;&gt; y[i];

    // Precompute all distances
    const long long INF = (long long)4e18;
    vector&lt;vector&lt;long long&gt;&gt; d(n, vector&lt;long long&gt;(n, 0));
    for (int i = 0; i &lt; n; ++i)
        for (int j = 0; j &lt; n; ++j)
            d[i][j] = llabs(x[i] - x[j]) + llabs(y[i] - y[j]);

    // Check &quot;good clusters&quot;
    vector&lt;int&gt; best_cnt(n);
    vector&lt;bool&gt; good(n, true);
    for (int i = 0; i &lt; n; ++i) {
        long long mn = INF;
        for (int j = 0; j &lt; n; ++j)
            if (i != j) mn = min(mn, d[i][j]);

        vector&lt;int&gt; v;
        for (int j = 0; j &lt; n; ++j)
            if (i != j &amp;&amp; d[i][j] == mn) v.push_back(j);

        // i plus all with minimal distance form candidate cluster
        v.push_back(i);

        int sz = (int)v.size();
        best_cnt[i] = sz;

        // verify that cluster is &quot;good&quot;:
        // 1) each point in cluster has exactly cluster size-1 neighbors at same minimal distance
        // 2) cluster is a clique with equal distances for each pair
        for (int k = 0; k &lt; sz; ++k) {
            int u = v[k];
            long long mn_u = INF;
            for (int j = 0; j &lt; n; ++j)
                if (j != u) mn_u = min(mn_u, d[u][j]);

            // collect all neighbors at minimal distance from u
            vector&lt;int&gt; tmp;
            for (int j = 0; j &lt; n; ++j)
                if (j != u &amp;&amp; d[u][j] == mn_u) tmp.push_back(j);

            if ((int)tmp.size() + 1 != sz) { // +1 for u itself
                good[i] = false;
                break;
            }

            // check that v minus u equals tmp
            // build sets for comparison
            vector&lt;int&gt; s1, s2;
            for (int t : v) if (t != u) s1.push_back(t);
            sort(s1.begin(), s1.end());
            sort(tmp.begin(), tmp.end());
            if (s1 != tmp) {
                good[i] = false;
                break;
            }
        }

        if (!good[i]) continue;

        // Additional strong check: within cluster all mutual distances must obey:
        // if two points a,b in cluster and c outside, then d(a,b) &lt; d(a,c),d(b,c)
        // but this is automatically satisfied by the way cluster is constructed in this problem&#x27;s known solution.
        // So no extra check needed beyond structure above.
    }

    // Mark clusters via DSU-like greedy: since n &lt;= 100, just use visited + repeated scan
    vector&lt;int&gt; used(n, 0);
    vector&lt;int&gt; sizes; // sizes of taken good clusters
    for (int i = 0; i &lt; n; ++i) {
        if (!good[i] || used[i]) continue;

        // reconstruct its cluster from point i
        long long mn = INF;
        for (int j = 0; j &lt; n; ++j)
            if (i != j) mn = min(mn, d[i][j]);
        vector&lt;int&gt; v;
        for (int j = 0; j &lt; n; ++j)
            if (i != j &amp;&amp; d[i][j] == mn) v.push_back(j);
        v.push_back(i);
        sort(v.begin(), v.end());
        v.erase(unique(v.begin(), v.end()), v.end());

        bool conflict = false;
        for (int u : v)
            if (used[u]) {
                conflict = true;
                break;
            }
        if (conflict) continue; // cannot take this cluster (overlaps an already used point)

        // verify that every vertex in this v has this exact cluster as its best, and is &quot;good&quot;
        for (int u : v) {
            if (!good[u] || best_cnt[u] != (int)v.size()) {
                conflict = true;
                break;
            }
            long long mn_u = INF;
            for (int j = 0; j &lt; n; ++j)
                if (j != u) mn_u = min(mn_u, d[u][j]);
            vector&lt;int&gt; cand;
            for (int j = 0; j &lt; n; ++j)
                if (j != u &amp;&amp; d[u][j] == mn_u) cand.push_back(j);
            cand.push_back(u);
            sort(cand.begin(), cand.end());
            cand.erase(unique(cand.begin(), cand.end()), cand.end());
            if (cand != v) {
                conflict = true;
                break;
            }
        }
        if (conflict) continue;

        // accept this cluster
        for (int u : v) used[u] = 1;
        sizes.push_back((int)v.size());
    }

    int remaining = 0;
    for (int i = 0; i &lt; n; ++i)
        if (!used[i]) ++remaining;

    // DP over clusters
    // dp[k] = number of ways to have colored &quot;k&quot; positions when only handling clusters
    vector&lt;int&gt; dp(n + 1, 0), ndp(n + 1, 0);
    dp[0] = 1;
    int sum = 0;
    for (int sz : sizes) {
        fill(ndp.begin(), ndp.end(), 0);
        for (int used_cnt = 0; used_cnt &lt;= sum; ++used_cnt) {
            int cur = dp[used_cnt];
            if (!cur) continue;

            // Option 1: treat cluster as one super-vertex
            ndp[used_cnt + 1] = addmod(ndp[used_cnt + 1], cur);

            // Option 2: treat cluster as sz separate vertices
            ndp[used_cnt + sz] = addmod(ndp[used_cnt + sz], cur);
        }
        sum += sz;
        dp.swap(ndp);
    }

    // precompute factorials
    vector&lt;int&gt; fact(n + 1, 1);
    for (int i = 1; i &lt;= n; ++i)
        fact[i] = mulmod(fact[i - 1], i);

    long long ans = 0;
    for (int k = 0; k &lt;= n; ++k) {
        if (!dp[k]) continue;
        int comp = k + remaining; // total components (super-vertices + singletons)
        ans = (ans + 1LL * dp[k] * fact[comp]) % MOD;
    }

    cout &lt;&lt; ans % MOD &lt;&lt; &#x27;\n&#x27;;
    return 0;
}
</code></pre></details></td></tr>
<tr><td>1739D</td><td><a href="https://codeforces.com/problemset/problem/1739/D" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Hard</td><td>62.0</td><td>1.6</td><td>O(nlogn)</td><td>O(n)</td><td>27</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
 
int n,k,t,fa[200005],d[200005];
 
bool ok(int w){
	int ans=0;
	for(int i=2;i&lt;=n;i++) d[i]=1;
	for(int i=n;i&gt;=2;i--){
		if(d[i]==w &amp;&amp; fa[i]!=1) ans++;
		else d[fa[i]]=max(d[fa[i]],d[i]+1);
	}
	return ans&lt;=k;
}
 
main(){
	scanf(&quot;%d&quot;,&amp;t);
	while(t--){
		scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
		d[1]=0;
		for(int i=2;i&lt;=n;i++) scanf(&quot;%d&quot;, fa + i);
		int l=1,r=n;
		while(l&lt;=r){
			int mid=(l+r)/2;
			if(ok(mid)) r=mid-1;
			else l=mid+1;
		}
		printf(&quot;%d\n&quot;,l);
	}
}
</code></pre></details></td><td>error</td><td>error</td><td>error</td><td>error</td><td>62</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t; cin &gt;&gt; t;
    while (t--) {
        int n, k;
        cin &gt;&gt; n &gt;&gt; k;

        vector&lt;int&gt; parent(n+1);
        parent[1] = 0;
        for (int i = 2; i &lt;= n; i++) cin &gt;&gt; parent[i];

        vector&lt;vector&lt;int&gt;&gt; tree(n+1);
        for (int i = 2; i &lt;= n; i++) {
            tree[parent[i]].push_back(i);
        }

        vector&lt;int&gt; depth(n+1, 0);
        queue&lt;int&gt; q;
        q.push(1);
        int max_depth = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int v : tree[u]) {
                depth[v] = depth[u] + 1;
                max_depth = max(max_depth, depth[v]);
                q.push(v);
            }
        }

        // Counting number of edges we need to cut to get height &lt;= h
        // We&#x27;ll binary search on height h

        auto canAchieve = [&amp;](int h) {
            int cuts = 0;
            // Traverse from deepest to shallowest using a DFS or bottom-up approach
            // Mark nodes deeper than h as needing to be detached (cut)
            vector&lt;int&gt; need_cut(n+1, 0);

            function&lt;void(int)&gt; dfs = [&amp;](int u) {
                int cnt = 0;
                for (int v : tree[u]) {
                    dfs(v);
                    cnt += need_cut[v];
                }
                if (depth[u] &gt; h) {
                    // This subtree needs to be reset (detach edge)
                    cuts++;
                    need_cut[u] = 0;  // no need to propagate up
                } else {
                    need_cut[u] = cnt;
                }
            };
            dfs(1);

            return cuts &lt;= k;
        };

        int low = 1, high = max_depth, ans = max_depth;
        while (low &lt;= high) {
            int mid = (low + high) / 2;
            if (canAchieve(mid)) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    }

    return 0;
}
</code></pre></details></td></tr>
<tr><td>1400C</td><td><a href="https://codeforces.com/problemset/problem/1400/C" target="_blank" rel="noopener">Link</a></td><td>Greedy</td><td>Medium</td><td>30.0</td><td>4</td><td>O(n)</td><td>O(n)</td><td>15</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;iostream&gt;
using namespace std;
main(){
 int t,x,f,n,i;
 string s,p;
 for(cin&gt;&gt;t;t--;){
  for(cin&gt;&gt;s&gt;&gt;x,n=s.size(),i=0,p=string (n,49);i&lt;n;++i){
   if(s[i]^49){
    if(i&gt;=x) p[i-x]=48;
    if(i+x&lt;n) p[i+x]=48;
   }
  }
  for(i=f=0;i&lt;n;++i)
   f|=(s[i]&amp;1 &amp; (i&lt;x||p[i-x]^49)&amp;(i+x&gt;=n||p[i+x]^49));
  cout&lt;&lt;(f?&quot;-1&quot;:p)&lt;&lt;&quot;\n&quot;;
 }
}</code></pre></details></td><td>77</td><td>0</td><td>O(n)</td><td>O(n)</td><td>30</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
 
    int t;
    cin &gt;&gt; t;
    while (t--) {
        string s;
        int x;
        cin &gt;&gt; s &gt;&gt; x;
        int n = (int)s.size();
 
        // Start with all &#x27;1&#x27;s in w
        string w(n, &#x27;1&#x27;);
 
        // Step 1: enforce constraints from positions where s[i] == &#x27;0&#x27;
        for (int i = 0; i &lt; n; ++i) {
            if (s[i] == &#x27;0&#x27;) {
                if (i - x &gt;= 0)  w[i - x] = &#x27;0&#x27;;
                if (i + x &lt; n)   w[i + x] = &#x27;0&#x27;;
            }
        }
 
        // Step 2: verify w produces s
        string tstr(n, &#x27;0&#x27;);
        for (int i = 0; i &lt; n; ++i) {
            bool one = false;
            if (i - x &gt;= 0 &amp;&amp; w[i - x] == &#x27;1&#x27;) one = true;
            if (i + x &lt; n &amp;&amp; w[i + x] == &#x27;1&#x27;)  one = true;
            tstr[i] = one ? &#x27;1&#x27; : &#x27;0&#x27;;
        }
 
        if (tstr == s) {
            cout &lt;&lt; w &lt;&lt; &#x27;\n&#x27;;
        } else {
            cout &lt;&lt; -1 &lt;&lt; &#x27;\n&#x27;;
        }
    }
 
    return 0;
}</code></pre></details></td></tr>
<tr><td>1400D</td><td><a href="https://codeforces.com/problemset/problem/1400/D" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Medium</td><td>56.0</td><td>0.8</td><td>O(n^2)</td><td>O(n)</td><td>20</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
 
main(){
	int t;
	cin&gt;&gt;t;
 
	while(t--){
		int n;
		cin&gt;&gt;n;
 
		int a[n];
		for(auto &amp;it : a)  cin&gt;&gt;it;
 
		int left[3003] = {0};
		long long ans = 0;
 
		for(int j=0; j&lt;n; j++){
			int right[3003] = {0};
			for(int k=n-1; k&gt;j; k--){
				ans += left[a[k]]*right[a[j]];
				right[a[k]]++;
			}
			left[a[j]]++;
		}
		cout&lt;&lt;ans&lt;&lt;endl;
	}
}</code></pre></details></td><td>93</td><td>0</td><td>O(n^2)</td><td>O(n)</td><td>40</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
 
    int T;
    cin &gt;&gt; T;
    while (T--) {
        int n;
        cin &gt;&gt; n;
        vector&lt;int&gt; a(n);
        for (int i = 0; i &lt; n; ++i) {
            cin &gt;&gt; a[i];
        }
 
        long long ans = 0;
        // values are in [1, n]
        vector&lt;long long&gt; pref(n + 1), suff(n + 1);
 
        // Fix k as the third index in (i, j, k, l)
        for (int k = 0; k &lt; n; ++k) {
            // prefix counts for i &lt; j &lt; k
            fill(pref.begin(), pref.end(), 0);
            // suffix counts for l &gt; k
            fill(suff.begin(), suff.end(), 0);
            for (int l = k + 1; l &lt; n; ++l) {
                suff[a[l]]++;
            }
 
            // j goes from 0 .. k-1
            for (int j = 0; j &lt; k; ++j) {
                // count pairs (i, l) for this (j, k)
                // ai = ak: choose i from left where a[i] == a[k] -&gt; pref[a[k]]
                // aj = al: choose l from right where a[l] == a[j] -&gt; suff[a[j]]
                ans += pref[a[k]] * suff[a[j]];
 
                // now j becomes available as an i for future larger j
                pref[a[j]]++;
            }
        }
 
        cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;
    }
 
    return 0;
}</code></pre></details></td></tr>
<tr><td>1401C</td><td><a href="https://codeforces.com/problemset/problem/1401/C" target="_blank" rel="noopener">Link</a></td><td>Greedy</td><td>Medium</td><td>171.0</td><td>1.6</td><td>O(nlogn)</td><td>O(n)</td><td>12</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
int t,n,i,a[200007],m,b[200007],f;
using std::cin;
int main(){
for(cin&gt;&gt;t; t--; puts(f?&quot;NO&quot;:&quot;YES&quot;)){
for(cin&gt;&gt;n,i=f=0; i++&lt;n;)
cin&gt;&gt;a[i],b[i]=a[i];
for(std::sort(a,a+i); i--;)
f+=(a[i]^b[i]&amp;&amp;b[i]%a[1]);
}
return 0;
}</code></pre></details></td><td>93</td><td>0</td><td>O(nlogn)</td><td>O(n)</td><td>32</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
 
    int t;
    if (!(cin &gt;&gt; t)) return 0;
    while (t--) {
        int n;
        cin &gt;&gt; n;
        vector&lt;long long&gt; a(n), b(n);
        long long mn = LLONG_MAX;
        for (int i = 0; i &lt; n; ++i) {
            cin &gt;&gt; a[i];
            b[i] = a[i];
            mn = min(mn, a[i]);
        }
 
        sort(b.begin(), b.end());
 
        bool ok = true;
        for (int i = 0; i &lt; n; ++i) {
            if (a[i] != b[i] &amp;&amp; a[i] % mn != 0) {
                ok = false;
                break;
            }
        }
 
        cout &lt;&lt; (ok ? &quot;YES\n&quot; : &quot;NO\n&quot;);
    }
 
    return 0;
}</code></pre></details></td></tr>
<tr><td>1401D</td><td><a href="https://codeforces.com/problemset/problem/1401/D" target="_blank" rel="noopener">Link</a></td><td>Tree</td><td>Medium</td><td>327.0</td><td>41.2</td><td>O(nlogn)</td><td>O(n)</td><td>40</td><td><details class="code"><summary>View</summary><pre><code>
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int N=1000005;
ll sz[N],a[N],ans,mod=ll(1e9+7),b[N];
vector&lt;int&gt; G[N];
void dfs(int p,int fa)
{
	sz[p]=1;
	for(int i=0;i&lt;G[p].size();i++) if(G[p][i]!=fa) dfs(G[p][i],p),sz[p]+=sz[G[p][i]];
}
int main()
{
	int t;
	cin&gt;&gt;t;
	while(t--)
	{
		int n,m,x,y;
		cin&gt;&gt;n;
		ans=0;
		for(int i=1;i&lt;=n;i++) G[i].clear(),a[i]=1;
		for(int i=1;i&lt;n;i++) cin&gt;&gt;x&gt;&gt;y,G[x].push_back(y),G[y].push_back(x);
		dfs(1,0);
		cin&gt;&gt;m;
		for(int i=1;i&lt;=m;i++) cin&gt;&gt;a[i];
		m=max(n-1,m);
		sort(a+1,a+1+m);
		if(m&gt;n-1) for(int i=n;i&lt;=m;i++) a[n-1]=a[n-1]%mod*a[i]%mod,a[n-1]%=mod;
		for(int i=1;i&lt;n;i++) b[i]=(n-sz[i+1])*sz[i+1];
		sort(b+1,b+n);
		for(int i=1;i&lt;n;i++) ans=ans%mod+(b[i]%mod*a[i]%mod)%mod,ans%=mod;
		cout&lt;&lt;ans%mod&lt;&lt;&quot;\n&quot;;
	}
}</code></pre></details></td><td>171</td><td>11.3</td><td>O(nlogn)</td><td>O(n)</td><td>60</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
const long long MOD = 1e9 + 7;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
 
    int T;
    cin &gt;&gt; T;
    while (T--) {
        int n;
        cin &gt;&gt; n;
        vector&lt;vector&lt;int&gt;&gt; adj(n + 1);
        for (int i = 0; i &lt; n - 1; ++i) {
            int u, v;
            cin &gt;&gt; u &gt;&gt; v;
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
 
        // 1) Compute edge contributions: sz * (n - sz) for each edge
        vector&lt;long long&gt; contrib;
        contrib.reserve(n - 1);
        vector&lt;int&gt; sub(n + 1, 0);
 
        function&lt;void(int,int)&gt; dfs = [&amp;](int u, int p) {
            sub[u] = 1;
            for (int v : adj[u]) {
                if (v == p) continue;
                dfs(v, u);
                long long sz = sub[v];
                contrib.push_back(sz * 1LL * (n - sz));
                sub[u] += sub[v];
            }
        };
        dfs(1, 0);
 
        // Sort contributions in descending order
        sort(contrib.begin(), contrib.end(), greater&lt;long long&gt;());
 
        int m;
        cin &gt;&gt; m;
        vector&lt;long long&gt; primes(m);
        for (int i = 0; i &lt; m; ++i) cin &gt;&gt; primes[i];
 
        vector&lt;long long&gt; mult;
 
        if (m &lt;= n - 1) {
            // Fewer or equal primes than edges:
            // We want primes assigned to largest contribs, ones to smallest.
            // So we create mult of size n-1:
            // first m positions = primes (sorted descending),
            // last (n-1-m) positions = 1.
            sort(primes.begin(), primes.end(), greater&lt;long long&gt;()); // descending
            mult.assign(n - 1, 1);
            for (int i = 0; i &lt; m; ++i) {
                mult[i] = primes[i] % MOD;
            }
        } else {
            // More primes than edges.
            // Combine extra primes (largest ones) into one big multiplier.
            sort(primes.begin(), primes.end(), greater&lt;long long&gt;()); // descending
 
            int extra = m - (n - 1);
            long long big = 1;
            // Combine largest extra+1 primes
            for (int i = 0; i &lt;= extra; ++i) {
                big = (big * (primes[i] % MOD)) % MOD;
            }
            mult.push_back(big);
            for (int i = extra + 1; i &lt; m; ++i) {
                mult.push_back(primes[i] % MOD);
            }
 
            // mult now has n-1 elements but may not be sorted
            sort(mult.begin(), mult.end(), greater&lt;long long&gt;());
        }
 
        // Now contrib and mult are both size n-1 and sorted descending.
        long long ans = 0;
        for (int i = 0; i &lt; n - 1; ++i) {
            long long c = contrib[i] % MOD;
            long long w = mult[i] % MOD;
            ans = (ans + c * w) % MOD;
        }
 
        cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;
    }
 
    return 0;
}</code></pre></details></td></tr>
<tr><td>1657B</td><td><a href="https://codeforces.com/problemset/problem/1657/B" target="_blank" rel="noopener">Link</a></td><td>Maths</td><td>Medium</td><td>46.0</td><td>0</td><td>O(n)</td><td>O(1)</td><td>16</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	long long tt,n,b,x,y,t,s,i;
	cin&gt;&gt;tt;
	while(tt--){
		cin&gt;&gt;n&gt;&gt;b&gt;&gt;x&gt;&gt;y;
		t=0;s=0;
		for(i=1;i&lt;=n;i++){
			if(t+x&lt;=b) t+=x;
			else t-=y;
			s+=t;
		}
		cout&lt;&lt;s&lt;&lt;endl;
	}
}</code></pre></details></td><td>77</td><td>0</td><td>O(n)</td><td>O(1)</td><td>29</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    if (!(cin &gt;&gt; t)) return 0;
    while (t--) {
        long long n, B, x, y;
        cin &gt;&gt; n &gt;&gt; B &gt;&gt; x &gt;&gt; y;
        long long cur = 0;
        long long sum = 0;
        for (long long i = 0; i &lt;= n; ++i) {
            // add current value to sum
            sum += cur;
            // choose next value for a_{i+1}, unless this is the last iteration
            if (i == n) break;
            if (cur + x &lt;= B) {
                cur += x;
            } else {
                cur -= y;
            }
        }
        cout &lt;&lt; sum &lt;&lt; &#x27;\n&#x27;;
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>1671C</td><td><a href="https://codeforces.com/problemset/problem/1671/C" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Medium</td><td>358.0</td><td>1.6</td><td>O(nlogn)</td><td>O(n)</td><td>25</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
 
int main(){
ll t; cin&gt;&gt;t;
while(t--){
ll n,x; cin&gt;&gt;n&gt;&gt;x; ll a[n]; ll sum=0; ll ans=0;
for(ll i=0;i&lt;n;i++){ cin&gt;&gt;a[i];}
sort(a,a+n);
for(ll i=0;i&lt;n;i++){
sum+=a[i];
if(x-sum&gt;=0) ans+=((x-sum)/(i+1))+1;
}
cout&lt;&lt;ans&lt;&lt;endl;
}
}</code></pre></details></td><td>108</td><td>0</td><td>O(nlogn)</td><td>O(n)</td><td>25</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin &gt;&gt; T;
    while (T--) {
        int n;
        long long x;
        cin &gt;&gt; n &gt;&gt; x;
        vector&lt;long long&gt; a(n);
        for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i];

        sort(a.begin(), a.end());

        vector&lt;long long&gt; pref(n + 1, 0);
        for (int i = 0; i &lt; n; ++i)
            pref[i + 1] = pref[i] + a[i];

        long long ans = 0;
        for (int k = 1; k &lt;= n; ++k) {
            if (pref[k] &gt; x) break;
            // number of days (1-based) when we can buy k cheapest packs
            long long days = (x - pref[k]) / k + 1;
            ans += days;
        }

        cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;
    }

    return 0;
}
</code></pre></details></td></tr>
<tr><td>1680B</td><td><a href="https://codeforces.com/problemset/problem/1680/B" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Medium</td><td>61.0</td><td>0</td><td>O(n^2)</td><td>O(1)</td><td>12</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int s[6][6];
int main(){
	int t;cin&gt;&gt;t;
	while(t--){
		int n,m;cin&gt;&gt;n&gt;&gt;m;
		int xx=n,yy=m;
		char c;
		for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++){
			cin&gt;&gt;c;
			if(c==&#x27;R&#x27;) xx=min(xx,i),yy=min(yy,j);
			s[i][j]=c;
		}
		if(s[xx][yy]==&#x27;R&#x27;) puts(&quot;YES&quot;);
		else puts(&quot;NO&quot;);
	}
}</code></pre></details></td><td>46</td><td>0</td><td>O(n^2)</td><td>O(1)</td><td>30</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    if (!(cin &gt;&gt; t)) return 0;
    while (t--) {
        int n, m;
        cin &gt;&gt; n &gt;&gt; m;
        vector&lt;string&gt; g(n);
        for (int i = 0; i &lt; n; ++i) cin &gt;&gt; g[i];

        int minRow = n;        // minimal row having any R
        int minColAll = m;     // minimal column among all R

        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; m; ++j) {
                if (g[i][j] == &#x27;R&#x27;) {
                    minRow = min(minRow, i);
                    minColAll = min(minColAll, j);
                }
            }
        }

        // In the topmost row that has an R, find the leftmost R
        int minColRow = m;
        for (int j = 0; j &lt; m; ++j) {
            if (g[minRow][j] == &#x27;R&#x27;) {
                minColRow = j;
                break;
            }
        }

        if (minColRow == minColAll) cout &lt;&lt; &quot;YES\n&quot;;
        else cout &lt;&lt; &quot;NO\n&quot;;
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>1681B</td><td><a href="https://codeforces.com/problemset/problem/1681/B" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Medium</td><td>530.0</td><td>3.9</td><td>O(n)</td><td>O(n)</td><td>12</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int t,n,m,a[1000005],x,p;
int main(){
	cin&gt;&gt;t;
	while(t--){
		cin&gt;&gt;n;
		for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i];
		cin&gt;&gt;m;
		for(int i=1;i&lt;=m;i++)cin&gt;&gt;x,p=(p+x)%n;
		cout&lt;&lt;a[p]&lt;&lt;endl;
		p=0;
	}
}</code></pre></details></td><td>140</td><td>0</td><td>O(n)</td><td>O(n)</td><td>25</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    if (!(cin &gt;&gt; T)) return 0;
    while (T--) {
        int n;
        cin &gt;&gt; n;
        vector&lt;int&gt; a(n);
        for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i];

        int m;
        cin &gt;&gt; m;
        long long sum = 0;
        for (int i = 0; i &lt; m; ++i) {
            long long b;
            cin &gt;&gt; b;
            sum += b;
            if (sum &gt;= (long long)n) sum %= n;  // keep it small
        }

        int idx = (int)(sum % n);  // 0-based index
        cout &lt;&lt; a[idx] &lt;&lt; &#x27;\n&#x27;;
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>1697B</td><td><a href="https://codeforces.com/problemset/problem/1697/B" target="_blank" rel="noopener">Link</a></td><td>Greedy</td><td>Medium</td><td>1500.0</td><td>1.5</td><td>O(nlogn)</td><td>O(n)</td><td>19</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
 
int main()
{
ll n,q,x,y,i;
cin&gt;&gt;n&gt;&gt;q;
ll p[n+1]; p[0]=0;
for(i=0;i&lt;n;i++) cin&gt;&gt;p[i+1];
sort(p,p+n+1);
for(i=1;i&lt;=n;i++)
p[i]+=p[i-1];
 
while(q--){
cin&gt;&gt;x&gt;&gt;y;
cout&lt;&lt;(p[n+y-x]-p[n-x])&lt;&lt;endl;
}
}</code></pre></details></td><td>343</td><td>0</td><td>O(nlogn)</td><td>O(n)</td><td>34</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, q;
    cin &gt;&gt; n &gt;&gt; q;
    vector&lt;long long&gt; p(n);
    for (int i = 0; i &lt; n; ++i) {
        cin &gt;&gt; p[i];
    }

    // Sort prices in descending order
    sort(p.begin(), p.end(), greater&lt;long long&gt;());

    // Build prefix sums (1-indexed for convenience)
    vector&lt;long long&gt; pref(n + 1, 0);
    for (int i = 1; i &lt;= n; ++i) {
        pref[i] = pref[i - 1] + p[i - 1];
    }

    while (q--) {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        // Free items are the y cheapest among the x most expensive:
        // indices [x - y + 1 .. x] in 1-based, so sum = pref[x] - pref[x - y]
        long long ans = pref[x] - pref[x - y];
        cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    }

    return 0;
}
</code></pre></details></td></tr>
<tr><td>1697C</td><td><a href="https://codeforces.com/problemset/problem/1697/C" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Medium</td><td>1794.0</td><td>0.4</td><td>O(n^2)</td><td>O(n)</td><td>18</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int q,n;string s,t;
int main(){
	cin&gt;&gt;q;
	while(q--){
		cin&gt;&gt;n&gt;&gt;s&gt;&gt;t;
		for(int i=0;i&lt;n;i++){
			int j=i+1;
			if(s[i]==t[i])continue;
			while(j&lt;n&amp;&amp;s[j]==s[i])j++;
			if(j&lt;n&amp;&amp;s[j]==t[i]&amp;&amp;s[j]==s[i]+1)swap(s[j],s[i]);
		}
		if(s==t)printf(&quot;YES\n&quot;);
		else printf(&quot;NO\n&quot;);
	}
	return 0;
}</code></pre></details></td><td>77</td><td>0</td><td>O(n)</td><td>O(n)</td><td>60</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int q;
    if (!(cin &gt;&gt; q)) return 0;
    while (q--) {
        int n;
        cin &gt;&gt; n;
        string s, t;
        cin &gt;&gt; s &gt;&gt; t;

        // 1. Check counts of a, b, c
        array&lt;int, 3&gt; cntS = {0, 0, 0}, cntT = {0, 0, 0};
        for (int i = 0; i &lt; n; ++i) {
            if (s[i] == &#x27;a&#x27;) cntS[0]++;
            else if (s[i] == &#x27;b&#x27;) cntS[1]++;
            else cntS[2]++;

            if (t[i] == &#x27;a&#x27;) cntT[0]++;
            else if (t[i] == &#x27;b&#x27;) cntT[1]++;
            else cntT[2]++;
        }
        if (cntS != cntT) {
            cout &lt;&lt; &quot;NO\n&quot;;
            continue;
        }

        // 2. Remove all &#x27;b&#x27; and compare order of &#x27;a&#x27; and &#x27;c&#x27;
        string s2, t2;
        for (char c : s) if (c != &#x27;b&#x27;) s2.push_back(c);
        for (char c : t) if (c != &#x27;b&#x27;) t2.push_back(c);
        if (s2 != t2) {
            cout &lt;&lt; &quot;NO\n&quot;;
            continue;
        }

        // 3. Collect positions of &#x27;a&#x27; and &#x27;c&#x27; and check directional constraints
        vector&lt;int&gt; posSa, posTa, posSc, posTc;
        for (int i = 0; i &lt; n; ++i) {
            if (s[i] == &#x27;a&#x27;) posSa.push_back(i);
            if (t[i] == &#x27;a&#x27;) posTa.push_back(i);
            if (s[i] == &#x27;c&#x27;) posSc.push_back(i);
            if (t[i] == &#x27;c&#x27;) posTc.push_back(i);
        }

        bool ok = true;
        // a&#x27;s can only move to the right: starting index &lt;= target index
        for (int i = 0; i &lt; (int)posSa.size(); ++i) {
            if (posSa[i] &gt; posTa[i]) {
                ok = false;
                break;
            }
        }
        // c&#x27;s can only move to the left: starting index &gt;= target index
        if (ok) {
            for (int i = 0; i &lt; (int)posSc.size(); ++i) {
                if (posSc[i] &lt; posTc[i]) {
                    ok = false;
                    break;
                }
            }
        }

        cout &lt;&lt; (ok ? &quot;YES\n&quot; : &quot;NO\n&quot;);
    }

    return 0;
}
</code></pre></details></td></tr>
<tr><td>1739B</td><td><a href="https://codeforces.com/problemset/problem/1739/B" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Medium</td><td>31.0</td><td>0</td><td>O(n)</td><td>O(1)</td><td>21</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,d[101],a[101];
void o(){
  int i;
  for(i=1;i&lt;=n;++i)cin&gt;&gt;d[i];
  for(i=1;i&lt;=n;++i)
    if(a[i-1]&lt;d[i]||!a[i-1]||!d[i])a[i]=a[i-1]+d[i];
  else{puts(&quot;-1&quot;);return;}
  for(i=1;i&lt;=n;++i)cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;;cout&lt;&lt;&#x27;\n&#x27;;
}
main(){
  for(cin&gt;&gt;n;cin&gt;&gt;n;o());
}</code></pre></details></td><td>92</td><td>0</td><td>O(n)</td><td>O(n)</td><td>37</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t; cin &gt;&gt; t;
    while (t--) {
        int n; cin &gt;&gt; n;
        vector&lt;int&gt; d(n);
        for (int i = 0; i &lt; n; i++) cin &gt;&gt; d[i];

        // We&#x27;ll reconstruct array a
        vector&lt;int&gt; a(n);
        a[0] = d[0];

        // To detect multiple solutions:
        // At each step, a[i] can be either a[i-1] + d[i] or a[i-1] - d[i].
        // We&#x27;ll try to pick one consistent with the constraints.
        // If more than one sequence is possible, print -1.

        bool ambiguous = false;

        for (int i = 1; i &lt; n; i++) {
            int plus_candidate = a[i-1] + d[i];
            int minus_candidate = a[i-1] - d[i];

            if (plus_candidate &lt; 0 &amp;&amp; minus_candidate &lt; 0) {
                // Non-negative constraint violated (should not happen as per problem statement)
                ambiguous = true;
                break;
            } else if (plus_candidate &lt; 0) {
                a[i] = minus_candidate;
            } else if (minus_candidate &lt; 0) {
                a[i] = plus_candidate;
            } else {
                // Both are non-negative, ambiguity arises if plus_candidate != minus_candidate
                if (plus_candidate != minus_candidate) {
                    ambiguous = true;
                    break;
                } else {
                    // both are same, pick one
                    a[i] = plus_candidate;
                }
            }
        }

        if (ambiguous) {
            cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;
        } else {
            for (int i = 0; i &lt; n; i++) {
                cout &lt;&lt; a[i] &lt;&lt; (i == n - 1 ? &quot;\n&quot; : &quot; &quot;);
            }
        }
    }

    return 0;
}
</code></pre></details></td></tr>
<tr><td>1739C</td><td><a href="https://codeforces.com/problemset/problem/1739/C" target="_blank" rel="noopener">Link</a></td><td>Maths</td><td>Medium</td><td>46.0</td><td>50</td><td>O(n)</td><td>O(1)</td><td>20</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
	int t,n,i;
	scanf(&quot;%d&quot;, &amp;t);
	while (t--)
	{
	long long x=1, y=0,mid=2;
		scanf(&quot;%d&quot;, &amp;n);
		for (i = 4; i &lt;= n; i = i + 2)
		{
			mid = mid * 2 * (i - 1) / i * 2;
			x = mid / 2 + y;
			y = mid - x - 1;
 
		}
		cout&lt;&lt;x%998244353&lt;&lt;&quot; &quot;&lt;&lt;y%998244353&lt;&lt;&quot; &quot;&lt;&lt;1&lt;&lt;endl;
	}
	return 0;
}</code></pre></details></td><td>error</td><td>error</td><td>error</td><td>error</td><td>49</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;

const int MOD = 998244353;
int t, n;

// Precompute factorials and inverse factorials for nCr modulo
ll fact[61], invfact[61];

ll mod_pow(ll base, ll exp) {
    ll res = 1;
    while (exp &gt; 0) {
        if (exp &amp; 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp &gt;&gt;= 1;
    }
    return res;
}

ll mod_inv(ll a) {
    return mod_pow(a, MOD - 2);
}

ll nCr(int n, int r) {
    if (r &gt; n || r &lt; 0) return 0;
    return fact[n] * invfact[r] % MOD * invfact[n - r] % MOD;
}

// Based on problem analysis:
// ways to distribute = nCr(n, n/2)
// ways for draw = 1 (only one distribution leads to a draw)
// ways Alex wins = nCr(n-1, n/2) - ways Alex loses
// ways Boris wins = ways Alex loses = nCr(n-1, n/2 - 1)

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    fact[0] = 1;
    for (int i = 1; i &lt;= 60; i++) fact[i] = fact[i-1] * i % MOD;
    invfact[60] = mod_inv(fact[60]);
    for (int i = 59; i &gt;= 0; i--) invfact[i] = invfact[i+1] * (i+1) % MOD;

    cin &gt;&gt; t;
    while (t--) {
        cin &gt;&gt; n;
        int half = n / 2;

        ll ways_total = nCr(n, half);
        ll ways_boris = nCr(n - 1, half - 1);
        ll ways_alex = nCr(n - 1, half) - ways_boris;
        if (ways_alex &lt; 0) ways_alex += MOD;

        // draw always 1 by problem statement
        ll ways_draw = 1;

        cout &lt;&lt; ways_alex &lt;&lt; &quot; &quot; &lt;&lt; ways_boris &lt;&lt; &quot; &quot; &lt;&lt; ways_draw &lt;&lt; &quot;\n&quot;;
    }

    return 0;
}
</code></pre></details></td></tr>
<tr><td>1849B</td><td><a href="https://codeforces.com/problemset/problem/1849/B" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Medium</td><td>562.0</td><td>0</td><td>O(nlogn)</td><td>O(n)</td><td>16</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
#include&lt;iostream&gt;
using namespace std;
int main()
{int t;
cin&gt;&gt;t;
while(t--)
{int n,m;
cin&gt;&gt;n&gt;&gt;m;
int x;
pair&lt;int,int&gt;a[n];
for(int i=0;i&lt;n;i++)
{cin&gt;&gt;x;
a[i]={-1-(x-1)%m,i+1};}
sort(a,a+n);
for(int i=0;i&lt;n;i++)cout&lt;&lt;a[i].second&lt;&lt;&quot; &quot;;
cout&lt;&lt;endl;}}</code></pre></details></td><td>186</td><td>0.9</td><td>O(nlogn)</td><td>O(n)</td><td>40</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    if (!(cin &gt;&gt; t)) return 0;
    while (t--) {
        int n;
        long long k;
        cin &gt;&gt; n &gt;&gt; k;
        vector&lt;pair&lt;long long,int&gt;&gt; v;
        v.reserve(n);

        for (int i = 0; i &lt; n; ++i) {
            long long a;
            cin &gt;&gt; a;
            long long r = a % k;
            if (r == 0) r = k;
            v.push_back({r, i + 1});   // store (remainder, index 1-based)
        }

        sort(v.begin(), v.end(), [&amp;](const auto &amp;x, const auto &amp;y) {
            if (x.first != y.first) return x.first &gt; y.first; // larger remainder first
            return x.second &lt; y.second;                       // smaller index first
        });

        for (auto &amp;p : v) {
            cout &lt;&lt; p.second &lt;&lt; &#x27; &#x27;;
        }
        cout &lt;&lt; &#x27;\n&#x27;;
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>1849C</td><td><a href="https://codeforces.com/problemset/problem/1849/C" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Medium</td><td>639.0</td><td>8.2</td><td>O(nlogn)</td><td>O(n)</td><td>35</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int t;
int n,m;
int main()
{
	cin&gt;&gt;t;
	while(t--){
		cin&gt;&gt;n&gt;&gt;m;
		string s;
		cin&gt;&gt;s;
		s=&quot; &quot;+s;
		vector&lt;int&gt; pre(n+1,0),suf(n+1,0);
		int pos=0;
		for(int i=1;i&lt;=n;i++){
			if(s[i]==&#x27;0&#x27;) pos=i;
			pre[i]=pos;
		} 
		pos=n+1;
		for(int i=n;i&gt;=1;i--){
			if(s[i]==&#x27;1&#x27;) pos=i;
			suf[i]=pos;
		}
		set&lt;pair&lt;int,int&gt;&gt; p;
		while(m--){
			int l,r;
			cin&gt;&gt;l&gt;&gt;r;
			l=suf[l];r=pre[r];
			if(l&gt;r){
				l=r=0;
			}
			p.insert({l,r});
		}
		cout&lt;&lt;p.size()&lt;&lt;endl;
	}
	return 0;
} </code></pre></details></td><td>280</td><td>4.5</td><td>O(n)</td><td>O(n)</td><td>50</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    if (!(cin &gt;&gt; T)) return 0;
    while (T--) {
        int n, m;
        cin &gt;&gt; n &gt;&gt; m;
        string s;
        cin &gt;&gt; s;
        s = &quot; &quot; + s; // 1-based

        // nearest1[i]: smallest index &gt;= i with s[index] == &#x27;1&#x27;; else n+1
        // nearest0[i]: largest index &lt;= i with s[index] == &#x27;0&#x27;; else 0
        vector&lt;int&gt; nearest1(n + 2, n + 1);
        vector&lt;int&gt; nearest0(n + 2, 0);

        // build nearest1 from right to left
        for (int i = n; i &gt;= 1; --i) {
            nearest1[i] = nearest1[i + 1];
            if (s[i] == &#x27;1&#x27;) nearest1[i] = i;
        }

        // build nearest0 from left to right
        for (int i = 1; i &lt;= n; ++i) {
            nearest0[i] = nearest0[i - 1];
            if (s[i] == &#x27;0&#x27;) nearest0[i] = i;
        }

        set&lt;pair&lt;int,int&gt;&gt; diff; // encodes distinct resulting strings (except original)
        bool same_exists = false;

        while (m--) {
            int l, r;
            cin &gt;&gt; l &gt;&gt; r;

            int L = nearest1[l];   // first 1 in [l, r], or &gt; r if none
            int R = nearest0[r];   // last 0  in [l, r], or &lt; l if none

            if (L &gt; R) {
                // substring [l, r] already sorted, operation changes nothing
                same_exists = true;
            } else {
                diff.insert({L, R});
            }
        }

        int ans = (int)diff.size();
        if (same_exists) ++ans;
        cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>2155B</td><td><a href="http://codeforces.com/problemset/problem/2155/B" target="_blank" rel="noopener">Link</a></td><td>Graph</td><td>Medium</td><td>77.0</td><td>0</td><td>O(n^2)</td><td>O(1)</td><td>33</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;iostream&gt;
using namespace std;
int main(){
int n,k;
int t;
cin&gt;&gt;t;
while(t--){
cin&gt;&gt;n&gt;&gt;k;
if(k==n*n-1)
    cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
else{
cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;
int temp=n,x;
while(n--){
x=temp;
while(x--){
if(k!=0){
cout&lt;&lt;&quot;U&quot;;
k--;
}
else{
if(x==0 &amp;&amp; n!=0)
    cout&lt;&lt;&quot;D&quot;;
else if(x==0 &amp;&amp; n==0)
cout&lt;&lt;&quot;L&quot;;
else{
cout&lt;&lt;&quot;RL&quot;;
x--;
}
}
}
cout&lt;&lt;endl;
}
}
}
 
return 0;
}</code></pre></details></td><td>64</td><td>0</td><td>O(n^2)</td><td>O(n^2)</td><td>70</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

void solve() {
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    long long total = 1LL * n * n;
    long long no_escape = total - k;  // number of non-escaping cells

    // Impossible case: exactly one non-escaping cell
    if (no_escape == 1) {
        cout &lt;&lt; &quot;NO\n&quot;;
        return;
    }

    vector&lt;string&gt; ans(n, string(n, &#x27;0&#x27;));

    // Case 1: all cells must escape
    if (no_escape == 0) {
        cout &lt;&lt; &quot;YES\n&quot;;
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (j == n - 1) ans[i][j] = &#x27;D&#x27;;
                else ans[i][j] = &#x27;R&#x27;;
            }
            cout &lt;&lt; ans[i] &lt;&lt; &#x27;\n&#x27;;
        }
        return;
    }

    // Case 2: there are non-escaping cells, and no_escape != 1
    // First, create a 2-cell cycle trap at (0,0) &lt;-&gt; (0,1)
    ans[0][0] = &#x27;R&#x27;;
    ans[0][1] = &#x27;L&#x27;;
    no_escape -= 2;  // we already accounted for these two non-escaping cells

    // Feed remaining non-escaping cells into the trap
    for (int i = 0; i &lt; n &amp;&amp; no_escape &gt; 0; ++i) {
        for (int j = 0; j &lt; n &amp;&amp; no_escape &gt; 0; ++j) {
            if (ans[i][j] != &#x27;0&#x27;) continue;  // already set (part of trap)
            // Direct this cell towards top-left so it eventually reaches trap
            if (j == 0) ans[i][j] = &#x27;U&#x27;;
            else ans[i][j] = &#x27;L&#x27;;
            --no_escape;
        }
    }

    // All remaining cells should be escaping
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            if (ans[i][j] == &#x27;0&#x27;) {
                if (j == n - 1) ans[i][j] = &#x27;D&#x27;;
                else ans[i][j] = &#x27;R&#x27;;
            }
        }
    }

    cout &lt;&lt; &quot;YES\n&quot;;
    for (int i = 0; i &lt; n; ++i) {
        cout &lt;&lt; ans[i] &lt;&lt; &#x27;\n&#x27;;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin &gt;&gt; t;
    while (t--) {
        solve();
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>2165C</td><td><a href="https://codeforces.com/problemset/problem/2165/C" target="_blank" rel="noopener">Link</a></td><td>Bit Manipulation</td><td>Medium</td><td>280.0</td><td>2</td><td>O(nlogn)</td><td>O(n)</td><td>33</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 5e5+15;
int n,a[N];
void func(int c){
	priority_queue &lt;int&gt; q;
	int ans = 0;
	for(int i = 1 ; i&lt;=30 ; i++) q.push(0);
	for(int i = max(1,n-30) ; i&lt;=n ; i++) q.push(a[i]);
	for(int i = 29;c;i--){
		if(c&gt;=(1&lt;&lt;i)){
			int u = q.top();q.pop();
			if(u&gt;=(1&lt;&lt;i)) u-=(1&lt;&lt;i) , q.push(u);
			else ans+=(1&lt;&lt;i)-u;
			c-=(1&lt;&lt;i);
		}
	}
	printf(&quot;%d\n&quot;,ans);
}
int main(){
	int t;scanf(&quot;%d&quot;,&amp;t);
	while(t--){
		int q;scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
		for(int i = 1 ; i&lt;=n ; i++) scanf(&quot;%d&quot;,&amp;a[i]);
		sort(a+1,a+n+1);
		while(q--){
			int c;scanf(&quot;%d&quot;,&amp;c);
			func(c);
		}
	}
	return 0;
}
</code></pre></details></td><td>error</td><td>error</td><td>error</td><td>error</td><td>error</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

const int B = 30; // bits limit

struct XORBasis {
    ll basis[B];
    ll min_val[B];
    XORBasis() {
        memset(basis, 0, sizeof(basis));
        memset(min_val, 0, sizeof(min_val));
    }

    // Insert a value to the basis, tracking its original min value
    void insert(ll x, ll cost = 0) {
        for (int i = B - 1; i &gt;= 0; i--) {
            if (!(x &amp; (1LL &lt;&lt; i))) continue;
            if (!basis[i]) {
                basis[i] = x;
                min_val[i] = cost;
                break;
            }
            if (cost &lt; min_val[i]) {
                swap(cost, min_val[i]);
                swap(x, basis[i]);
            }
            x ^= basis[i];
        }
    }

    // Check if x can be represented by the basis
    // Return min cost to represent x (or -1 if not possible)
    ll query(ll x) {
        ll res = 0;
        for (int i = B - 1; i &gt;= 0; i--) {
            if ((x &amp; (1LL &lt;&lt; i))) {
                if (!basis[i]) return -1;
                x ^= basis[i];
                res += min_val[i];
            }
        }
        return res;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int t; cin &gt;&gt; t;
    while (t--) {
        int n, q; cin &gt;&gt; n &gt;&gt; q;
        vector&lt;ll&gt; a(n);
        for (ll &amp;x : a) cin &gt;&gt; x;
        
        XORBasis basis;
        // Insert all a_i with cost 0 (current values)
        for (auto x : a) basis.insert(x, 0);

        while (q--) {
            ll c; cin &gt;&gt; c;
            ll ans = basis.query(c);
            if (ans == -1) {
                // Since increments can be any amount, minimum cost to form c is at least 
                // the smallest increase needed to have c in the basis.
                // But the problem setup means that increasing any a_i by 1 can shift basis.
                // Here, just output 0 if c==0 and cannot form c otherwise means no solution with 0 cost.
                // Problem states increments can be large, so answer 0 if c=0 else output minimal increments however we need a full approach.
                // We will output the minimal increments needed to add c into basis from scratch:
                // Since problem is complex, for now output 0 means no solution in base basis.
                cout &lt;&lt; 0 &lt;&lt; &quot;\n&quot;;
            } else {
                cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
            }
        }
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>2166D</td><td><a href="https://codeforces.com/problemset/problem/2166/D" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Medium</td><td>249.0</td><td>0.1</td><td>O(n^2)</td><td>O(n)</td><td>31</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const ll M=998244353;
ll t,n,vis[5005],dp[5005];
int main(){
	cin&gt;&gt;t;
	while(t--){
		cin&gt;&gt;n;
		for(ll i=0;i&lt;=n;i++)dp[i]=vis[i]=0;
		for(ll i=1;i&lt;=n;i++){
			ll a;
			cin&gt;&gt;a;
			vis[a]++;
		}
		dp[0]=1;
		sort(vis+1,vis+1+n);
		ll ans=vis[n];
		for(ll i=1;i&lt;n;i++){
			ans=ans*(vis[i]+1)%M;
			for(ll j=n;j&gt;=vis[i];j--){
				dp[j]+=dp[j-vis[i]]*vis[i];
				dp[j]%=M;
			}
		}
		for(ll i=vis[n];i&lt;=n;i++)ans=(ans+dp[i])%M;
		printf(&quot;%lld\n&quot;,ans); 
	}
	return 0;
} </code></pre></details></td><td>error</td><td>error</td><td>error</td><td>error</td><td>error</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

const int MOD = 998244353;
const int MAXN = 5000;

int fact[MAXN+1], invFact[MAXN+1];

// Modular exponentiation
int modPow(int base, int exp) {
    int result = 1;
    int cur = base;
    while (exp &gt; 0) {
        if (exp &amp; 1) result = (1LL * result * cur) % MOD;
        cur = (1LL * cur * cur) % MOD;
        exp &gt;&gt;= 1;
    }
    return result;
}

// Precompute factorials and inverse factorials
void precomputeFactorials() {
    fact[0] = 1;
    for (int i = 1; i &lt;= MAXN; i++)
        fact[i] = (1LL * fact[i-1] * i) % MOD;

    invFact[MAXN] = modPow(fact[MAXN], MOD-2);
    for (int i = MAXN - 1; i &gt;= 0; i--)
        invFact[i] = (1LL * invFact[i+1] * (i+1)) % MOD;
}

// Compute n choose k modulo MOD
int choose(int n, int k) {
    if (k &gt; n || k &lt; 0) return 0;
    return (1LL * fact[n] * ((1LL * invFact[k] * invFact[n-k]) % MOD)) % MOD;
}

int add(int a, int b) {
    a += b;
    if (a &gt;= MOD) a -= MOD;
    return a;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    precomputeFactorials();

    int t; cin &gt;&gt; t;
    while (t--) {
        int n; cin &gt;&gt; n;
        vector&lt;int&gt; a(n);
        for (auto &amp;x : a) cin &gt;&gt; x;

        vector&lt;int&gt; freq(n+1, 0);
        for (int x : a) freq[x]++;

        map&lt;int,int&gt; freqCount;
        for (int i = 1; i &lt;= n; i++) {
            if (freq[i] &gt; 0) freqCount[freq[i]]++;
        }

        // DP where dp[i] = number of ways to form multisets of size i
        vector&lt;int&gt; dp(1, 1); // dp[0] = 1
        int currentMax = 0;

        for (auto &amp;p : freqCount) {
            int c = p.second;
            vector&lt;int&gt; newdp(currentMax + c + 1, 0);
            for (int i = 0; i &lt;= currentMax; i++) {
                if (dp[i] == 0) continue;
                for (int j = 0; j &lt;= c; j++) {
                    int ways = choose(c, j);
                    newdp[i + j] = add(newdp[i + j], (int)((1LL * dp[i] * ways) % MOD));
                }
            }
            dp.swap(newdp);
            currentMax += c;
        }

        int answer = 0;
        for (int i = 1; i &lt;= currentMax; i++) {
            answer = add(answer, dp[i]);
        }

        cout &lt;&lt; answer &lt;&lt; &quot;\n&quot;;
    }
    return 0;
}
</code></pre></details></td></tr>
<tr><td>2169C</td><td><a href="https://codeforces.com/problemset/problem/2169/C" target="_blank" rel="noopener">Link</a></td><td>Greedy </td><td>Medium</td><td>249.0</td><td>0</td><td>O(n)</td><td>O(1)</td><td>16</td><td><details class="code"><summary>View</summary><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	int t;
	cin&gt;&gt;t;
	while(t--){
		int n;
		cin&gt;&gt;n;
		long long cur=0,best=0,Sum=0;
		for(int i=1;i&lt;=n;i++){
			int x;
			cin&gt;&gt;x;
			Sum+=x;
			cur=max(0LL,cur+2LL*i-x);
			best=max(best,cur);
		}
		cout&lt;&lt;Sum+best&lt;&lt;&quot;\n&quot;;
	}
}</code></pre></details></td><td>92</td><td>0</td><td>O(n)</td><td>O(n)</td><td>45</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    if (!(cin &gt;&gt; T)) return 0;
    while (T--) {
        int n;
        cin &gt;&gt; n;
        vector&lt;long long&gt; a(n + 1), pref(n + 1, 0);
        for (int i = 1; i &lt;= n; ++i) {
            cin &gt;&gt; a[i];
            pref[i] = pref[i - 1] + a[i];
        }

        long long baseSum = pref[n];

        // f(l) = pref[l-1] - l^2 + l
        auto f = [&amp;](int l) -&gt; long long {
            long long L = l;
            return pref[l - 1] - L * L + L;
        };
        // g(r) = r^2 + r - pref[r]
        auto g = [&amp;](int r) -&gt; long long {
            long long R = r;
            return R * R + R - pref[r];
        };

        long long bestGain = 0;          // option of no operation
        long long bestF = f(1);          // max f(l) for l &lt;= r, start with l=1

        for (int r = 1; r &lt;= n; ++r) {
            if (r &gt; 1) {
                // include f(r) into bestF before using r as right endpoint
                bestF = max(bestF, f(r));
            }
            long long candGain = bestF + g(r);
            if (candGain &gt; bestGain) bestGain = candGain;
        }

        cout &lt;&lt; baseSum + bestGain &lt;&lt; &#x27;\n&#x27;;
    }
    return 0;
}
</code></pre></details></td></tr>
        </tbody>
      </table>
    </div>
    </section><section id="tbl_leet_code_sec"><h2>Leet code - Submissions</h2>
    <div class="table-wrap">
      <input class="search" type="search" placeholder="Search Problem ID / Domain / Level..." oninput="filterTable('tbl_leet_code', this.value)">
      <table id="tbl_leet_code">
        <thead><tr><th>Problem ID</th><th>Problem</th><th>Domain</th><th>Level</th><th>Runtime H (ms)</th><th>Mem H (MB)</th><th>TC H</th><th>SC H</th><th>LOC H</th><th>Human Code</th><th>Runtime LLM (ms)</th><th>Mem LLM (MB)</th><th>TC LLM</th><th>SC LLM</th><th>LOC LLM</th><th>LLM Code</th></tr></thead>
        <tbody>
        <tr><td>100</td><td><a href="https://leetcode.com/problems/same-tree/description/" target="_blank" rel="noopener">Link</a></td><td>Binary tree</td><td>Easy</td><td>4.0</td><td>10.54</td><td>O(n)</td><td>O(n)</td><td>11</td><td><details class="code"><summary>View</summary><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p==nullptr&amp;&amp;q==nullptr)  return true;
        if(p==nullptr||q==nullptr)  return false;
        if(p-&gt;val!=q-&gt;val)  return false;
        return (isSameTree(p-&gt;right,q-&gt;right)&amp;&amp;isSameTree(p-&gt;left,q-&gt;left));
    }
};</code></pre></details></td><td>0</td><td>12.93</td><td>O(n)</td><td>O(n)</td><td>8</td><td><details class="code"><summary>View</summary><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == nullptr &amp;&amp; q == nullptr) return true;
        if (p == nullptr || q == nullptr) return false;
        if (p-&gt;val != q-&gt;val) return false;
        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
    }
};
</code></pre></details></td></tr>
<tr><td>1051</td><td><a href="https://leetcode.com/problems/height-checker/description/" target="_blank" rel="noopener">Link</a></td><td>Sorting</td><td>Easy</td><td>0.0</td><td>9.98</td><td>O(nlogn)</td><td>O(n)</td><td>11</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int heightChecker(vector&lt;int&gt;&amp; heights) {
        vector&lt;int&gt; temp(heights.begin(), heights.end());
        sort(temp.begin(), temp.end());
        int ans = 0;
        for(int i = 0; i&lt;temp.size(); i++){
            if(temp[i] != heights[i])
            ans++;
        }
        return ans;
    }
};</code></pre></details></td><td>0</td><td>11.52</td><td>O(nlogn)</td><td>O(n)</td><td>15</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int heightChecker(vector&lt;int&gt;&amp; heights) {
        vector&lt;int&gt; expected = heights;
        sort(expected.begin(), expected.end());
        int ans = 0;
        for (int i = 0; i &lt; (int)heights.size(); i++) {
            if (heights[i] != expected[i]) ans++;
        }
        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>1122</td><td><a href="https://leetcode.com/problems/relative-sort-array/description/" target="_blank" rel="noopener">Link</a></td><td>Sorting</td><td>Easy</td><td>5.0</td><td>9.28</td><td>O(n^2)</td><td>O(1)</td><td>30</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; relativeSortArray(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) {
        int ind = -1;
        for(int i = 0; i&lt;arr2.size(); i++){
            int low = ind+1, high = arr1.size()-1;
            while(low&lt;high){
                if(arr1[low] != arr2[i] &amp;&amp; arr1[high] == arr2[i]){
                    ind = max(ind, low);
                    swap(arr1[low], arr1[high]);
                    low++;
                    high--;
                }
                else if(arr1[low] == arr2[i]){
                    ind = max(ind, low);
                    low++;
                }
                else{
                    high--;
                }
            }            
        }
        for(int i = ind + 1; i&lt;arr1.size(); i++){
            for(int j = i+1; j&lt;arr1.size(); j++){
                if(arr1[i] &gt; arr1[j])
                    swap(arr1[i], arr1[j]);
            }
        }
        return arr1;
    }
};</code></pre></details></td><td>0</td><td>10.58</td><td>O(n)</td><td>O(n)</td><td>15</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; relativeSortArray(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) {
        // Counting sort style: value range is 0..1000
        int maxV = 1000;
        vector&lt;int&gt; cnt(maxV + 1, 0);
        for (int x : arr1) cnt[x]++;

        vector&lt;int&gt; res;
        res.reserve(arr1.size());

        // Place elements in arr2 order
        for (int x : arr2) {
            while (cnt[x]-- &gt; 0) res.push_back(x);
        }

        // Place remaining elements in ascending order
        for (int v = 0; v &lt;= maxV; ++v) {
            while (cnt[v]-- &gt; 0) res.push_back(v);
        }
        return res;
    }
};
</code></pre></details></td></tr>
<tr><td>121</td><td><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Easy</td><td>156.0</td><td>93.2</td><td>O(n)</td><td>O(1)</td><td>13</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int mini=prices[0];
        int ans=0;
        for(int i=0;i&lt;prices.size();i++){
            ans=max(ans,prices[i]-mini);
            mini=min(mini,prices[i]);
        }
        return ans;
    }
};</code></pre></details></td><td>0</td><td>97.4</td><td>O(n)</td><td>O(1)</td><td>18</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int mini = prices[0];
        int ans = 0;
        for (int i = 0; i &lt; (int)prices.size(); ++i) {
            ans = max(ans, prices[i] - mini);
            mini = min(mini, prices[i]);
        }
        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>1290</td><td><a href="https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/" target="_blank" rel="noopener">Link</a></td><td>Linked List</td><td>Easy</td><td>0.0</td><td>10.6</td><td>O(n)</td><td>O(1)</td><td>7</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int getDecimalValue(ListNode* head) {
        int num = 0;
        while(head != NULL){
            num = (num &lt;&lt; 1) + head-&gt;val;
            head = head-&gt;next;
        }
        return num;
    }
};</code></pre></details></td><td>0</td><td>10.54</td><td>O(n)</td><td>O(1)</td><td>6</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int getDecimalValue(ListNode* head) {
        int num = 0;
        while (head != nullptr) {
            num = (num &lt;&lt; 1) + head-&gt;val;  // Shift left and add current bit
            head = head-&gt;next;             // Move to next node
        }
        return num;
    }
};</code></pre></details></td></tr>
<tr><td>1290</td><td><a href="https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/" target="_blank" rel="noopener">Link</a></td><td>Lineked list</td><td>Easy</td><td>0.0</td><td>10.55</td><td>O(n)</td><td>O(1)</td><td>13</td><td><details class="code"><summary>View</summary><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    int getDecimalValue(ListNode* head) {
        int num = 0;
        while(head != NULL){
            num = (num &lt;&lt; 1) + head-&gt;val;
            head = head-&gt;next;
        }
        return num;
    }
};</code></pre></details></td><td>2</td><td>10.72</td><td>O(n)</td><td>O(1)</td><td>12</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int getDecimalValue(ListNode* head) {
        int num = 0;
        while (head) {
            num = (num &lt;&lt; 1) | head-&gt;val;
            head = head-&gt;next;
        }
        return num;
    }
};
</code></pre></details></td></tr>
<tr><td>1356</td><td><a href="https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/description/" target="_blank" rel="noopener">Link</a></td><td>Sorting</td><td>Easy</td><td>416.0</td><td>10.38</td><td>O(n^2)</td><td>O(1)</td><td>20</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) {
        for(int i = 0; i &lt; arr.size(); i++){
            short min = i;
            for(int j = i+1; j&lt;arr.size(); j++){
                int minBits = 0, curBits = 0;
                for(int k = 0; k&lt;16 ; k++ ){
                    if(arr[min]&gt;&gt;k &amp; 1)
                        minBits++;
                    if(arr[j]&gt;&gt;k &amp; 1)
                        curBits++;
                }
                if(minBits &gt; curBits || (minBits == curBits &amp;&amp; arr[min] &gt; arr[j])){
                    swap(arr[min],arr[j]);
                }
            }
        }
        return arr;
    }
};</code></pre></details></td><td>0</td><td>14.03</td><td>O(nlogn)</td><td>O(1)</td><td>11</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) {
        auto bits = [](int x) {
            return __builtin_popcount(x);
        };
        sort(arr.begin(), arr.end(),
             [&amp;](int a, int b) {
                 int pa = bits(a), pb = bits(b);
                 if (pa != pb) return pa &lt; pb;
                 return a &lt; b;
             });
        return arr;
    }
};
</code></pre></details></td></tr>
<tr><td>136</td><td><a href="https://leetcode.com/problems/single-number/description/" target="_blank" rel="noopener">Link</a></td><td>Bit Manipulation</td><td>Easy</td><td>11.0</td><td>16.96</td><td>O(n)</td><td>O(1)</td><td>7</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        for(int i=1;i&lt;nums.size();i++)
            nums[i]^=nums[i-1];
        return nums[nums.size()-1];
    }
};</code></pre></details></td><td>0</td><td>20.76</td><td>O(n)</td><td>O(1)</td><td>15</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        int x = 0;
        for (int v : nums) x ^= v;
        return x;
    }
};
</code></pre></details></td></tr>
<tr><td>167</td><td><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Easy</td><td>12.0</td><td>10.9</td><td>O(n)</td><td>O(n)</td><td>12</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int,int&gt;s;
        for(int i=0;i&lt;nums.size();i++){
            if(s.find(target-nums[i])!=s.end()){
                return {s[target-nums[i]],i};
            }
            s[nums[i]]=i;
        }
        return{0,0};
    }
};</code></pre></details></td><td>0</td><td>14.91</td><td>O(n)</td><td>O(n)</td><td>14</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; seen; // Stores num -&gt; index
        for (int i = 0; i &lt; nums.size(); ++i) {
            int complement = target - nums[i];
            if (seen.count(complement)) {
                return {seen[complement], i};
            }
            seen[nums[i]] = i;
        }
        return {}; // Should never reach here as only one solution exists
    }
};
</code></pre></details></td></tr>
<tr><td>169</td><td><a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="noopener">Link</a></td><td>Sorting</td><td>Easy</td><td>6.0</td><td>19.88</td><td>O(n)</td><td>O(1)</td><td>9</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int boyerMoore(vector&lt;int&gt; &amp;arr) {
    int element, vote = 0;
    for(int i=0;i&lt;arr.size();i++){
        if(!vote){
            element = arr[i];
        }
        if(element == arr[i])
            vote++;
        else
            vote--;
    }
    return element;
}

    int majorityElement(vector&lt;int&gt;&amp; nums) {
        return boyerMoore(nums);
    }
};</code></pre></details></td><td>0</td><td>28.03</td><td>O(n)</td><td>O(1)</td><td>6</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        int candidate = 0, count = 0;
        for (int x : nums) {
            if (count == 0) candidate = x;
            count += (x == candidate) ? 1 : -1;
        }
        return candidate; // problem guarantees majority exists
    }
};
</code></pre></details></td></tr>
<tr><td>242</td><td><a href="https://leetcode.com/problems/valid-anagram/description/" target="_blank" rel="noopener">Link</a></td><td>Sorting</td><td>Easy</td><td>7.0</td><td>7.72</td><td>O(n)</td><td>O(1)</td><td>9</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length() != t.length()) return false;
        vector&lt;int&gt; charDiff(26, 0);
        for(int i = 0; i&lt;s.length(); i++){
            charDiff[s[i] - &#x27;a&#x27;]++, charDiff[t[i] - &#x27;a&#x27;]--;
        }
        for(int i = 0; i&lt;26; i++){
            if(charDiff[i]) return false;
        }
        return true;
    }
};</code></pre></details></td><td>2</td><td>9.62</td><td>O(n)</td><td>O(1)</td><td>16</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size()) return false;
        int cnt[26] = {0};
        for (int i = 0; i &lt; (int)s.size(); ++i) {
            cnt[s[i] - &#x27;a&#x27;]++;
            cnt[t[i] - &#x27;a&#x27;]--;
        }
        for (int i = 0; i &lt; 26; ++i)
            if (cnt[i] != 0) return false;
        return true;
    }
};
</code></pre></details></td></tr>
<tr><td>455</td><td><a href="https://leetcode.com/problems/assign-cookies/description/" target="_blank" rel="noopener">Link</a></td><td>Sorting</td><td>Easy</td><td>8.0</td><td>44.75</td><td>O(nlogn+mlogm)</td><td>O(1)</td><td>17</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int matched = 0;
        int j = 0;
        for(int i = 0; i&lt;g.size(); i++){
            while(j&lt; s.size() &amp;&amp;  s[j]&lt;g[i]){
                j++;
            }
            if(j&lt;s.size()){
                matched++;
                j++;
            }
        }
        return matched;
    }
};</code></pre></details></td><td>15</td><td>44.81</td><td>O(nlogn+mlogm)</td><td>O(1)</td><td>13</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int i = 0, j = 0, matched = 0;
        while (i &lt; (int)g.size() &amp;&amp; j &lt; (int)s.size()) {
            if (s[j] &gt;= g[i]) { // cookie satisfies child
                matched++; 
                i++; 
                j++;
            } else {
                j++; // try next larger cookie
            }
        }
        return matched;
    }
};
</code></pre></details></td></tr>
<tr><td>501</td><td><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/description/" target="_blank" rel="noopener">Link</a></td><td>Binary tree</td><td>Easy</td><td>12.0</td><td>24.28</td><td>O(n)</td><td>O(n)</td><td>23</td><td><details class="code"><summary>View</summary><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    void getMode(TreeNode * cur, int &amp; curVal, int &amp; curFreq, int &amp; maxFreq, vector&lt;int&gt; &amp; ans){
        if(cur == nullptr) return;
        getMode(cur-&gt;left, curVal, curFreq, maxFreq, ans);
        if(curVal == cur-&gt;val){
            curFreq++;            
        }
        else{
            curVal = cur-&gt;val; 
            curFreq = 1;
        }      
        if(maxFreq &lt; curFreq){
            ans.clear();
            maxFreq = curFreq;
        }        
        if(maxFreq == curFreq){
            ans.push_back(curVal);
        }
        
        getMode(cur-&gt;right, curVal, curFreq, maxFreq, ans);
        return;
    }

    vector&lt;int&gt; findMode(TreeNode* root) {
        vector&lt;int&gt; ans;
        int curVal = 0, curFreq = 0, maxFreq = 1;
        getMode(root, curVal, curFreq, maxFreq, ans);
        return ans;
    }
};</code></pre></details></td><td>0</td><td>24.24</td><td>O(n)</td><td>O(n)</td><td>20</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    void touch(int val, int&amp; last, int&amp; cnt, int&amp; best, vector&lt;int&gt;&amp; out) {
        if (cnt == 0 || val != last) { last = val; cnt = 1; }
        else { cnt++; }
        if (cnt &gt; best) { best = cnt; out.clear(); out.push_back(val); }
        else if (cnt == best) { out.push_back(val); }
    }

    void dfs(TreeNode* n, int&amp; last, int&amp; cnt, int&amp; best, vector&lt;int&gt;&amp; out) {
        if (!n) return;
        dfs(n-&gt;left, last, cnt, best, out);
        touch(n-&gt;val, last, cnt, best, out);
        dfs(n-&gt;right, last, cnt, best, out);
    }

    vector&lt;int&gt; findMode(TreeNode* root) {
        vector&lt;int&gt; out;
        int last = 0, cnt = 0, best = 0;
        dfs(root, last, cnt, best, out);
        return out;
    }
};
</code></pre></details></td></tr>
<tr><td>706</td><td><a href="https://leetcode.com/problems/design-hashmap/description/" target="_blank" rel="noopener">Link</a></td><td>Linked List</td><td>Easy</td><td>70.0</td><td>220.26</td><td>O(1)</td><td>O(M)</td><td>17</td><td><details class="code"><summary>View</summary><pre><code>class MyHashMap {
public:
    vector&lt;int&gt; hashMap;
    
    MyHashMap() {
      hashMap = vector&lt;int&gt;(1000001, -1);
    }
    
    void put(int key, int value) {
      hashMap[key] = value;
    }
    
    int get(int key) {
      return hashMap[key];
    }
    
    void remove(int key) {
      hashMap[key] = -1;
    }
};</code></pre></details></td><td>16</td><td>69.94</td><td>O(1)</td><td>O(n)</td><td>35</td><td><details class="code"><summary>View</summary><pre><code>
class MyHashMap {
private:
    static const int SIZE = 10007; // A prime number for better distribution
    std::vector&lt;std::list&lt;std::pair&lt;int,int&gt;&gt;&gt; table;

    int hash(int key) {
        return key % SIZE;
    }

public:
    MyHashMap() : table(SIZE) {}

    void put(int key, int value) {
        int idx = hash(key);
        for (auto &amp;kv : table[idx]) {
            if (kv.first == key) {
                kv.second = value;
                return;
            }
        }
        table[idx].emplace_back(key, value);
    }

    int get(int key) {
        int idx = hash(key);
        for (auto &amp;kv : table[idx]) {
            if (kv.first == key) {
                return kv.second;
            }
        }
        return -1;
    }

    void remove(int key) {
        int idx = hash(key);
        auto &amp;chain = table[idx];
        for (auto it = chain.begin(); it != chain.end(); ++it) {
            if (it-&gt;first == key) {
                chain.erase(it);
                return;
            }
        }
    }
};
</code></pre></details></td></tr>
<tr><td>844</td><td><a href="https://leetcode.com/problems/backspace-string-compare/description/" target="_blank" rel="noopener">Link</a></td><td>Stack</td><td>Easy</td><td>0.0</td><td>6.56</td><td>O(n)</td><td>O(1)</td><td>41</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int count = 0;
        for(int i = s.length()-1; i&gt;=0; i--){
            if(s[i] == &#x27;#&#x27;) count++;
            else if(count){
                s[i] = &#x27;#&#x27;;
                count--;
            }
        }
        count = 0;
        for(int i = t.length()-1; i&gt;=0; i--){
            if(t[i] == &#x27;#&#x27;) count++;
            else if(count){
                t[i] = &#x27;#&#x27;;
                count--;
            }
        }
        int ptr1 = 0, ptr2 = 0;
        while(ptr1 &lt; s.length() || ptr2 &lt; t.length()){
            if(ptr1 &lt; s.length() &amp;&amp; s[ptr1] == &#x27;#&#x27;){
                ptr1++;
                continue;
            }
            if(ptr2 &lt; t.length() &amp;&amp; t[ptr2] == &#x27;#&#x27;){
                ptr2++;
                continue;
            }
            if(s[ptr1] != t[ptr2])
                return false;
            else{
                ptr1++;
                ptr2++;
            }
        }
        return true;
    }
};</code></pre></details></td><td>0</td><td>8.33</td><td>O(n)</td><td>O(1)</td><td>29</td><td><details class="code"><summary>View</summary><pre><code>
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int i = (int)s.size() - 1, j = (int)t.size() - 1;
        int skipS = 0, skipT = 0;
        while (i &gt;= 0 || j &gt;= 0) {
            // find next valid char in s
            while (i &gt;= 0) {
                if (s[i] == &#x27;#&#x27;) { ++skipS; --i; }
                else if (skipS &gt; 0) { --skipS; --i; }
                else break;
            }
            // find next valid char in t
            while (j &gt;= 0) {
                if (t[j] == &#x27;#&#x27;) { ++skipT; --j; }
                else if (skipT &gt; 0) { --skipT; --j; }
                else break;
            }
            // compare current valid chars
            char cs = (i &gt;= 0 ? s[i] : &#x27;\0&#x27;);
            char ct = (j &gt;= 0 ? t[j] : &#x27;\0&#x27;);
            if (cs != ct) return false;
            --i; --j;
        }
        return true;
    }
};
</code></pre></details></td></tr>
<tr><td>844</td><td><a href="https://leetcode.com/problems/backspace-string-compare/description/" target="_blank" rel="noopener">Link</a></td><td>Stack</td><td>Easy</td><td>0.0</td><td>6.56</td><td>O(n)</td><td>O(1)</td><td>38</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int count = 0;
        for(int i = s.length()-1; i&gt;=0; i--){
            if(s[i] == &#x27;#&#x27;) count++;
            else if(count){
                s[i] = &#x27;#&#x27;;
                count--;
            }
        }
        count = 0;
        for(int i = t.length()-1; i&gt;=0; i--){
            if(t[i] == &#x27;#&#x27;) count++;
            else if(count){
                t[i] = &#x27;#&#x27;;
                count--;
            }
        }
        int ptr1 = 0, ptr2 = 0;
        while(ptr1 &lt; s.length() || ptr2 &lt; t.length()){
            if(ptr1 &lt; s.length() &amp;&amp; s[ptr1] == &#x27;#&#x27;){
                ptr1++;
                continue;
            }
            if(ptr2 &lt; t.length() &amp;&amp; t[ptr2] == &#x27;#&#x27;){
                ptr2++;
                continue;
            }
            if(s[ptr1] != t[ptr2])
                return false;
            else{
                ptr1++;
                ptr2++;
            }
        }
        return true;
    }
};</code></pre></details></td><td>1</td><td>8.36</td><td>O(n)</td><td>O(1)</td><td>24</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int i = (int)s.size() - 1, j = (int)t.size() - 1;
        int skipS = 0, skipT = 0;

        while (i &gt;= 0 || j &gt;= 0) {
            // advance i to next valid char in s
            while (i &gt;= 0) {
                if (s[i] == &#x27;#&#x27;) { skipS++; i--; }
                else if (skipS &gt; 0) { skipS--; i--; }
                else break;
            }
            // advance j to next valid char in t
            while (j &gt;= 0) {
                if (t[j] == &#x27;#&#x27;) { skipT++; j--; }
                else if (skipT &gt; 0) { skipT--; j--; }
                else break;
            }
            // compare current valid chars
            if (i &gt;= 0 &amp;&amp; j &gt;= 0) {
                if (s[i] != t[j]) return false;
            } else if (i &gt;= 0 || j &gt;= 0) {
                return false;
            }
            i--; j--;
        }
        return true;
    }
};
</code></pre></details></td></tr>
<tr><td>10</td><td><a href="https://leetcode.com/problems/regular-expression-matching/description/" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Hard</td><td>564.0</td><td>122.82</td><td>O(m*n)</td><td>O(m*n)</td><td>50</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    int memo[20][20]={};

    int dp(string s,string p,int ptr1,int ptr2){
        // cout&lt;&lt;ptr1&lt;&lt;&quot; &quot;&lt;&lt;ptr2&lt;&lt;&quot; &quot;&lt;&lt;endl;
        if(ptr1&lt;0&amp;&amp;ptr2&lt;0)return 1;
        else if(ptr2&lt;0)return 0;
        else if(ptr1&lt;0){
            if(p[ptr2]==&#x27;*&#x27;){
                return dp(s,p,ptr1,ptr2-2);
            }
            return 0;
        }
        if(memo[ptr1][ptr2]!=-1)
        return memo[ptr1][ptr2];
        int ans=0;
        if(p[ptr2]==&#x27;*&#x27;){
            ptr2--;            
            ans|=dp(s,p,ptr1,ptr2-1);
            if(p[ptr2]==&#x27;.&#x27;){
                while(ptr1&gt;=0){                
                    ans|=dp(s,p,ptr1-1,ptr2-1);
                    if(ptr1==0)
                    break;
                    ptr1--;
                }
            }
            else{                
                while(ptr1&gt;=0&amp;&amp;s[ptr1]==p[ptr2]){                
                    ans|=dp(s,p,ptr1-1,ptr2-1);
                    if(ptr1==0)
                    break;
                    ptr1--;
                }
            }
        }
        if(p[ptr2]==&#x27;.&#x27;){
            ans|=dp(s,p,ptr1-1,ptr2-1);
        }
        if(p[ptr2]==s[ptr1]){
            ans|=dp(s,p,ptr1-1,ptr2-1);
        }
        // cout&lt;&lt;ptr1&lt;&lt;&quot; &quot;&lt;&lt;ptr2&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;
        return memo[ptr1][ptr2]=ans;
    }

    bool isMatch(string s, string p){
        for(int i=0;i&lt;20;i++){
            for(int j=0;j&lt;20;j++){
                memo[i][j]=-1;
            }
        }
    return bool(dp(s,p,s.length()-1,p.length()-1));     
    }
};</code></pre></details></td><td>0</td><td>9.06</td><td>O(m*n)</td><td>O(m*n)</td><td>30</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.length(), n = p.length();
        vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false));
        dp[0][0] = true;  // empty string matches empty pattern

        // Handle patterns like a*, a*b*, a*b*c* matching empty string
        for (int j = 2; j &lt;= n; j += 2) {
            if (p[j - 1] == &#x27;*&#x27;) {
                dp[0][j] = dp[0][j - 2];
            }
        }

        for (int i = 1; i &lt;= m; i++) {
            for (int j = 1; j &lt;= n; j++) {
                if (p[j - 1] == &#x27;.&#x27; || p[j - 1] == s[i - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p[j - 1] == &#x27;*&#x27;) {
                    dp[i][j] = dp[i][j - 2];  // zero occurrence of preceding char
                    if (p[j - 2] == &#x27;.&#x27; || p[j - 2] == s[i - 1]) {
                        dp[i][j] = dp[i][j] || dp[i - 1][j];  // one or more occurrence
                    }
                } else {
                    dp[i][j] = false;
                }
            }
        }
        return dp[m][n];
    }
};
</code></pre></details></td></tr>
<tr><td>10</td><td><a href="https://leetcode.com/problems/regular-expression-matching/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Hard</td><td>564.0</td><td>122</td><td>O(n^2)</td><td>O(n^2)</td><td>63</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    int memo[20][20]={};

    int dp(string s,string p,int ptr1,int ptr2){
        // cout&lt;&lt;ptr1&lt;&lt;&quot; &quot;&lt;&lt;ptr2&lt;&lt;&quot; &quot;&lt;&lt;endl;
        if(ptr1&lt;0&amp;&amp;ptr2&lt;0)return 1;
        else if(ptr2&lt;0)return 0;
        else if(ptr1&lt;0){
            if(p[ptr2]==&#x27;*&#x27;){
                return dp(s,p,ptr1,ptr2-2);
            }
            return 0;
        }
        if(memo[ptr1][ptr2]!=-1)
        return memo[ptr1][ptr2];
        int ans=0;
        if(p[ptr2]==&#x27;*&#x27;){
            ptr2--;            
            ans|=dp(s,p,ptr1,ptr2-1);
            if(p[ptr2]==&#x27;.&#x27;){
                while(ptr1&gt;=0){                
                    ans|=dp(s,p,ptr1-1,ptr2-1);
                    if(ptr1==0)
                    break;
                    ptr1--;
                }
            }
            else{                
                while(ptr1&gt;=0&amp;&amp;s[ptr1]==p[ptr2]){                
                    ans|=dp(s,p,ptr1-1,ptr2-1);
                    if(ptr1==0)
                    break;
                    ptr1--;
                }
            }
        }
        if(p[ptr2]==&#x27;.&#x27;){
            ans|=dp(s,p,ptr1-1,ptr2-1);
        }
        if(p[ptr2]==s[ptr1]){
            ans|=dp(s,p,ptr1-1,ptr2-1);
        }
        // cout&lt;&lt;ptr1&lt;&lt;&quot; &quot;&lt;&lt;ptr2&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;
        return memo[ptr1][ptr2]=ans;
    }

    bool isMatch(string s, string p){
        for(int i=0;i&lt;20;i++){
            for(int j=0;j&lt;20;j++){
                memo[i][j]=-1;
            }
        }
    return bool(dp(s,p,s.length()-1,p.length()-1));     
    }
};</code></pre></details></td><td>3</td><td>10.66</td><td>O(n^2)</td><td>O(n^2)</td><td>34</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool isMatch(string s, string p) {
        int n = s.size(), m = p.size();
        vector&lt;vector&lt;int&gt;&gt; memo(n + 1, vector&lt;int&gt;(m + 1, -1)); // -1=unknown, 0=false, 1=true [web:291]

        function&lt;int(int,int)&gt; dfs = [&amp;](int i, int j) -&gt; int {
            if (j == m) return i == n;                                    // pattern end matches only if string end [web:291]
            if (memo[i][j] != -1) return memo[i][j];                       // memoized result [web:291]

            bool firstMatch = (i &lt; n) &amp;&amp; (p[j] == s[i] || p[j] == &#x27;.&#x27;);    // current char match [web:291]

            bool res;
            if (j + 1 &lt; m &amp;&amp; p[j + 1] == &#x27;*&#x27;) {                            // &#x27;*&#x27; can take zero or more of p[j] [web:291]
                res = (dfs(i, j + 2) ||                                    // take zero of preceding element [web:291]
                       (firstMatch &amp;&amp; dfs(i + 1, j)));                      // take one and stay on same pattern char [web:291]
            } else {
                res = firstMatch &amp;&amp; dfs(i + 1, j + 1);                     // consume both if match [web:291]
            }
            return memo[i][j] = res;                                       // store as 0/1 implicitly [web:291]
        };

        return dfs(0, 0);                                                  // start from both beginnings [web:291]
    }
};
</code></pre></details></td></tr>
<tr><td>118</td><td><a href="https://leetcode.com/problems/pascals-triangle/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Hard</td><td>0.0</td><td>9.87</td><td>O(n^2)</td><td>O(1)</td><td>27</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        vector&lt;vector&lt;int&gt;&gt; pascalsTriangle(numRows);
        int len = 1;
        pascalsTriangle[0].push_back(1);
        for(int i = 1; i&lt;numRows; i++){            
            len++;
            for(int j = 0; j&lt;len; j++){
                int cur = 0, next = 0;
                if(j&gt;0){
                    cur = pascalsTriangle[i-1][j-1];
                }
                if(j&lt;len-1){
                    next = pascalsTriangle[i-1][j];
                }
                pascalsTriangle[i].push_back(cur+next);
            }
        }
        return pascalsTriangle;
    }
};</code></pre></details></td><td>2</td><td>9.76</td><td>O(n^2)</td><td>O(n^2)</td><td>24</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        vector&lt;vector&lt;int&gt;&gt; pascal(numRows);
        for (int i = 0; i &lt; numRows; ++i) {
            pascal[i].resize(i + 1);
            pascal[i][0] = pascal[i][i] = 1;
            for (int j = 1; j &lt; i; ++j) {
                pascal[i][j] = pascal[i - 1][j - 1] + pascal[i - 1][j];
            }
        }
        return pascal;
    }
};
</code></pre></details></td></tr>
<tr><td>123</td><td><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Hard</td><td>168.0</td><td>75.95</td><td>O(n)</td><td>O(n)</td><td>31</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int left[prices.size()];
        int right[prices.size()];
        int ans=0;
        int mini=prices[0];
        left[0]=0;
        right[prices.size()-1]=0;
        for(int i=1;i&lt;prices.size();i++)
        {
            left[i]=max(left[i-1],prices[i]-mini);
            mini=min(mini,prices[i]);
        }
        mini=prices[prices.size()-1];
        for(int i=prices.size()-2;i&gt;=0;i--)
        {
            right[i]=max(right[i+1],mini-prices[i]);
            mini=max(mini,prices[i]);
        }
        for(int i=1;i&lt;prices.size()-1;i++){
            ans=max(ans,left[i]+right[i+1]);
        }
        ans=max(ans,right[0]);
        ans=max(ans,left[prices.size()-1]);
        return ans;
    }
};</code></pre></details></td><td>0</td><td>79.27</td><td>O(n)</td><td>O(1)</td><td>22</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        if (prices.empty()) return 0;
        int f1 = -prices[0];   // after first buy
        int f2 = 0;            // after first sell
        int f3 = -prices[0];   // after second buy
        int f4 = 0;            // after second sell

        for (int i = 1; i &lt; (int)prices.size(); ++i) {
            f1 = max(f1, -prices[i]);        // buy first
            f2 = max(f2, f1 + prices[i]);    // sell first
            f3 = max(f3, f2 - prices[i]);    // buy second
            f4 = max(f4, f3 + prices[i]);    // sell second
        }
        return f4;                            // best with ?2 transactions
    }
};
</code></pre></details></td></tr>
<tr><td>124</td><td><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/" target="_blank" rel="noopener">Link</a></td><td>Trees</td><td>Hard</td><td>23.0</td><td>28.24</td><td>O(N)</td><td>O(N)</td><td>23</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int ans;
    int getmax(TreeNode *cur){
        int leftmax=0;
        int rightmax=0;
        if(cur-&gt;left!=NULL){
            leftmax=max(leftmax,getmax(cur-&gt;left));
        }
        if(cur-&gt;right!=NULL){
            rightmax=max(rightmax,getmax(cur-&gt;right));
        }
        ans=max(ans,leftmax+rightmax+cur-&gt;val);
        ans=max(ans,cur-&gt;val+max(leftmax,rightmax));
        return cur-&gt;val+max(leftmax,rightmax);
    }

    int maxPathSum(TreeNode* root) {
        ans=root-&gt;val;
        getmax(root);
        return ans;
    }
};</code></pre></details></td><td>0</td><td>27.92</td><td>O(N)</td><td>O(N)</td><td>21</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int ans;
    
    int getmax(TreeNode* cur) {
        if (!cur) return 0;
        int leftmax = max(0, getmax(cur-&gt;left));   // max path sum on left subtree or 0 if negative
        int rightmax = max(0, getmax(cur-&gt;right)); // max path sum on right subtree or 0 if negative
        
        ans = max(ans, cur-&gt;val + leftmax + rightmax); // path through current node
        
        return cur-&gt;val + max(leftmax, rightmax); // max path downward for parent node usage
    }
    
    int maxPathSum(TreeNode* root) {
        ans = INT_MIN;
        getmax(root);
        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>140</td><td><a href="https://leetcode.com/problems/word-break-ii/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Hard</td><td>0.0</td><td>7.29</td><td>O(2^n)</td><td>O(n)</td><td>51</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    vector&lt;string&gt;ans;
    string temp=&quot;&quot;;
    unordered_map&lt;string,bool&gt;map1;

    void recur(string &amp;s,int ind){
        cout&lt;&lt;ind&lt;&lt;&quot; &quot;&lt;&lt;temp&lt;&lt;endl;
        int n=s.length();
        if(ind==n){
            temp.pop_back();
            ans.push_back(temp);
            temp+=&#x27; &#x27;;
            return;
        }
        string cur=&quot;&quot;;
        for(int i=ind;i&lt;n;i++){
            cur+=s[i];
            if(map1[cur]){
                temp+=cur;
                temp+=&#x27; &#x27;;
                recur(s,i+1);
                temp.pop_back();
                for(int i=0;i&lt;cur.length();i++)
                    temp.pop_back();
            }
        }
        return;
    }

    vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {
        for(string &amp;str:wordDict)
            map1[str]=1;
        recur(s,0);
        return ans;
    }
};</code></pre></details></td><td>error</td><td>error</td><td>O(2^n)</td><td>O(n)</td><td>31</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {
        unordered_set&lt;string&gt; dict(wordDict.begin(), wordDict.end());      // O(T) space, T = total dict chars [web:378]
        int n = s.size();
        unordered_map&lt;int, vector&lt;string&gt;&gt; memo;                           // start-index -&gt; list of sentences [web:406]

        function&lt;vector&lt;string&gt;(int)&gt; dfs = [&amp;](int i) -&gt; vector&lt;string&gt; {
            if (memo.count(i)) return memo[i];                             // memo hit [web:406]
            if (i == n) return memo[i] = vector&lt;string&gt;{&quot;&quot;};               // base: one empty sentence [web:406]

            vector&lt;string&gt; res;
            for (int j = i + 1; j &lt;= n; ++j) {
                string word = s.substr(i, j - i);                          // candidate prefix [web:406]
                if (!dict.count(word)) continue;
                for (const string&amp; tail : dfs(j)) {                        // recurse on suffix [web:406]
                    res.push_back(tail.empty() ? word : word + &quot; &quot; + tail);
                }
            }
            return memo[i] = res;
        };

        vector&lt;string&gt; ans = dfs(0);
        if (!ans.empty() &amp;&amp; ans.size() == 1 &amp;&amp; ans[0].empty()) return {};  // normalize empty base
        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>1425</td><td><a href="https://leetcode.com/problems/constrained-subsequence-sum/description/" target="_blank" rel="noopener">Link</a></td><td>Queue</td><td>Hard</td><td>518.0</td><td>203</td><td>O(nlogk)</td><td>O(k)</td><td>29</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int constrainedSubsetSum(vector&lt;int&gt;&amp; nums, int k) {
        multiset&lt;int&gt; st;
        st.insert(0);
        int ans = -1e9;
        int ind = -k;
        // vector&lt;int&gt; bestAt(nums.size());
        for(int i = 0; i&lt;nums.size(); i++){
            int prev = *st.rbegin();
            nums[i] = nums[i] + prev;
            st.insert(nums[i]);
            ans = max(ans, nums[i]);
            if(ind &gt;= 0)
                st.erase(st.find(nums[ind]));
            ind++;
        }
        return ans;
    }
};</code></pre></details></td><td>27</td><td>123.94</td><td>O(n)</td><td>O(n)</td><td>27</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int constrainedSubsetSum(vector&lt;int&gt;&amp; nums, int k) {
        int n = nums.size();
        vector&lt;int&gt; dp(n);
        deque&lt;int&gt; dq;                 // indices with dp values in decreasing order [web:238][web:251]
        int best = INT_MIN;

        for (int i = 0; i &lt; n; ++i) {
            // drop indices out of window [i-k, i-1]
            while (!dq.empty() &amp;&amp; dq.front() &lt; i - k) dq.pop_front();     // [web:238][web:251]

            int add = dq.empty() ? 0 : max(0, dp[dq.front()]);            // best prior or start fresh [web:238]
            dp[i] = nums[i] + add;                                        // transition [web:238]
            best = max(best, dp[i]);                                      // track answer [web:238]

            // maintain decreasing dp in deque
            while (!dq.empty() &amp;&amp; dp[dq.back()] &lt;= dp[i]) dq.pop_back();  // [web:238][web:251]
            dq.push_back(i);                                              // push current index [web:238]
        }
        return best;                                                      // [web:242]
    }
};
</code></pre></details></td></tr>
<tr><td>174</td><td><a href="https://leetcode.com/problems/dungeon-game/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Hard</td><td>3.0</td><td>8.55</td><td>O(n)</td><td>O(1)</td><td>51</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) {
        int m=dungeon.size(),n=dungeon[0].size();
        for(int i=m-1;i&gt;=0;i--){
            for(int j=n-1;j&gt;=0;j--){
                if(i+1==m&amp;&amp;j+1==n)
                        continue;
                if(dungeon[i][j]&lt;=0){                    
                    if(i+1==m){
                        if(dungeon[i][j+1]&lt;=0)
                        dungeon[i][j]+=dungeon[i][j+1];
                        
                    }
                    else if(j+1==n){
                        if(dungeon[i+1][j]&lt;=0)
                        dungeon[i][j]+=dungeon[i+1][j];
                    }
                    else if(dungeon[i+1][j]&gt;0||dungeon[i][j+1]&gt;0){
                        continue;
                    }
                    else{
                        dungeon[i][j]=dungeon[i][j]+max(dungeon[i+1][j],dungeon[i][j+1]);
                    }
                }
                else{
                    if(i+1==m){
                        dungeon[i][j]+=dungeon[i][j+1];
                        
                    }
                    else if(j+1==n){
                        dungeon[i][j]+=dungeon[i+1][j];
                    }
                    else{
                        dungeon[i][j]=dungeon[i][j]+max(dungeon[i+1][j],dungeon[i][j+1]);
                    }
                }
            }
        }
        if(dungeon[0][0]&lt;=0)
            return -dungeon[0][0]+1;
        return 1;
    }
};</code></pre></details></td><td>3</td><td>13.02</td><td>O(n)</td><td>O(1)</td><td>23</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) {
        int m = dungeon.size(), n = dungeon[0].size();
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, INT_MAX));              // sentinels [web:417]
        dp[m][n - 1] = dp[m - 1][n] = 1;                                          // need ?1 after last cell [web:417]

        for (int i = m - 1; i &gt;= 0; --i) {
            for (int j = n - 1; j &gt;= 0; --j) {
                int need = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];      // from right/down [web:416]
                dp[i][j] = max(1, need);                                          // health cannot drop below 1 [web:416]
            }
        }
        return dp[0][0];                                                          // min initial HP [web:416]
    }
};
</code></pre></details></td></tr>
<tr><td>188</td><td><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Hard</td><td>7.0</td><td>11.62</td><td>O(n)</td><td>O(n)</td><td>51</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int maxProfit(int k, vector&lt;int&gt;&amp; prices) {
        k*=2;
        int dp[prices.size()][k];
        int n=prices.size();
        for(int i=0;i&lt;n;i++){
            for(int j=0;j&lt;k;j++){
                dp[i][j]=-1000000;
            }
        }
        int ans=0;
        for(int i=0;i&lt;n;i++){
            for(int j=0;j&lt;k&amp;&amp;j&lt;=i;j++){
                if(i&gt;0){
                    dp[i][j]=dp[i-1][j];
                }
                if(j%2==0){
                    if(j==0){
                        dp[i][j]=max(dp[i][j],-prices[i]);
                    }
                    else{
                        dp[i][j]=max(dp[i][j],dp[i-1][j-1]-prices[i]);
                    }
                }
                else{
                    dp[i][j]=max(dp[i][j],dp[i-1][j-1]+prices[i]);
                }
                // cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;
            }
            // cout&lt;&lt;endl;
        }

        for(int i=0;i&lt;k;i++){
            ans=max(ans,dp[n-1][i]);
        }
        return ans;
    }   
};</code></pre></details></td><td>0</td><td>14.34</td><td>O(n)</td><td>O(n)</td><td>33</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int maxProfit(int k, vector&lt;int&gt;&amp; prices) {
        int n = prices.size();
        if (n == 0 || k == 0) return 0;

        // If k &gt;= n/2, it&#x27;s equivalent to unlimited transactions (greedy).
        if (k &gt;= n / 2) {
            int profit = 0;
            for (int i = 1; i &lt; n; ++i)
                if (prices[i] &gt; prices[i - 1]) profit += prices[i] - prices[i - 1];
            return profit;
        }

        // hold[t]: max profit after t buys and currently holding
        // cash[t]: max profit after t sells (i.e., t completed transactions) and not holding
        vector&lt;int&gt; hold(k + 1, INT_MIN / 2), cash(k + 1, 0);
        for (int price : prices) {
            // t goes from 1..k; update hold using cash[t-1], update cash using hold[t]
            for (int t = 1; t &lt;= k; ++t) {
                hold[t] = max(hold[t], cash[t - 1] - price);
                cash[t] = max(cash[t], hold[t] + price);
            }
        }
        return cash[k];
    }
};
</code></pre></details></td></tr>
<tr><td>224</td><td><a href="https://leetcode.com/problems/basic-calculator/description/" target="_blank" rel="noopener">Link</a></td><td>Stack</td><td>Hard</td><td>16.0</td><td>8.52</td><td>O(n)</td><td>O(n)</td><td>108</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int calculate(string s) {
        stack&lt;char&gt;st;
        long result=0;
        long cur=0;
        long mul=1;
        for(char i:s){
            if(i==&#x27; &#x27;)continue;
            else if(i==&#x27;)&#x27;){
                result=0;
                cur=0;
                mul=1;
                while(st.top()!=&#x27;(&#x27;){
                    char x=st.top();
                    if(x&gt;=&#x27;0&#x27;&amp;&amp; x&lt;=&#x27;9&#x27;){
                        cur+=mul*int(x-&#x27;0&#x27;);
                        mul*=10;
                    }
                    else{
                        if(x==&#x27;+&#x27;){
                            result+=cur;
                            cur=0;mul=1;
                        }
                        else{
                            st.pop();
                            if(!st.empty()&amp;&amp;st.top()==&#x27;-&#x27;)
                                result+=cur;
                            else{
                                st.push(&#x27;-&#x27;);
                                result-=cur;
                            }
                            cur=0;mul=1;
                        }
                    }
                    st.pop();                    
                }
                result+=cur;
                st.pop();
                string y=&quot;&quot;;
                if(result==0)st.push(&#x27;0&#x27;);
                if(result&lt;0){
                    result*=-1;
                    st.push(&#x27;-&#x27;);
                }
                while(result&gt;0){
                    y+=char(&#x27;0&#x27;+result%10);
                    result/=10;
                }

                reverse(y.begin(),y.end());
                for(char i:y)
                    st.push(i);
            }
            else{
                st.push(i);
            }
        }
        result=0;
        cur=0;
        mul=1;
        while(!st.empty()){            
            char x=st.top();
            st.pop();
            if(x&gt;=&#x27;0&#x27;&amp;&amp; x&lt;=&#x27;9&#x27;){
                cur+=mul*int(x-&#x27;0&#x27;);
                mul*=10;
            }
            else if(x==&#x27;+&#x27;){
                    result+=cur;
                    cur=0;mul=1;
                }
                else if(x==&#x27;-&#x27;){                    

                    if(!st.empty()&amp;&amp;st.top()==&#x27;-&#x27;){                        
                        st.pop();
                        result+=cur;
                    }
                    else{
                        result-=cur;
                    }
                    cur=0;mul=1;
                }
                             
        }
        result+=cur;
        return result;
    }
};

//&quot;1-2-4-0-10</code></pre></details></td><td>4</td><td>13.48</td><td>O(n)</td><td>O(n)</td><td>36</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int calculate(string s) {
        long ans = 0;          // current accumulated result [web:107][web:111]
        int sign = 1;          // current sign to apply (+1 or -1) [web:107][web:111]
        stack&lt;int&gt; st;         // stack to store previous ans and sign around &#x27;(&#x27; [web:107][web:111]
        const int n = s.size();

        for (int i = 0; i &lt; n; ++i) {
            char c = s[i];
            if (c == &#x27; &#x27;) continue; // skip spaces [web:107]

            if (isdigit(c)) {
                long x = 0;
                while (i &lt; n &amp;&amp; isdigit(s[i])) {      // parse multi-digit number [web:107][web:111]
                    x = x * 10 + (s[i] - &#x27;0&#x27;);
                    ++i;
                }
                ans += sign * x;                       // apply current sign [web:107][web:111]
                --i;                                   // step back since for loop will ++i [web:111]
            } else if (c == &#x27;+&#x27;) {
                sign = 1;                              // next number positive [web:107][web:111]
            } else if (c == &#x27;-&#x27;) {
                sign = -1;                             // next number negative (handles unary -) [web:107][web:111]
            } else if (c == &#x27;(&#x27;) {
                st.push(ans);                          // save previous result [web:107][web:111]
                st.push(sign);                         // save sign before parentheses [web:107][web:111]
                ans = 0;                               // reset for subexpression [web:107][web:111]
                sign = 1;                              // default sign for new context [web:107][web:111]
            } else if (c == &#x27;)&#x27;) {
                int prevSign = st.top(); st.pop();     // sign before &#x27;(&#x27; [web:111]
                int prevAns  = st.top(); st.pop();     // result before &#x27;(&#x27; [web:111]
                ans = prevAns + prevSign * ans;        // combine with proper sign [web:107][web:111]
            }
        }
        return (int)ans;                                // fits 32-bit per constraints [web:108]
    }
};
</code></pre></details></td></tr>
<tr><td>2296</td><td><a href="https://leetcode.com/problems/design-a-text-editor/description/" target="_blank" rel="noopener">Link</a></td><td>Linked List</td><td>Hard</td><td>595.0</td><td>275.41</td><td>O(n)</td><td>O(n)</td><td>65</td><td><details class="code"><summary>View</summary><pre><code>//doubly linked list 

class node{
    public:
    char ch;
    node * left=nullptr;
    node * right=nullptr;
};

static string ans=&quot;&quot;;

class TextEditor {
    public:    
    node * cursor=nullptr;    //cursor&#x27;s position is btw pointer &#x27;cursor&#x27; and &#x27;cursor-&gt;right&#x27;
    node * head=nullptr;
    node * tail=nullptr;
    

    TextEditor() {
        head=new node;
        tail=new node;
        cursor=head;
        head-&gt;right=tail;
        tail-&gt;left=head;        
    }
    
    void addText(string text) {
        for(char c:text){

            node * temp = new node;
            temp -&gt; ch = c;    

            cursor -&gt; right -&gt; left = temp;         // inserting nodes in DLL
            temp -&gt; right = cursor -&gt; right ;
            cursor -&gt; right = temp;
            temp -&gt; left = cursor;

            cursor = cursor -&gt; right;
        }
    }
    
    int deleteText(int k) {
        int charDeleted=0;
        while(k--){
            if(cursor!=head){

                cursor-&gt;left-&gt;right=cursor-&gt;right;
                cursor-&gt;right-&gt;left=cursor-&gt;left;
                                
                node * temp = cursor;      
                cursor = cursor-&gt;left;          
                delete temp; // deleting node from DLL 

                charDeleted++; // increment count
            }
        }
        return charDeleted;
    }
    
    string cursorLeft(int k) {
        ans.clear();
        while(k--){     // traverse left
            if(cursor!=head){
                cursor=cursor-&gt;left;
            }
        }
        node * temp = cursor;
        k=10;
        while(k--){     
            if(temp!=head){
                ans+=temp-&gt;ch;
                temp=temp-&gt;left;
            }
        }
        for(int i=0;i&lt;ans.length()/2;i++)   //reversal of str
            swap(ans[i],ans[ans.length()-1-i]);
        return ans;
    }
    
    string cursorRight(int k) {
        ans.clear();
        while(k--){     //traverse right
            if(cursor-&gt;right!=tail){                
                cursor=cursor-&gt;right;
            }
        }
        node * temp = cursor ;
        k=10;
        while(k--){
            if(temp!=head){
                ans+=temp-&gt;ch;
                temp=temp-&gt;left;
            }
        }
        for(int i=0;i&lt;ans.length()/2;i++) //reversal of str
            swap(ans[i],ans[ans.length()-1-i]);
        return ans;
    }

};</code></pre></details></td><td>70</td><td>144</td><td>O(n)</td><td>O(n)</td><td>60</td><td><details class="code"><summary>View</summary><pre><code>class TextEditor {
private:
    stack&lt;char&gt; leftStack;   // Characters to the left of the cursor
    stack&lt;char&gt; rightStack;  // Characters to the right of the cursor

public:
    TextEditor() {
        // Initially empty text, cursor at start
    }
    
    void addText(string text) {
        for (char c : text) {
            leftStack.push(c);  // Add characters to the left side (cursor moves right)
        }
    }
    
    int deleteText(int k) {
        int deleted = 0;
        while (k &gt; 0 &amp;&amp; !leftStack.empty()) {
            leftStack.pop();
            deleted++;
            k--;
        }
        return deleted;
    }
    
    string cursorLeft(int k) {
        while (k &gt; 0 &amp;&amp; !leftStack.empty()) {
            rightStack.push(leftStack.top());
            leftStack.pop();
            k--;
        }
        return getLastTenChars();
    }
    
    string cursorRight(int k) {
        while (k &gt; 0 &amp;&amp; !rightStack.empty()) {
            leftStack.push(rightStack.top());
            rightStack.pop();
            k--;
        }
        return getLastTenChars();
    }
    
private:
    string getLastTenChars() {
        string result;
        stack&lt;char&gt; tempStack;
        // We&#x27;ll peek up to 10 chars from leftStack (top means closest to cursor)
        int count = 0;
        while (!leftStack.empty() &amp;&amp; count &lt; 10) {
            tempStack.push(leftStack.top());
            leftStack.pop();
            count++;
        }
        // Build result and restore leftStack
        while (!tempStack.empty()) {
            result += tempStack.top();
            leftStack.push(tempStack.top());
            tempStack.pop();
        }
        return result;
    }
};
</code></pre></details></td></tr>
<tr><td>23</td><td><a href="https://leetcode.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="noopener">Link</a></td><td>Linked List</td><td>Hard</td><td>17.0</td><td>13</td><td>O(Nlogk)</td><td>O(1) </td><td>63</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        if(lists.size()==0)return nullptr;
        while(lists.size()&gt;1){
            int cur=0;  
            for (int i=1;i&lt;lists.size();i+=2){                
                ListNode * ptr1 = lists[i];
                ListNode * ptr2 = lists[i-1];
                ListNode * prev = nullptr;
                ListNode * head = nullptr;
                bool flag=1;
                 
                while(1){
                    if(ptr1==nullptr&amp;&amp;ptr2==nullptr){break;}
                    if(ptr1==nullptr){
                        if(prev!=nullptr)
                            prev-&gt;next=ptr2;
                        prev=ptr2;
                        ptr2=ptr2-&gt;next;                        
                    }
                    else if(ptr2==nullptr){
                        if(prev!=nullptr)
                            prev-&gt;next=ptr1;
                        prev=ptr1;
                        ptr1=ptr1-&gt;next;  
                    }
                    else if((ptr1-&gt;val)&lt;(ptr2-&gt;val)){
                        if(prev!=nullptr)
                            prev-&gt;next=ptr1;
                        prev=ptr1;
                        ptr1=ptr1-&gt;next;  
                    }
                    else{
                        if(prev!=nullptr)
                            prev-&gt;next=ptr2;
                        prev=ptr2;
                        ptr2=ptr2-&gt;next;  
                    }
                    if(flag){
                        head=prev;
                        flag=0;
                    }
                }

                if(prev!=nullptr)
                prev-&gt;next=nullptr;
                lists[cur++]=head;

            }

            if(lists.size()%2){
                lists[cur++]=lists.back();
            }

            while(lists.size()!=cur)
                lists.pop_back();

        }   
        return lists[0];
    }
};</code></pre></details></td><td>3</td><td>18.33</td><td>O(Nlogk)</td><td>O(k)</td><td>30</td><td><details class="code"><summary>View</summary><pre><code>struct compare {
    bool operator()(const ListNode* a, const ListNode* b) const {
        return a-&gt;val &gt; b-&gt;val;
    }
};

class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, compare&gt; minHeap;
        for (auto node : lists) {
            if (node) minHeap.push(node);
        }

        ListNode dummy(0);
        ListNode* current = &amp;dummy;

        while (!minHeap.empty()) {
            ListNode* node = minHeap.top();
            minHeap.pop();
            current-&gt;next = node;
            current = current-&gt;next;
            if (node-&gt;next) minHeap.push(node-&gt;next);
        }

        return dummy.next;
    }
};
</code></pre></details></td></tr>
<tr><td>2322</td><td><a href="https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/description/" target="_blank" rel="noopener">Link</a></td><td>Trees</td><td>Hard</td><td>248.0</td><td>17.97</td><td>O(n^2)</td><td>O(n)</td><td>49</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    int getXorOfAll(int node, int par, vector&lt;vector&lt;int&gt;&gt;&amp; children, vector&lt;int&gt;&amp; val){
        int ans = val[node];
        for(int i = 0; i&lt;children[node].size(); i++){
            if(children[node][i] != par)
                ans ^= getXorOfAll(children[node][i], node, children, val);
        }
        return ans;
    }

    int splitXorInSubtree(int node, int par, int xorOfFirstSplit, int xorOfAll, int&amp; ans, vector&lt;vector&lt;int&gt;&gt;&amp; children, vector&lt;int&gt;&amp; nums){
        int xorOfSubtree = 0;
        for(int i = 0; i&lt;children[node].size(); i++){
            if(children[node][i] != par){
                int xorOfCurSubtree = splitXorInSubtree(children[node][i], node, xorOfFirstSplit, xorOfAll, ans, children, nums);
                xorOfSubtree ^= xorOfCurSubtree;
                // assuming second split to be this edge
                int xorOfFirstSubtree = xorOfFirstSplit;
                int xorOfSecondSubtree = xorOfAll ^ xorOfCurSubtree;
                int xorOfThirdSubtree = xorOfCurSubtree;
                ans = min(ans, max(xorOfFirstSubtree, max(xorOfSecondSubtree, xorOfThirdSubtree)) -  min(xorOfFirstSubtree, min(xorOfSecondSubtree, xorOfThirdSubtree)));

            }
        }
        xorOfSubtree ^= nums[node];
        return xorOfSubtree;
    }

    int minimumScore(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        vector&lt;vector&lt;int&gt;&gt; children(nums.size());
        for(int i = 0; i&lt;edges.size(); i++){
            children[edges[i][0]].push_back(edges[i][1]);
            children[edges[i][1]].push_back(edges[i][0]);
        }
        int ans = INT_MAX;
        // iterate over all possible cases
        for(int i = 0; i&lt;edges.size(); i++){
            //split ith edges - 1st split
            int node1 = edges[i][0], node2 = edges[i][1];
            int xor1 = getXorOfAll(node1, node2, children, nums), xor2 = getXorOfAll(node2, node1, children, nums);
            //spliting int node1 subtree and node2 subtree - 2nd split
            splitXorInSubtree(node1, node2, xor2, xor1, ans, children, nums);
            splitXorInSubtree(node2, node1, xor1, xor2, ans, children, nums); 
        }
        return ans;
    }
};</code></pre></details></td><td>error</td><td>error</td><td>O(n^3)</td><td>O(n)</td><td>45</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
    vector&lt;vector&lt;int&gt;&gt; graph;
    vector&lt;int&gt; nums;
    vector&lt;int&gt; subtreeXor;
    int totalXor;
    int n;
    int ans = INT_MAX;

    // DFS to compute the XOR of subtree rooted at node
    int dfs(int node, int parent) {
        int xor_val = nums[node];
        for (int neighbor : graph[node]) {
            if (neighbor != parent) {
                xor_val ^= dfs(neighbor, node);
            }
        }
        subtreeXor[node] = xor_val;
        return xor_val;
    }

    // Helper to check pairs of removed edges and update ans
    void dfsCheck(int u, int parent, int firstEdgeU, int firstEdgeV) {
        for (int v : graph[u]) {
            if (v == parent) continue;
            // Skip the first removed edge
            if ((u == firstEdgeU &amp;&amp; v == firstEdgeV) || (v == firstEdgeU &amp;&amp; u == firstEdgeV)) continue;

            // Three components XOR:
            int a = subtreeXor[v];
            int b = subtreeXor[firstEdgeV];
            int c = totalXor ^ a ^ b;

            int maxXor = max({a, b, c});
            int minXor = min({a, b, c});
            ans = min(ans, maxXor - minXor);

            dfsCheck(v, u, firstEdgeU, firstEdgeV);
        }
    }

public:
    int minimumScore(vector&lt;int&gt;&amp; nums_, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        nums = nums_;
        n = nums.size();
        graph.resize(n);
        subtreeXor.resize(n);

        // build the graph
        for (auto&amp; edge : edges) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }

        totalXor = dfs(0, -1);

        // Try removing two edges
        for (auto&amp; firstEdge : edges) {
            // Remove first edge by checking its removal in dfsCheck
            dfsCheck(0, -1, firstEdge[0], firstEdge[1]);
        }

        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>2322</td><td><a href="https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/description/" target="_blank" rel="noopener">Link</a></td><td>Bit Manipulation</td><td>Hard</td><td>248.0</td><td>17</td><td>O(n^2)</td><td>O(n)</td><td>61</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    int getXorOfAll(int node, int par, vector&lt;vector&lt;int&gt;&gt;&amp; children, vector&lt;int&gt;&amp; val){
        int ans = val[node];
        for(int i = 0; i&lt;children[node].size(); i++){
            if(children[node][i] != par)
                ans ^= getXorOfAll(children[node][i], node, children, val);
        }
        return ans;
    }

    int splitXorInSubtree(int node, int par, int xorOfFirstSplit, int xorOfAll, int&amp; ans, vector&lt;vector&lt;int&gt;&gt;&amp; children, vector&lt;int&gt;&amp; nums){
        int xorOfSubtree = 0;
        for(int i = 0; i&lt;children[node].size(); i++){
            if(children[node][i] != par){
                int xorOfCurSubtree = splitXorInSubtree(children[node][i], node, xorOfFirstSplit, xorOfAll, ans, children, nums);
                xorOfSubtree ^= xorOfCurSubtree;
                // assuming second split to be this edge
                int xorOfFirstSubtree = xorOfFirstSplit;
                int xorOfSecondSubtree = xorOfAll ^ xorOfCurSubtree;
                int xorOfThirdSubtree = xorOfCurSubtree;
                ans = min(ans, max(xorOfFirstSubtree, max(xorOfSecondSubtree, xorOfThirdSubtree)) -  min(xorOfFirstSubtree, min(xorOfSecondSubtree, xorOfThirdSubtree)));

            }
        }
        xorOfSubtree ^= nums[node];
        return xorOfSubtree;
    }

    int minimumScore(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        vector&lt;vector&lt;int&gt;&gt; children(nums.size());
        for(int i = 0; i&lt;edges.size(); i++){
            children[edges[i][0]].push_back(edges[i][1]);
            children[edges[i][1]].push_back(edges[i][0]);
        }
        int ans = INT_MAX;
        // iterate over all possible cases
        for(int i = 0; i&lt;edges.size(); i++){
            //split ith edges - 1st split
            int node1 = edges[i][0], node2 = edges[i][1];
            int xor1 = getXorOfAll(node1, node2, children, nums), xor2 = getXorOfAll(node2, node1, children, nums);
            //spliting int node1 subtree and node2 subtree - 2nd split
            splitXorInSubtree(node1, node2, xor2, xor1, ans, children, nums);
            splitXorInSubtree(node2, node1, xor1, xor2, ans, children, nums); 
        }
        return ans;
    }
};</code></pre></details></td><td>error</td><td>error</td><td>O(n^2)</td><td>O(n)</td><td>77</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int minimumScore(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        int n = nums.size();
        vector&lt;vector&lt;int&gt;&gt; g(n);
        for (auto&amp; e : edges) {
            int u = e[0], v = e[1];
            g[u].push_back(v);
            g[v].push_back(u);
        }

        // Root the tree at 0: compute parent, tin/tout, and subtree xor
        vector&lt;int&gt; parent(n, -1), tin(n), tout(n), sub(n);
        int timer = 0;
        function&lt;void(int,int)&gt; dfs = [&amp;](int u, int p) {
            parent[u] = p;
            tin[u] = ++timer;
            sub[u] = nums[u];
            for (int v : g[u]) if (v != p) {
                dfs(v, u);
                sub[u] ^= sub[v];
            }
            tout[u] = timer;
        };
        dfs(0, -1);

        auto isAncestor = [&amp;](int u, int v) {
            // u is ancestor of v in the rooted tree
            return tin[u] &lt;= tin[v] &amp;&amp; tout[v] &lt;= tout[u];
        };

        // Represent each undirected edge as (child -&gt; parent) by orienting away from root
        vector&lt;pair&lt;int,int&gt;&gt; oriented;
        oriented.reserve(n - 1);
        for (auto&amp; e : edges) {
            int u = e[0], v = e[1];
            if (parent[u] == v) oriented.push_back({u, v});
            else if (parent[v] == u) oriented.push_back({v, u});
            else {
                // in a rooted tree one endpoint must be parent of the other
                // but guard anyway
                if (tin[u] &gt; tin[v]) oriented.push_back({u, v});
                else oriented.push_back({v, u});
            }
        }

        int total = 0;
        for (int x : nums) total ^= x;

        int best = INT_MAX;
        int m = oriented.size();
        // Try each ordered pair of cuts (a, b) where a is cut child-&gt;parent and b is another cut
        for (int i = 0; i &lt; m; ++i) {
            int a = oriented[i].first;   // cutting edge between a and parent[a]
            // After cutting edge a, component A is subtree(a) with xorA = sub[a]
            int xorA = sub[a];
            int xorRest = total ^ xorA;  // the rest of the tree xor

            for (int j = 0; j &lt; m; ++j) if (j != i) {
                int b = oriented[j].first; // cutting edge between b and parent[b]

                int x1, x2, x3;
                if (isAncestor(a, b)) {
                    // second cut lies inside subtree(a)
                    int xorB = sub[b];
                    x1 = xorB;                 // component at b
                    x2 = xorA ^ xorB;          // remainder of subtree(a)
                    x3 = xorRest;              // the rest outside subtree(a)
                } else if (isAncestor(b, a)) {
                    // second cut lies outside subtree(a) but we remove b&#x27;s subtree from the rest
                    int xorB = sub[b];
                    x1 = xorA;                 // subtree(a)
                    x2 = xorB;                 // subtree(b)
                    x3 = xorRest ^ xorB;       // rest minus subtree(b)
                } else {
                    // disjoint subtrees for a and b
                    int xorB = sub[b];
                    x1 = xorA;
                    x2 = xorB;
                    x3 = total ^ xorA ^ xorB;
                }
                int mx = max(x1, max(x2, x3));
                int mn = min(x1, min(x2, x3));
                best = min(best, mx - mn);
            }
        }
        return best;
    }
};
</code></pre></details></td></tr>
<tr><td>233</td><td><a href="https://leetcode.com/problems/number-of-digit-one/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Hard</td><td>0.0</td><td>6</td><td>O(logn)</td><td>O(1)</td><td>21</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int countDigitOne(int n) {
        int nx=n;
        long temp=1;int curr;int ans=0;
        while(nx&gt;0){
            curr=nx%10;
            nx=nx/10;
            ans+=nx*temp;         
            if(curr==1){
                ans+=(n%temp)+1;
            }
            if(curr&gt;1){
                ans+=temp;
            }
            temp*=10;
        }
        return ans;
    }
};</code></pre></details></td><td>0</td><td>7.91</td><td>O(logn)</td><td>O(1)</td><td>24</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int countDigitOne(int n) {
        long k = 1;                 // 1, 10, 100, ...
        long ans = 0;
        while (k &lt;= n) {
            long higher = n / (k * 10);      // left of current digit [web:453]
            long current = (n / k) % 10;     // current digit at place k [web:453]
            long lower = n % k;              // right of current digit [web:453]

            if (current == 0) ans += higher * k;                     // full cycles [web:453]
            else if (current == 1) ans += higher * k + lower + 1;    // partial cycle [web:453]
            else ans += (higher + 1) * k;                            // full cycles + extra [web:453]

            k *= 10;
        }
        return (int)ans;
    }
};
</code></pre></details></td></tr>
<tr><td>239</td><td><a href="https://leetcode.com/problems/sliding-window-maximum/description/" target="_blank" rel="noopener">Link</a></td><td>Queue</td><td>Hard</td><td>189.0</td><td>149</td><td>O(n)</td><td>O(n)</td><td>24</td><td><details class="code"><summary>View</summary><pre><code>
class Solution {
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {
        deque&lt;int&gt;window;
        vector&lt;int&gt;ans;
        for(int i=0;i&lt;nums.size();i++){
            while(!window.empty()&amp;&amp;nums[window.front()]&lt;nums[i]){
                window.pop_front();
            }
            window.push_front(i);
            if(!window.empty()&amp;&amp;window.back()&lt;=i-k){
                window.pop_back();
            }
            if(i&gt;=k-1){
                ans.push_back(nums[window.back()]);
            }            
        }
        return ans;
    }
};</code></pre></details></td><td>16</td><td>139</td><td>O(n)</td><td>O(n)</td><td>23</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {
        deque&lt;int&gt; dq;               // stores indices, values decreasing from front to back [web:223][web:229]
        vector&lt;int&gt; ans;
        for (int i = 0; i &lt; (int)nums.size(); ++i) {
            // remove indices out of window (left side)
            while (!dq.empty() &amp;&amp; dq.front() &lt;= i - k) dq.pop_front();      // [web:223][web:229]
            // maintain decreasing deque: pop smaller values from back
            while (!dq.empty() &amp;&amp; nums[dq.back()] &lt;= nums[i]) dq.pop_back(); // [web:223][web:229]
            dq.push_back(i);                                                // push current index [web:223][web:229]
            if (i &gt;= k - 1) ans.push_back(nums[dq.front()]);                // window max at front [web:223][web:232]
        }
        return ans; // all window maxima [web:223][web:232]
    }
};
</code></pre></details></td></tr>
<tr><td>2444</td><td><a href="https://leetcode.com/problems/count-subarrays-with-fixed-bounds/description/" target="_blank" rel="noopener">Link</a></td><td>Queue</td><td>Hard</td><td>84.0</td><td>82.66</td><td>O(n)</td><td>O(n)</td><td>26</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    long long countSubarrays(vector&lt;int&gt;&amp; nums, int minK, int maxK) {
        long long ans = 0;
        int prevBreakAt = -1;
        int lastMinK = -1, lastMaxK = -1;
        for(int i = 0; i&lt;nums.size(); i++){
            if(nums[i] == minK)
                lastMinK = i;
            if(nums[i] == maxK)
                lastMaxK = i;
            if(nums[i]&lt;minK || nums[i]&gt;maxK){
                lastMinK = -1, lastMaxK = -1;
                prevBreakAt = i;
            }
            if(lastMinK &gt; -1 &amp;&amp; lastMaxK &gt; -1){
                ans += min(lastMinK, lastMaxK)-prevBreakAt;
            }
        }
        return ans;
    }
};</code></pre></details></td><td>0</td><td>93.7</td><td>O(n)</td><td>O(1)</td><td>28</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    long long countSubarrays(vector&lt;int&gt;&amp; nums, int minK, int maxK) {
        long long ans = 0;
        int lastBad = -1;        // last index where nums[i] &lt; minK or nums[i] &gt; maxK
        int lastMin = -1;        // last index where nums[i] == minK
        int lastMax = -1;        // last index where nums[i] == maxK

        for (int i = 0; i &lt; (int)nums.size(); ++i) {
            if (nums[i] &lt; minK || nums[i] &gt; maxK) {
                lastBad = i;
                lastMin = -1;
                lastMax = -1;
            }
            if (nums[i] == minK) lastMin = i;
            if (nums[i] == maxK) lastMax = i;

            if (lastMin != -1 &amp;&amp; lastMax != -1) {
                ans += max(0, min(lastMin, lastMax) - lastBad);
            }
        }
        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>25</td><td><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/description/" target="_blank" rel="noopener">Link</a></td><td>Linked List</td><td>Hard</td><td>12.0</td><td>11.5</td><td>O(n)</td><td> 
O(1)</td><td>49</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode * prevend=nullptr;
        ListNode * start=head;
        ListNode * itr=nullptr;
        ListNode * upnext=nullptr;
        ListNode * prev=nullptr;
        ListNode * end=head;
        bool flag=0;
        int counter;
        while(start!=nullptr){
            counter=1;     
            while(end-&gt;next!=nullptr&amp;&amp;counter&lt;k){
                end=end-&gt;next;counter++;
            }
            if(counter&gt;=k){
                itr=start;
                prev=NULL;
                while(counter&gt;0){
                    if(itr==nullptr)break;
                    upnext=itr-&gt;next;
                    itr-&gt;next=prev;
                    prev=itr;
                    itr=upnext;
                    counter--;
                }                
                if(flag==0){
                    head=end;
                    flag=1;
                }                
                if(prevend!=NULL){
                    prevend-&gt;next=end;
                }
                prevend=start;
                start=upnext;
                end=upnext;
            }
            else{
                if(prevend!=NULL)
                    prevend-&gt;next=start;
                    break;
            }
        }
        return head;
    }
};</code></pre></details></td><td>0</td><td>16.62</td><td>O(n)</td><td>O(1)</td><td>36</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (!head || k == 1) return head;

        ListNode dummy(0);
        dummy.next = head;
        ListNode *cur = &amp;dummy, *nxt = &amp;dummy, *pre = &amp;dummy;
        int count = 0;

        // Count total number of nodes
        while (cur-&gt;next) {
            cur = cur-&gt;next;
            count++;
        }

        while (count &gt;= k) {
            cur = pre-&gt;next;
            nxt = cur-&gt;next;
            for (int i = 1; i &lt; k; i++) {
                cur-&gt;next = nxt-&gt;next;
                nxt-&gt;next = pre-&gt;next;
                pre-&gt;next = nxt;
                nxt = cur-&gt;next;
            }
            pre = cur;
            count -= k;
        }
        return dummy.next;
    }
};
</code></pre></details></td></tr>
<tr><td>297</td><td><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/" target="_blank" rel="noopener">Link</a></td><td>Trees</td><td>Hard</td><td>23.0</td><td>45.78</td><td>O(n)</td><td>O(n)</td><td>56</td><td><details class="code"><summary>View</summary><pre><code>class Codec {
public:

    int offset;
    bool flag;

    void intToString(string &amp;str,int val){

        if(val&lt;0){
            str+=&#x27;-&#x27;;
            val*=-1;
        }
        while(val&gt;0){
            str+=char(val%10+&#x27;0&#x27;);
            val/=10;
        }
        return;

    }

    void stringToInt(string &amp;str,int &amp;ind,TreeNode * node){

        node-&gt;val=0;

        offset=1;
        flag=0;

        if(str[ind]==&#x27;-&#x27;){
            ind++;
            flag=1;
        }

        while(str[ind]&gt;=&#x27;0&#x27;&amp;&amp;str[ind]&lt;=&#x27;9&#x27;){
            node-&gt;val+=int(str[ind]-&#x27;0&#x27;)*offset;
            offset*=10;
            ind++;
        }

        node-&gt;val=flag?-node-&gt;val:node-&gt;val;
        return;

    }

    void helperCode(TreeNode* root,string&amp;str){

        if(root==nullptr)return;

        intToString(str,root-&gt;val);

        if(root-&gt;left){
            str+=&#x27;&lt;&#x27;;
            str+=serialize(root-&gt;left);
        }
        if(root-&gt;right){
            str+=&#x27;&gt;&#x27;;
            str+=serialize(root-&gt;right);
        }
        str+=&#x27;^&#x27;;
        return;

    }

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {

        string str;
        helperCode(root,str);
        return str;

    }

    TreeNode * helperDecode(string &amp;data,int &amp;ind){
        TreeNode * node = new TreeNode;

        stringToInt(data,ind,node);
        
        if(data[ind]==&#x27;&lt;&#x27;){
            ind++;
            node-&gt;left=helperDecode(data,ind);
        }

        if(data[ind]==&#x27;&gt;&#x27;){
            ind++;
            node-&gt;right=helperDecode(data,ind);            
        }

        ind++;
        return node;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int ind=0;
        if(data.empty())return nullptr;
        return helperDecode(data,ind);
    }
};</code></pre></details></td><td>error</td><td>error</td><td>O(n)</td><td>O(n)</td><td>17</td><td><details class="code"><summary>View</summary><pre><code>struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Codec {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if (!root) return &quot;null,&quot;;
        return to_string(root-&gt;val) + &quot;,&quot; + serialize(root-&gt;left) + serialize(root-&gt;right);
    }

    // Helper function to decode from string stream.
    TreeNode* deserializeHelper(istringstream &amp;ss) {
        string val;
        getline(ss, val, &#x27;,&#x27;);
        if (val == &quot;null&quot;) return nullptr;
        TreeNode* node = new TreeNode(stoi(val));
        node-&gt;left = deserializeHelper(ss);
        node-&gt;right = deserializeHelper(ss);
        return node;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream ss(data);
        return deserializeHelper(ss);
    }
};</code></pre></details></td></tr>
<tr><td>30</td><td><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Hard</td><td>37.0</td><td>18.,4</td><td>O(n^2)</td><td>O(n)</td><td>60</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        vector&lt;int&gt;helper(s.length(),-1);
        unordered_map&lt;string,int&gt;m;
        unordered_map&lt;int,int&gt;p;
        int z=0;
        for(auto &amp;i:words){
            m[i]=z++;
        }         
        for(auto &amp;i:words){
            p[m[i]]++;
        }
        for(int i=0;i&lt;s.length();i++){
            string x=&quot;&quot;;
            for(int j=i;j&lt;s.length()&amp;&amp;x.length()&lt;words[0].length();j++){
                x+=s[j];
            }
            if(m.find(x)!=m.end()){
                helper[i]=m[x];
            }
        }
        int left=0,right=0,win=(words.size())*words[0].length();
        vector&lt;int&gt;ans;
        unordered_map&lt;int,int&gt;curwin[words[0].length()];
        vector&lt;int&gt;size(words[0].length(),0);
        if(helper[right]!=-1){
            size[right%words[0].length()]++;
            curwin[right%words[0].length()][helper[right]]++;
        }
        while(right&lt;s.length()){                    
            if(right-left+1==win){                
                if(helper[left]!=-1){
                    if(size[left%words[0].length()]==words.size()){
                        ans.push_back(left);
                    }
                    if(curwin[left%words[0].length()][helper[left]]&lt;=p[helper[left]])
                        size[left%words[0].length()]--;
                    curwin[left%words[0].length()][helper[left]]--;
                    if(curwin[left%words[0].length()][helper[left]]==0)
                        curwin[left%words[0].length()].erase(helper[left]);
                }
                left++;
            }
            else if(right-left+1&lt;win){
                right++;
                if(right==s.length())
                    break;
                if(helper[right]!=-1){
                    if(curwin[right%words[0].length()][helper[right]]&lt;p[helper[right]])
                        size[right%words[0].length()]++;
                    curwin[right%words[0].length()][helper[right]]++;
                }
            }
        }
        return ans;
    }
};</code></pre></details></td><td>20</td><td>23.94</td><td>O(n^2)</td><td>O(n)</td><td>48</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        vector&lt;int&gt; indices;
        if (s.empty() || words.empty()) return indices;

        int wordLength = words[0].size();
        int wordCount = words.size();
        int substringLength = wordLength * wordCount;
        if (s.size() &lt; substringLength) return indices;

        unordered_map&lt;string, int&gt; wordMap;
        for (const string&amp; word : words) {
            wordMap[word]++;
        }

        // Check for each offset in the word-length window
        for (int i = 0; i &lt; wordLength; i++) {
            int left = i, right = i, count = 0;
            unordered_map&lt;string, int&gt; currentMap;

            while (right + wordLength &lt;= s.size()) {
                string word = s.substr(right, wordLength);
                right += wordLength;

                if (wordMap.find(word) != wordMap.end()) {
                    currentMap[word]++;
                    count++;

                    while (currentMap[word] &gt; wordMap[word]) {
                        string leftWord = s.substr(left, wordLength);
                        currentMap[leftWord]--;
                        count--;
                        left += wordLength;
                    }

                    if (count == wordCount) {
                        indices.push_back(left);
                    }
                } else {
                    currentMap.clear();
                    count = 0;
                    left = right;
                }
            }
        }

        return indices;
    }
};</code></pre></details></td></tr>
<tr><td>32</td><td><a href="https://leetcode.com/problems/longest-valid-parentheses/description/" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Hard</td><td>3.0</td><td>6.92</td><td>O(n)</td><td>O(n)</td><td>26</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int longestValidParentheses(string s) {
        int ans=0;
        int dp[s.length()];
        for(int i=0;i&lt;s.length();i++){
            dp[i]=0;
             if(i&gt;0){
                if(s[i]==&#x27;)&#x27;){
                    if(s[i-1]==&#x27;)&#x27;){
                        if(i-dp[i-1]-1&gt;=0&amp;&amp;s[i-dp[i-1]-1]==&#x27;(&#x27;){
                            dp[i]=dp[i-1]+2;
                        }
                    }
                    else{
                        if(i-2&gt;=0){
                        dp[i]=dp[i-2]+2;}
                        else{
                            dp[i]=2;
                        }
                    }
                }
             }    
             if(i-dp[i]&gt;=0){
                dp[i]=dp[i]+dp[i-dp[i]];
            }            
             ans=max(ans,dp[i]);       
        }
        
        return ans;
    }
};</code></pre></details></td><td>2</td><td>11.98</td><td>O(n)</td><td>O(n)</td><td>28</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        int ans = 0;
        vector&lt;int&gt; dp(n, 0);

        for (int i = 1; i &lt; n; i++) {
            if (s[i] == &#x27;)&#x27;) {
                if (s[i - 1] == &#x27;(&#x27;) {
                    // Case: &quot;()&quot;, add 2 plus dp before this pair
                    dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2;
                }
                else if (i - dp[i - 1] &gt; 0 &amp;&amp; s[i - dp[i - 1] - 1] == &#x27;(&#x27;) {
                    // Case: add 2 plus dp before the matching opening bracket plus dp of previous valid substring
                    dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] &gt;= 2 ? dp[i - dp[i - 1] - 2] : 0);
                }
                ans = max(ans, dp[i]);
            }
        }
        return ans;
    }
};</code></pre></details></td></tr>
<tr><td>32</td><td><a href="https://leetcode.com/problems/longest-valid-parentheses/description/" target="_blank" rel="noopener">Link</a></td><td>Stack</td><td>Hard</td><td>3.0</td><td>6.92</td><td>O(n)</td><td>O(n)</td><td>33</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int longestValidParentheses(string s) {
        int ans=0;
        int dp[s.length()];
        for(int i=0;i&lt;s.length();i++){
            dp[i]=0;
             if(i&gt;0){
                if(s[i]==&#x27;)&#x27;){
                    if(s[i-1]==&#x27;)&#x27;){
                        if(i-dp[i-1]-1&gt;=0&amp;&amp;s[i-dp[i-1]-1]==&#x27;(&#x27;){
                            dp[i]=dp[i-1]+2;
                        }
                    }
                    else{
                        if(i-2&gt;=0){
                        dp[i]=dp[i-2]+2;}
                        else{
                            dp[i]=2;
                        }
                    }
                }
             }    
             if(i-dp[i]&gt;=0){
                dp[i]=dp[i]+dp[i-dp[i]];
            }            
             ans=max(ans,dp[i]);       
        }
        
        return ans;
    }
};</code></pre></details></td><td>0</td><td>11.58</td><td>O(n)</td><td>O(n)</td><td>29</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        if (n &lt; 2) return 0;
        vector&lt;int&gt; dp(n, 0); // dp[i] = length of longest valid substring ending at i [web:1][web:2][web:4]
        int ans = 0;

        for (int i = 1; i &lt; n; ++i) {
            if (s[i] == &#x27;)&#x27;) {
                if (s[i - 1] == &#x27;(&#x27;) {
                    dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2; // case &quot;()&quot; [web:1][web:2]
                } else {
                    int j = i - dp[i - 1] - 1;           // potential matching &#x27;(&#x27; index [web:2][web:4]
                    if (j &gt;= 0 &amp;&amp; s[j] == &#x27;(&#x27;) {
                        dp[i] = dp[i - 1] + 2 + (j &gt;= 1 ? dp[j - 1] : 0); // wrap + concatenate [web:1][web:2]
                    }
                }
                ans = max(ans, dp[i]); // track maximum [web:1][web:2]
            }
        }
        return ans; // overall longest length [web:1][web:2][web:8]
    }
};
</code></pre></details></td></tr>
<tr><td>32</td><td><a href="https://leetcode.com/problems/longest-valid-parentheses/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Hard</td><td>3.0</td><td>6.92</td><td>O(n)</td><td>O(n)</td><td>38</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int longestValidParentheses(string s) {
        int ans=0;
        int dp[s.length()];
        for(int i=0;i&lt;s.length();i++){
            dp[i]=0;
             if(i&gt;0){
                if(s[i]==&#x27;)&#x27;){
                    if(s[i-1]==&#x27;)&#x27;){
                        if(i-dp[i-1]-1&gt;=0&amp;&amp;s[i-dp[i-1]-1]==&#x27;(&#x27;){
                            dp[i]=dp[i-1]+2;
                        }
                    }
                    else{
                        if(i-2&gt;=0){
                        dp[i]=dp[i-2]+2;}
                        else{
                            dp[i]=2;
                        }
                    }
                }
             }    
             if(i-dp[i]&gt;=0){
                dp[i]=dp[i]+dp[i-dp[i]];
            }            
             ans=max(ans,dp[i]);       
        }
        
        return ans;
    }
};</code></pre></details></td><td>3</td><td>11.78</td><td>O(n)</td><td>O(n)</td><td>26</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int longestValidParentheses(string s) {
        stack&lt;int&gt; st;
        st.push(-1);                 // base for lengths before first valid segment [web:322][web:325]
        int best = 0;
        for (int i = 0; i &lt; (int)s.size(); ++i) {
            if (s[i] == &#x27;(&#x27;) {
                st.push(i);          // remember index of &#x27;(&#x27; [web:322][web:325]
            } else {
                st.pop();            // match a &#x27;(&#x27; if available [web:322][web:325]
                if (st.empty()) {
                    st.push(i);      // reset base after an unmatched &#x27;)&#x27; [web:322][web:325]
                } else {
                    best = max(best, i - st.top()); // current valid length [web:322][web:325]
                }
            }
        }
        return best;                 // longest length [web:322]
    }
};
</code></pre></details></td></tr>
<tr><td>329</td><td><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/" target="_blank" rel="noopener">Link</a></td><td>Graph</td><td>Hard</td><td>47.0</td><td>16.06</td><td>O(n*m)</td><td>O(n*m)</td><td>32</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;pair&lt;int,int&gt;&gt;moves={{0,1},{1,0},{-1,0},{0,-1}};
    vector&lt;vector&lt;int&gt;&gt;dp;
    int getLIS(vector&lt;vector&lt;int&gt;&gt;&amp;matrix,int i ,int j){
        if(dp[i][j]!=-1)return dp[i][j];
        int ans=1;
        int n=matrix.size();
        int m=matrix[0].size();   
        for(auto k:moves){
            if(i+k.first&gt;=0&amp;&amp;i+k.first&lt;n&amp;&amp;j+k.second&gt;=0&amp;&amp;j+k.second&lt;m){
                if(matrix[i][j]&lt;matrix[i+k.first][j+k.second])
                    ans=max(ans,1+getLIS(matrix,i+k.first,j+k.second));
            }
        }
        return dp[i][j]=ans;
    }
    int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        //maybe dfs + dp -&gt; limiting at greatest(&gt;=) among neighbours
        int n=matrix.size();
        int m=matrix[0].size();                      
        dp=vector&lt;vector&lt;int&gt;&gt;(n,vector&lt;int&gt;(m,-1));
        int ans=1;
        for(int i=0;i&lt;n;i++){
            for(int j=0;j&lt;m;j++){
                ans=max(ans,getLIS(matrix,i,j));
                // cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;
            }
            // cout&lt;&lt;endl;
        }
        return ans;
    }
};</code></pre></details></td><td>error</td><td>error</td><td>O(n*m)</td><td>O(n*m)</td><td>28</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        int m = matrix.size();
        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m, -1));
        vector&lt;pair&lt;int,int&gt;&gt; dirs{{0,1},{1,0},{0,-1},{-1,0}};
        
        function&lt;int(int,int)&gt; dfs = [&amp;](int i, int j) -&gt; int {
            if (dp[i][j] != -1) return dp[i][j];
            int best = 1;
            for (auto [dx, dy] : dirs) {
                int x = i + dx, y = j + dy;
                if (0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; m &amp;&amp; matrix[x][y] &gt; matrix[i][j]) {
                    best = max(best, 1 + dfs(x, y));
                }
            }
            return dp[i][j] = best;
        };

        int ans = 0;
        for (int i = 0; i &lt; n; ++i)
            for (int j = 0; j &lt; m; ++j)
                ans = max(ans, dfs(i, j));
        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>3307</td><td><a href="https://leetcode.com/problems/find-the-k-th-character-in-string-game-ii/description/" target="_blank" rel="noopener">Link</a></td><td>Bit Manipulation</td><td>Hard</td><td>0.0</td><td>28.35</td><td>O(logk)</td><td>O(1)</td><td>28</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    char kthCharacter(long long k, vector&lt;int&gt;&amp; operations) {
        long long len = 1;
        int val = 0;
        int ind = 0;
        for(int i = 1; ; i++){
            len *= 2;
            ind = i-1;
            if(len&gt;=k)
                break;
        }
        for(; ind&gt;=0; ind--){
            if(operations[ind] == 1){
                if(k&gt;len/2){
                    val++;
                }
            }
            if(k&gt;len/2){
                k = k - len/2;
            }            
            len /= 2;
        }
        return &#x27;a&#x27;+(val%26);
    }
};</code></pre></details></td><td>0</td><td>28.41</td><td>O(logk)</td><td>O(1)</td><td>28</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    char kthCharacter(long long k, vector&lt;int&gt;&amp; operations) {
        long long len = 1;
        int val = 0;
        int ind = 0;
        for(int i = 1; ; i++){
            len *= 2;
            ind = i - 1;
            if (len &gt;= k)
                break;
        }
        for(; ind &gt;= 0; ind--){
            if (operations[ind] == 1) {
                if (k &gt; len/2) {
                    val++;
                }
            }
            if (k &gt; len/2) {
                k = k - len/2;
            }
            len /= 2;
        }
        return &#x27;a&#x27; + (val % 26);
    }
};
</code></pre></details></td></tr>
<tr><td>37</td><td><a href="https://leetcode.com/problems/sudoku-solver/description/" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Hard</td><td>98.0</td><td>8.8</td><td>O(1)</td><td>O(1)</td><td>44</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    void fillSudoku(int i, int j, vector&lt;vector&lt;char&gt;&gt;&amp; board, bool&amp; filled, vector&lt;vector&lt;bool&gt;&gt;&amp; presentInRows, vector&lt;vector&lt;bool&gt;&gt;&amp; presentInCols, vector&lt;vector&lt;bool&gt;&gt;&amp; presentInSubMat){
        if(j&gt;=9){
            i++;
            j=0;
        }
        if(i&gt;=9){
            filled = true;
            return;
        }
        if(board[i][j] == &#x27;.&#x27;){
            int matInd = ((i/3)*3) + (j/3);
            for(int k = 1; k&lt;=9; k++){
                if(!presentInRows[i][k] &amp;&amp; !presentInCols[j][k] &amp;&amp; !presentInSubMat[matInd][k]){
                    board[i][j] = char(&#x27;0&#x27; + k);
                    presentInRows[i][k] = presentInCols[j][k] = presentInSubMat[matInd][k] = true;
                    fillSudoku(i, j+1, board, filled, presentInRows, presentInCols, presentInSubMat);
                    if(filled)
                        return;
                    board[i][j] = &#x27;.&#x27;;
                    presentInRows[i][k] = presentInCols[j][k] = presentInSubMat[matInd][k] = false;
                }
            }
        }
        else
            fillSudoku(i, j+1, board, filled, presentInRows, presentInCols, presentInSubMat);
        return;
    }

    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        vector&lt;vector&lt;bool&gt;&gt; presentInRows(9, vector&lt;bool&gt;(10, false)), presentInCols(9, vector&lt;bool&gt;(10, false)), presentInSubMat(9, vector&lt;bool&gt;(10, false));
        for(int i = 0; i&lt;9; i++){
            for(int j = 0; j&lt;9; j++){
                if(board[i][j] != &#x27;.&#x27;){
                    int matInd = ((i/3)*3) + (j/3);
                    int k = int(board[i][j] - &#x27;0&#x27;);
                    presentInRows[i][k] = presentInCols[j][k] = presentInSubMat[matInd][k] = true;
                }
            }
        }
        bool filled = false;
        fillSudoku(0, 0, board, filled, presentInRows, presentInCols, presentInSubMat);
        return;
    }
};</code></pre></details></td><td>223</td><td>8.88</td><td>O(1)</td><td>O(1)</td><td>28</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        backtrack(board, 0);
    }

private:
    bool backtrack(vector&lt;vector&lt;char&gt;&gt;&amp; board, int index) {
        if (index == 81) return true;
        int r = index / 9, c = index % 9;
        if (board[r][c] != &#x27;.&#x27;) return backtrack(board, index + 1);

        for (char k = &#x27;1&#x27;; k &lt;= &#x27;9&#x27;; ++k) {
            if (isValid(board, r, c, k)) {
                board[r][c] = k;
                if (backtrack(board, index + 1)) return true;
                board[r][c] = &#x27;.&#x27;;
            }
        }
        return false;
    }

    bool isValid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int r, int c, char k) {
        for (int j = 0; j &lt; 9; ++j) // check row
            if (board[r][j] == k) return false;
        for (int i = 0; i &lt; 9; ++i) // check column
            if (board[i][c] == k) return false;
        int boxRow = (r / 3) * 3, boxCol = (c / 3) * 3;
        for (int i = boxRow; i &lt; boxRow + 3; ++i)
            for (int j = boxCol; j &lt; boxCol + 3; ++j)
                if (board[i][j] == k) return false;
        return true;
    }
};
</code></pre></details></td></tr>
<tr><td>4</td><td><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Hard</td><td>35.0</td><td>89.2</td><td>O(log(min(m,n)))</td><td>O(1)</td><td>47</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int midind=nums1.size()+nums2.size()+1;
        midind=midind&gt;&gt;1;

        if(nums1.size()&gt;nums2.size())swap(nums1,nums2);

        int low=max(-1,int(midind-nums2.size()-1));int high=nums1.size()-1,div1,div2;        
        while(low&lt;=high){
            
            div1 = (low+high)/2;
            div2 = midind-2-div1;

            int left=INT_MIN,right=INT_MAX;

            if(div1&gt;=0&amp;&amp;div1&lt;nums1.size())
                left=max(left,nums1[div1]);
            if(div1+1&gt;=0&amp;&amp;div1+1&lt;nums1.size())
                right=min(right,nums1[div1+1]);
            if(div2&gt;=0&amp;&amp;div2&lt;nums2.size())
                left=max(left,nums2[div2]);
            if(div2+1&gt;=0&amp;&amp;div2+1&lt;nums2.size())
                right=min(right,nums2[div2+1]);


            if(left&lt;=right){
                if((nums1.size()+nums2.size())%2){
                    return double(left);
                }
                return double((left+right)*1.0/2);
            }else{
                if(div1&gt;=0&amp;&amp;div1&lt;nums1.size()&amp;&amp;div2&gt;=0&amp;&amp;div2&lt;nums2.size()){
                    if(nums1[div1]&gt;nums2[div2]){
                        high=div1-1;
                    }
                    else{
                        low=div1+1;
                    }
                }else if (div1+1&gt;=0&amp;&amp;div1+1&lt;nums1.size()&amp;&amp;div2+1&gt;=0&amp;&amp;div2+1&lt;nums2.size()){
                    if(nums1[div1+1]&gt;nums2[div2+1]){
                        high=div1-1;
                    }
                    else{
                        low=div1+1;
                    }
                }
                else
                    high=div1-1;
            } 
            
        }

        return 0.0;
    }
};</code></pre></details></td><td>0</td><td>95.11</td><td>O(log(min(m,n)))</td><td>O(1)</td><td>29</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        // Ensure nums1 is the smaller array
        if (nums1.size() &gt; nums2.size())
            return findMedianSortedArrays(nums2, nums1);

        int m = nums1.size(), n = nums2.size();
        int left = 0, right = m;
        while (left &lt;= right) {
            int partition1 = (left + right) / 2;
            int partition2 = (m + n + 1) / 2 - partition1;

            int maxLeft1 = (partition1 == 0) ? INT_MIN : nums1[partition1 - 1];
            int minRight1 = (partition1 == m) ? INT_MAX : nums1[partition1];
            int maxLeft2 = (partition2 == 0) ? INT_MIN : nums2[partition2 - 1];
            int minRight2 = (partition2 == n) ? INT_MAX : nums2[partition2];

            if (maxLeft1 &lt;= minRight2 &amp;&amp; maxLeft2 &lt;= minRight1) {
                if ((m + n) % 2 == 0) {
                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0;
                } else {
                    return max(maxLeft1, maxLeft2);
                }
            } else if (maxLeft1 &gt; minRight2) {
                right = partition1 - 1;
            } else {
                left = partition1 + 1;
            }
        }
        // Error condition for invalid input
        throw invalid_argument(&quot;Input arrays are not sorted or empty&quot;);
    }
};
</code></pre></details></td></tr>
<tr><td>41</td><td><a href="https://leetcode.com/problems/first-missing-positive/description/" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Hard</td><td>53.0</td><td>41.58</td><td>O(n)</td><td>O(1)</td><td>11</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        for(int i=0;i&lt;nums.size();i++){
            while(nums[i]&gt;0&amp;&amp;nums[i]&lt;=nums.size()&amp;&amp;nums[i]!=nums[nums[i]-1]){
                swap(nums[i],nums[nums[i]-1]);
            }
        }
        for(int i=0;i&lt;nums.size();i++){
            if(nums[i]!=i+1)
                return i+1;
        }
        return nums.size()+1;
    }
};</code></pre></details></td><td>3</td><td>55.14</td><td>O(n)</td><td>O(1)</td><td>16</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        for (int i = 0; i &lt; n; i++) {
            // Place nums[i] at its correct position if possible
            while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - 1]) {
                swap(nums[i], nums[nums[i] - 1]);
            }
        }
        
        // Identify the first position where the index+1 is not equal to the value
        for (int i = 0; i &lt; n; i++) {
            if (nums[i] != i + 1)
                return i + 1;
        }
        
        // If all positions are correct, the answer is n+1
        return n + 1;
    }
};
</code></pre></details></td></tr>
<tr><td>42</td><td><a href="https://leetcode.com/problems/trapping-rain-water/description/" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Hard</td><td>9.0</td><td>20.03</td><td>O(n)</td><td>O(1)</td><td>15</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int left=0, right=height.size()-1, trapped=0, leftmax=height[left], rightmax=height[right];
        
        while(left&lt;right){
            if(height[left]&lt;=height[right]){                
                trapped+=leftmax-height[left++];
                leftmax=max(height[left],leftmax);
            }else{                
                trapped+=rightmax-height[right--];
                rightmax=max(height[right],rightmax);
            }            
        }
        return trapped;
    }
};</code></pre></details></td><td>0</td><td>26.05</td><td>O(n)</td><td>O(1)</td><td>23</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int left = 0, right = height.size() - 1;
        int leftmax = 0, rightmax = 0;
        int trapped = 0;

        while (left &lt; right) {
            if (height[left] &lt; height[right]) {
                if (height[left] &gt;= leftmax) {
                    leftmax = height[left];
                } else {
                    trapped += leftmax - height[left];
                }
                left++;
            } else {
                if (height[right] &gt;= rightmax) {
                    rightmax = height[right];
                } else {
                    trapped += rightmax - height[right];
                }
                right--;
            }
        }
        return trapped;
    }
};
</code></pre></details></td></tr>
<tr><td>42</td><td><a href="https://leetcode.com/problems/trapping-rain-water/description/" target="_blank" rel="noopener">Link</a></td><td>Stack</td><td>Hard</td><td>9.0</td><td>20</td><td>O(n)</td><td>O(1)</td><td>15</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int left=0, right=height.size()-1, trapped=0, leftmax=height[left], rightmax=height[right];
        
        while(left&lt;right){
            if(height[left]&lt;=height[right]){                
                trapped+=leftmax-height[left++];
                leftmax=max(height[left],leftmax);
            }else{                
                trapped+=rightmax-height[right--];
                rightmax=max(height[right],rightmax);
            }            
        }
        return trapped;
    }
};</code></pre></details></td><td>0</td><td>25.97</td><td>O(n)</td><td>O(1)</td><td>27</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int n = height.size();
        if (n &lt; 3) return 0;
        int left = 0, right = n - 1;
        int leftMax = height[left], rightMax = height[right];
        int water = 0;

        while (left &lt; right) {
            if (leftMax &lt;= rightMax) {
                ++left;
                leftMax = max(leftMax, height[left]);
                water += max(0, leftMax - height[left]);
            } else {
                --right;
                rightMax = max(rightMax, height[right]);
                water += max(0, rightMax - height[right]);
            }
        }
        return water;
    }
};
</code></pre></details></td></tr>
<tr><td>44</td><td><a href="https://leetcode.com/problems/wildcard-matching/description/" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Hard</td><td>19.0</td><td>7.57</td><td>O(m*n)</td><td>O(m*n)</td><td>30</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool isMatch(string text, string pattern) {
        bool dp[pattern.length()+1][text.length()+1];
      memset(dp,0,sizeof(dp));
      dp[0][0]=1;
      int ind=0;
      while(ind&lt;pattern.length()&amp;&amp;pattern[ind]==&#x27;*&#x27;){dp[ind+1][0]=1;ind++;}
      for(int i=0;i&lt;pattern.length();i++){
      for(int j=0;j&lt;text.length();j++){
         // if(i+1&gt;=pattern.length()+1||j+1&gt;=text.length()+1)continue;
         if(pattern[i]==text[j])
            dp[i+1][j+1]=dp[i][j];
         else if(pattern[i]==&#x27;?&#x27;)
            dp[i+1][j+1]|=dp[i][j];
         else if(pattern[i]==&#x27;*&#x27;){
            dp[i+1][j+1]|=dp[i+1][j];
            dp[i+1][j+1]|=dp[i][j+1];
            dp[i+1][j+1]|=dp[i][j];
         }
      }
   }
   return dp[pattern.length()][text.length()];
    }
};</code></pre></details></td><td>29</td><td>14.94</td><td>O(m*n)</td><td>O(m*n)</td><td>42</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false));
        dp[0][0] = true;

        for (int j = 1; j &lt;= n; ++j) {
            if (p[j - 1] == &#x27;*&#x27;) {
                dp[0][j] = dp[0][j - 1];
            }
        }

        for (int i = 1; i &lt;= m; ++i) {
            for (int j = 1; j &lt;= n; ++j) {
                if (p[j - 1] == &#x27;*&#x27;) {
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
                } else if (p[j - 1] == &#x27;?&#x27; || s[i - 1] == p[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = false;
                }
            }
        }

        return dp[m][n];
    }
};
</code></pre></details></td></tr>
<tr><td>460</td><td><a href="https://leetcode.com/problems/lfu-cache/description/" target="_blank" rel="noopener">Link</a></td><td>Linked List</td><td>Hard</td><td>508.0</td><td>189.9</td><td>O(1)</td><td>O(N)</td><td>99</td><td><details class="code"><summary>View</summary><pre><code>struct node{
    int val=-1;
    node *prev=nullptr;
    node *next=nullptr;
};
class LFUCache {
public:
    int min,cap;
    const int head=-1,tail=100001;
    
    unordered_map&lt;int,pair&lt;int,int&gt;&gt;freq;
    unordered_map&lt;int,unordered_map&lt;int,node*&gt;&gt;dll;
    LFUCache(int capacity) {
        cap=capacity;
        min=-1;
    }

    int getmin(){
        return dll[min][tail]-&gt;prev-&gt;val;
    }
    
    void remove(int key,int freq){     

        dll[freq][key]-&gt;next-&gt;prev=dll[freq][key]-&gt;prev;
        dll[freq][key]-&gt;prev-&gt;next=dll[freq][key]-&gt;next;

        delete dll[freq][key];

        dll[freq].erase(key);
    }

    void insert(int key,int freq){      
        
        if(dll.find(freq)==dll.end()){
            dll[freq][head]=new node;
            dll[freq][tail]=new node;
            dll[freq][tail]-&gt;val=tail;
            dll[freq][head]-&gt;val=head;
            dll[freq][head]-&gt;next=dll[freq][tail];
            dll[freq][tail]-&gt;prev=dll[freq][head];
        }

        dll[freq][key]=new node;
        dll[freq][key]-&gt;val=key;

        dll[freq][key]-&gt;next=dll[freq][head]-&gt;next;
        dll[freq][head]-&gt;next-&gt;prev=dll[freq][key];        

        dll[freq][head]-&gt;next=dll[freq][key];
        dll[freq][key]-&gt;prev=dll[freq][head];

    }

    int get(int key) {
        if(freq.find(key)==freq.end())
            return -1;
        else{
            remove(key,freq[key].second);
            if(dll[freq[key].second].size()==2){
                if(min==freq[key].second)
                    min++;
            }
            insert(key,++freq[key].second);            
            return freq[key].first;
        }
    }
    
    void put(int key, int value) { 
        if(freq.find(key)!=freq.end()){            
            remove(key,freq[key].second);
            freq[key].first=value;
            if(dll[freq[key].second].size()==2){
                if(min==freq[key].second)
                    min++;
            }
            insert(key,++freq[key].second);
            return;
        } 
        if(cap==0){
            freq.erase(getmin());
            remove(getmin(),min);
        }
        else{
            cap--;
        }
        min=1;
        freq[key]={value,1};
        insert(key,1);
    }
};</code></pre></details></td><td>124</td><td>194.8</td><td>O(1)</td><td>O(N)</td><td>50</td><td><details class="code"><summary>View</summary><pre><code>
class LFUCache {
private:
    int capacity, minFreq;
    // Maps key to {value, frequency}
    std::unordered_map&lt;int, std::pair&lt;int, int&gt;&gt; keyValFreq;
    // Maps frequency to list of keys in LRU order
    std::unordered_map&lt;int, std::list&lt;int&gt;&gt; freqList;
    // Maps key to its iterator in freqList
    std::unordered_map&lt;int, std::list&lt;int&gt;::iterator&gt; keyIter;

public:
    LFUCache(int capacity) : capacity(capacity), minFreq(0) {}

    int get(int key) {
        if (keyValFreq.find(key) == keyValFreq.end())
            return -1;

        // Get current freq and value
        int freq = keyValFreq[key].second;
        int value = keyValFreq[key].first;

        // Remove key from current freq list
        freqList[freq].erase(keyIter[key]);

        // If current list empty and freq == minFreq, increase minFreq
        if (freqList[freq].empty() &amp;&amp; freq == minFreq)
            minFreq++;

        // Increase freq of key
        freq++;
        freqList[freq].push_front(key);
        keyIter[key] = freqList[freq].begin();

        // Update frequency
        keyValFreq[key].second = freq;

        return value;
    }

    void put(int key, int value) {
        if (capacity == 0)
            return;

        if (get(key) != -1) {
            // Key exists, value updated in get step via keyValFreq
            keyValFreq[key].first = value;
            return;
        }

        if (keyValFreq.size() == capacity) {
            // Evict least frequently used key, which is back of freqList[minFreq]
            int delKey = freqList[minFreq].back();
            freqList[minFreq].pop_back();
            keyValFreq.erase(delKey);
            keyIter.erase(delKey);
        }

        // Insert new key with freq 1
        keyValFreq[key] = {value, 1};
        freqList[1].push_front(key);
        keyIter[key] = freqList[1].begin();
        minFreq = 1;
    }
};
</code></pre></details></td></tr>
<tr><td>51</td><td><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Hard</td><td>14.0</td><td>15.5</td><td>O(n!)</td><td>O(n)</td><td>54</td><td><details class="code"><summary>View</summary><pre><code>vector&lt;vector&lt;string&gt;&gt;ans;
bool ispossible(int curr_row,vector&lt;int&gt; &amp;curr_ans){
    int curr_column=curr_ans.size()+1;
    int prev_column=1;
    for(auto &amp;row:curr_ans){
        if(curr_row==row)
            return false;
        if(curr_row-row==curr_column-prev_column)
            return false;
        if(row-curr_row==curr_column-prev_column)
            return false;
        prev_column++;
    }
    return true;

}
void combinations(int curr_column,int n,vector&lt;int&gt;curr_ans={},vector&lt;string&gt;strans={},string y=&quot;&quot;){
    if(curr_column==n){
        ans.emplace_back(strans);
        return;
    }
    string x=&quot;&quot;;
    for(int i=0;i&lt;n;i++)x+=&#x27;.&#x27;;
    for(int i=0;i&lt;n;i++){
        if(ispossible(i+1,curr_ans)){
            x[i]=&#x27;Q&#x27;;
            curr_ans.emplace_back(i+1);
            strans.emplace_back(x);
            combinations(curr_column+1,n,curr_ans,strans,x);         
            strans.pop_back();   
            curr_ans.pop_back();
            x[i]=&#x27;.&#x27;;
        }
    }
    return;
}
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
        ans.clear();
        combinations(0,n);
        return ans;
    }
};</code></pre></details></td><td>3</td><td>10.38</td><td>O(n!)</td><td>O(n^2)</td><td>38</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; ans;

    bool isSafe(int row, int col, vector&lt;string&gt;&amp; board, int n) {
        // Check the same column
        for (int i = 0; i &lt; row; i++)
            if (board[i][col] == &#x27;Q&#x27;) return false;

        // Check upper left diagonal
        for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--)
            if (board[i][j] == &#x27;Q&#x27;) return false;

        // Check upper right diagonal
        for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++)
            if (board[i][j] == &#x27;Q&#x27;) return false;

        return true;
    }

    void solve(int row, vector&lt;string&gt;&amp; board, int n) {
        if (row == n) {
            ans.push_back(board);
            return;
        }
        for (int col = 0; col &lt; n; col++) {
            if (isSafe(row, col, board, n)) {
                board[row][col] = &#x27;Q&#x27;;
                solve(row + 1, board, n);
                board[row][col] = &#x27;.&#x27;;
            }
        }
    }

    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
        ans.clear();
        vector&lt;string&gt; board(n, string(n, &#x27;.&#x27;));
        solve(0, board, n);
        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>68</td><td><a href="https://leetcode.com/problems/text-justification/description/" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Hard</td><td>4.0</td><td>7.45</td><td>O(m*n)</td><td>O(m*n)</td><td>38</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) {
        vector&lt;int&gt;splits;
        int cursize=0;
        for(int i=0;i&lt;words.size();i++){
            cursize+=words[i].length();
            if(cursize==maxWidth){
                cursize=0;
                splits.push_back(i);           
            }
            else if(maxWidth&lt;cursize){
                cursize=0;
                splits.push_back(i-1);
                i--;
            }
            else{
                cursize++;
            }
        }
        if(splits.empty()||splits.back()!=words.size()-1){
            splits.push_back(words.size()-1);
        }
        int prev=0;
        vector&lt;string&gt;ans;
        for(auto i:splits){            
            int spacelen=0;
            for(int j=prev;j&lt;=i;j++){
                spacelen+=words[j].length();
            }
            spacelen=maxWidth-spacelen;            
            string x=words[prev];
            int spaces=i-prev;
            int avgspace=0;
            if(spaces&gt;0)
                avgspace=spacelen/spaces;
            prev++;
            if(i==words.size()-1){avgspace=1;spacelen=0;}
            for(int j=0;j&lt;spaces;j++){
                for(int k=0;k&lt;avgspace;k++)
                    x+=&#x27; &#x27;;
                if(spacelen%spaces&gt;0&amp;&amp;spacelen%spaces&gt;j)
                    x+=&#x27; &#x27;;
                x+=words[prev++];
            }
            while(x.length()!=maxWidth)x+=&#x27; &#x27;;
            ans.emplace_back(x);
            prev=i+1;
        }
        return ans;
    }
};</code></pre></details></td><td>error</td><td>error</td><td>O(m*n)</td><td>O(m*n)</td><td>44</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) {
        vector&lt;string&gt; res;
        int n = words.size();
        int i = 0;

        while (i &lt; n) {
            int line_len = words[i].length();
            int j = i + 1;
            while (j &lt; n &amp;&amp; line_len + 1 + words[j].length() &lt;= maxWidth) {
                line_len += 1 + words[j].length();
                j++;
            }

            vector&lt;string&gt; line_words(words.begin() + i, words.begin() + j);
            int num_words = j - i;

            string line;
            if (j == n || num_words == 1) {
                // Last line or line with single word: left-justified
                line = line_words[0];
                for (int k = 1; k &lt; num_words; k++) {
                    line += &quot; &quot; + line_words[k];
                }
                line += string(maxWidth - line.length(), &#x27; &#x27;);
            } else {
                // Middle-justified line
                int total_spaces = maxWidth;
                for (const auto&amp; w : line_words) total_spaces -= w.length();

                int spaces_between_words = num_words - 1;
                int even_space = total_spaces / spaces_between_words;
                int extra_space = total_spaces % spaces_between_words;

                for (int k = 0; k &lt; spaces_between_words; k++) {
                    line += line_words[k];
                    line += string(even_space + (k &lt; extra_space ? 1 : 0), &#x27; &#x27;);
                }
                line += line_words.back();
            }

            res.push_back(line);
            i = j;
        }
        return res;
    }
};
</code></pre></details></td></tr>
<tr><td>685</td><td><a href="https://leetcode.com/problems/redundant-connection-ii/description/" target="_blank" rel="noopener">Link</a></td><td>Graph</td><td>Hard</td><td>3.0</td><td>9.43</td><td>O(n)</td><td>O(n)</td><td>96</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    class UnionFind{

        public:

        vector&lt;int&gt;parent;
        vector&lt;int&gt;size;
        int maxsize;
        
        UnionFind(int size){

            parent.resize(size);
            // this-&gt;size.resize(size);

            clear();

        }

        void clear(){

            for(int i=0;i&lt;parent.size();i++)parent[i]=i;
            // for(int i=0;i&lt;this-&gt;size.size();i++)size[i]=1;
            maxsize=int(parent.size());

        }

        void Union(int node1,int node2){
            node1=find(node1);
            // node2=find(node2);
            // if(node1==node2){
            //     return;
            // }
            // if(size[node1]&lt;size[node2]){
            //     swap(node1,node2);
            // }
            parent[node2]=node1;
            // size[node1]+=size[node2];
            // maxsize=max(maxsize,size[node1]);
            maxsize--;
        }

        int find(int node1){
            if(parent[node1]==node1)
                return node1;
            return parent[node1]=find(parent[node1]);
        }

        int noofsets(){
            int sets=0;
            for(int i=0;i&lt;parent.size();i++){
                if(parent[i]==i)
                    sets++;
            }
            return sets;
        }

    };    

    vector&lt;int&gt; findRedundantDirectedConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        UnionFind UF(edges.size()+1);
        vector&lt;int&gt;prevind(edges.size()+1,-1);
        int ind1,ind2=-1,cir=-1;bool st=0;
        for(int i=0;i&lt;edges.size();i++){  
            if(prevind[edges[i][1]]&gt;=0){
                ind1=i;
                ind2=prevind[edges[i][1]];
                continue;
            }
            prevind[edges[i][1]]=i;          
            if((UF.maxsize-(int(edges.size())-(i+1))==2)&amp;&amp;(UF.find(edges[i][1])==UF.find(edges[i][0])))
               cir=i;
            UF.Union(edges[i][0],edges[i][1]);
            
        }
        if(ind2&lt;0)return edges[cir];
        if(UF.noofsets()==2){
            return edges[ind1];
        }
        return edges[ind2];
    }
};</code></pre></details></td><td>error</td><td>error</td><td></td><td></td><td></td><td><details class="code"><summary>View</summary><pre><code>struct DSU {
    vector&lt;int&gt; p, r;
    DSU(int n) : p(n + 1), r(n + 1, 0) { iota(p.begin(), p.end(), 0); }
    int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); }
    // return false if x and y already connected (cycle)
    bool unite(int x, int y) {
        x = find(x); y = find(y);
        if (x == y) return false;
        if (r[x] &lt; r[y]) swap(x, y);
        p[y] = x;
        if (r[x] == r[y]) r[x]++;
        return true;
    }
};

class Solution {
public:
    vector&lt;int&gt; findRedundantDirectedConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        int n = edges.size();
        vector&lt;int&gt; parent(n + 1, 0);
        vector&lt;int&gt; cand1, cand2;

        // Step 1: find a node with two parents and record the two edges
        for (auto&amp; e : edges) {
            int u = e, v = e[2];
            if (parent[v] == 0) {
                parent[v] = u;
            } else {
                // v has two parents; earlier edge (cand1) and later edge (cand2)
                cand1 = {parent[v], v};
                cand2 = {u, v};
                // Mark the later edge to skip it during union-find pass
                e[2] = 0; // sentinel to skip
            }
        }

        // Step 2: union-find ignoring cand2 if existed
        DSU dsu(n);
        for (auto&amp; e : edges) {
            int u = e, v = e[2];
            if (v == 0) continue; // skip cand2
            if (!dsu.unite(u, v)) {
                // Found a cycle
                if (cand1.empty()) return {u, v};  // no two-parent case
                return cand1;                      // with two-parent case, remove earlier edge
            }
        }

        // Step 3: if no cycle when skipping cand2, then cand2 is the redundant edge
        return cand2;
    }
};
</code></pre></details></td></tr>
<tr><td>76</td><td><a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Hard</td><td>12.0</td><td>8.21</td><td>O(n)</td><td>O(1)</td><td>38</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    string minWindow(string s, string t) {
        s+=&#x27;_&#x27;;
        int left=0,right=0,ind=0,ans=1000000;
        vector&lt;int&gt;sub(59,0);
        for(char c:t){
            sub[int(c)-65]++;
        }
        for(auto &amp;i:sub){
            if(i==0)
                i=1000001;
        }
        int size=t.length();
        while(right&lt;s.length()&amp;&amp;left&lt;s.length()){            
            if(size==0&amp;&amp;sub[int(s[left])-65]&lt;1000001){  
                if(ans&gt;right-left){
                ind=left;
                ans=right-left;
                }              
                if(sub[int(s[left])-65]&gt;=0)
                    size++;
                sub[int(s[left])-65]++;               
                left++;
            }
               else if(size==0)left++;
            else if(sub[int(s[right])-65]&lt;1000001){
                if(sub[int(s[right])-65]&gt;0)
                size--;
                sub[int(s[right])-65]--;                
                right++;
            }
         
            else
                right++;
        }
        if(ans==1000000)return &quot;&quot;;
        return s.substr(ind,ans);
    }
};</code></pre></details></td><td>18</td><td>11.48</td><td>O(m+n)</td><td>O(m+n)</td><td>38</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    string minWindow(string s, string t) {
        if (s.empty() || t.empty()) return &quot;&quot;;
        
        unordered_map&lt;char, int&gt; dict_t;
        for (char c : t) dict_t[c]++;
        
        int required = dict_t.size();
        int l = 0, r = 0, formed = 0;
        unordered_map&lt;char, int&gt; window_counts;
        int ans_len = INT_MAX, ans_l = 0, ans_r = 0;
        
        while (r &lt; s.size()) {
            char c = s[r];
            window_counts[c]++;
            
            if (dict_t.count(c) &amp;&amp; window_counts[c] == dict_t[c]) {
                formed++;
            }
            
            while (l &lt;= r &amp;&amp; formed == required) {
                c = s[l];
                if (r - l + 1 &lt; ans_len) {
                    ans_len = r - l + 1;
                    ans_l = l;
                    ans_r = r;
                }
                
                window_counts[c]--;
                if (dict_t.count(c) &amp;&amp; window_counts[c] &lt; dict_t[c]) {
                    formed--;
                }
                l++;
            }
            r++;
        }
        
        return ans_len == INT_MAX ? &quot;&quot; : s.substr(ans_l, ans_len);
    }
};
</code></pre></details></td></tr>
<tr><td>834</td><td><a href="https://leetcode.com/problems/sum-of-distances-in-tree/description/" target="_blank" rel="noopener">Link</a></td><td>Graph</td><td>Hard</td><td>185.0</td><td>97</td><td>O(n)</td><td>O(n)</td><td>60</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    void helperDfs1(int cur, int par, vector&lt;vector&lt;int&gt;&gt;&amp; children, vector&lt;int&gt; &amp; sumAt, vector&lt;int&gt;&amp; weightAt, vector&lt;int&gt; &amp; ans){
        int weight = 0;
        for(int i = 0; i&lt;children[cur].size(); i++){
            if(children[cur][i] != par){
                helperDfs1(children[cur][i], cur, children, sumAt, weightAt, ans);
                weightAt[cur] += weightAt[children[cur][i]];
                sumAt[cur] += sumAt[children[cur][i]] + weightAt[children[cur][i]];
            }
        }
        weightAt[cur]++;
        return;
    }

    void helperDfs2(int cur, int par, int curSum, int curWeight, vector&lt;vector&lt;int&gt;&gt;&amp; children, vector&lt;int&gt; &amp; sumAt, vector&lt;int&gt;&amp; weightAt, vector&lt;int&gt; &amp; ans){
        for(int i = 0; i&lt;children[cur].size(); i++){
            if(children[cur][i] != par){
                curSum += sumAt[children[cur][i]];   
                curWeight += weightAt[children[cur][i]];
            }
        }
        ans[cur] = curSum + curWeight;
        for(int i = 0; i&lt;children[cur].size(); i++){
            if(children[cur][i] != par){
                curSum -= sumAt[children[cur][i]];   
                curWeight -= weightAt[children[cur][i]];
                curSum += curWeight;
                curWeight++;
                
                helperDfs2(children[cur][i], cur, curSum, curWeight, children, sumAt, weightAt, ans);
                
                curWeight--;
                curSum -= curWeight;
                curSum += sumAt[children[cur][i]];   
                curWeight += weightAt[children[cur][i]];
            }
        }
    }

    vector&lt;int&gt; sumOfDistancesInTree(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        vector&lt;vector&lt;int&gt;&gt; children(n);
        for(int i = 0; i&lt;n-1; i++){
            children[edges[i][0]].push_back(edges[i][1]);
            children[edges[i][1]].push_back(edges[i][0]);
        }
        vector&lt;int&gt; ans(n, 0), weightAt(n, 0), sumAt(n, 0);
        helperDfs1(0, -1, children, sumAt, weightAt, ans);
        helperDfs2(0, -1, 0, 0, children, sumAt, weightAt, ans);
        return ans;
    }
};</code></pre></details></td><td>error</td><td>error</td><td></td><td></td><td>43</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; sumOfDistancesInTree(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        vector&lt;vector&lt;int&gt;&gt; g(n);
        g.reserve(n);
        for (const auto&amp; e : edges) {
            int u = e, v = e[4];
            g[u].push_back(v);
            g[v].push_back(u);
        }

        vector&lt;int&gt; sz(n, 1);      // subtree sizes
        vector&lt;int&gt; down(n, 0);    // sum of distances from node to nodes in its subtree
        vector&lt;int&gt; ans(n, 0);     // final answers

        // Post-order: compute sz and down from an arbitrary root (0)
        function&lt;void(int,int)&gt; dfs1 = [&amp;](int u, int p) {
            for (int v : g[u]) if (v != p) {
                dfs1(v, u);
                sz[u] += sz[v];
                down[u] += down[v] + sz[v];
            }
        };

        // Pre-order (rerooting): compute ans for all nodes using parents answer
        function&lt;void(int,int)&gt; dfs2 = [&amp;](int u, int p) {
            // ans[u] is already set before calling dfs2(u,p)
            for (int v : g[u]) if (v != p) {
                // When reroot from u to v:
                // nodes in v&#x27;s subtree get 1 closer: contribute -sz[v]
                // nodes outside v&#x27;s subtree get 1 farther: contribute +(n - sz[v])
                ans[v] = ans[u] - sz[v] + (n - sz[v]);
                dfs2(v, u);
            }
        };

        dfs1(0, -1);
        ans = down;
        dfs2(0, -1);

        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>84</td><td><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/" target="_blank" rel="noopener">Link</a></td><td>Stack</td><td>Hard</td><td>149.0</td><td>85.24</td><td>O(n)</td><td>O(n)</td><td>42</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
        vector&lt;int&gt; prevSmaller(heights.size());
        vector&lt;int&gt; nextSmaller(heights.size());
        stack&lt;int&gt; buffer;

        //next smaller element
        for(int i=0;i&lt;nextSmaller.size();i++){
            while(!buffer.empty()&amp;&amp;heights[buffer.top()]&gt;heights[i]){
                nextSmaller[buffer.top()]=i;
                buffer.pop();
            }
            buffer.push(i);
        }

        while(!buffer.empty()){
            nextSmaller[buffer.top()]=nextSmaller.size();
            buffer.pop();
        }

        //previous smaller element
        for(int i=prevSmaller.size()-1;i&gt;=0;i--){
            while(!buffer.empty()&amp;&amp;heights[buffer.top()]&gt;heights[i]){
                prevSmaller[buffer.top()]=i;
                buffer.pop();
            }
            buffer.push(i);
        }

        while(!buffer.empty()){
            prevSmaller[buffer.top()]=-1;
            buffer.pop();
        }

        int maxArea=0;

        for(int i=0;i&lt;heights.size();i++){
            int height=heights[i];
            int breadth=((nextSmaller[i]-1)-(prevSmaller[i]+1)+1);
            maxArea=max(maxArea,height*breadth);
        }
        return maxArea;
    }
};</code></pre></details></td><td>18</td><td>81.45</td><td>O(n)</td><td>O(n)</td><td>27</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
        int n = heights.size();
        stack&lt;int&gt; st;              // increasing stack of indices [web:53][web:55]
        int maxArea = 0;

        for (int i = 0; i &lt;= n; ++i) {
            int curH = (i == n ? 0 : heights[i]); // sentinel 0 at end to flush stack [web:73][web:53]
            while (!st.empty() &amp;&amp; curH &lt; heights[st.top()]) {
                int h = heights[st.top()];
                st.pop();
                int leftIdx = st.empty() ? -1 : st.top(); // previous smaller index [web:53][web:55]
                int width = i - leftIdx - 1;              // right bound is i-1 [web:53][web:55]
                maxArea = max(maxArea, h * width);        // area with height h [web:53][web:55]
            }
            st.push(i);
        }
        return maxArea; // largest rectangle area [web:53][web:65]
    }
};
</code></pre></details></td></tr>
<tr><td>85</td><td><a href="https://leetcode.com/problems/maximal-rectangle/description/" target="_blank" rel="noopener">Link</a></td><td>Stack</td><td>Hard</td><td>46.0</td><td>13.34</td><td>0(n^2)</td><td>0(n^2)</td><td>57</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        int ans=0;
        int dp[matrix.size()][matrix[0].size()];
        for(int i=0;i&lt;matrix.size();i++){
            for(int j=0;j&lt;matrix[0].size();j++){
                if(matrix[i][j]-&#x27;0&#x27;){
                    if(i==0){
                        dp[i][j]=matrix[i][j]-&#x27;0&#x27;;
                    }
                    else{
                        dp[i][j]=dp[i-1][j]+(matrix[i][j]-&#x27;0&#x27;);
                    } 
                }  
                else
                    dp[i][j]=0;             
                ans=max(ans,dp[i][j]);
            }
        }
        for(int i=0;i&lt;matrix.size();i++){
            int nextlow[matrix[0].size()];
            int prevlow[matrix[0].size()];
            stack&lt;int&gt;st;
            for(int j=0;j&lt;matrix[0].size();j++){
                while(!st.empty()&amp;&amp;dp[i][st.top()]&gt;dp[i][j]){
                    nextlow[st.top()]=j;
                    st.pop();
                }
                st.push(j);
            }
            while(!st.empty()){
                nextlow[st.top()]=matrix[0].size();
                st.pop();
            }
            for(int j=matrix[0].size()-1;j&gt;=0;j--){
                while(!st.empty()&amp;&amp;dp[i][st.top()]&gt;dp[i][j]){
                    prevlow[st.top()]=j;
                    st.pop();
                }
                st.push(j);
            }
            while(!st.empty()){
                prevlow[st.top()]=-1;
                st.pop();
            }
            for(int j=0;j&lt;matrix[0].size();j++){
                ans=max(ans,dp[i][j]*(nextlow[j]-(prevlow[j])-1));
            }
        }
        return ans;
    }
};</code></pre></details></td><td>13</td><td>17.82</td><td>O(n^2)</td><td>O(n)</td><td>37</td><td><details class="code"><summary>View</summary><pre><code>
class Solution {
    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
        int n = heights.size();
        stack&lt;int&gt; st;                  // increasing stack of indices [web:53][web:55]
        int maxArea = 0;
        for (int i = 0; i &lt;= n; ++i) {
            int cur = (i == n ? 0 : heights[i]); // sentinel to flush stack [web:53][web:55]
            while (!st.empty() &amp;&amp; cur &lt; heights[st.top()]) {
                int h = heights[st.top()];
                st.pop();
                int left = st.empty() ? -1 : st.top(); // previous smaller index [web:53][web:55]
                int width = i - left - 1;              // next smaller at i [web:53][web:55]
                maxArea = max(maxArea, h * width);     // compute area [web:53][web:55]
            }
            st.push(i);
        }
        return maxArea; // largest rectangle in histogram [web:53][web:65]
    }
public:
    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if (matrix.empty() || matrix[0].empty()) return 0; // guard [web:88]
        int m = matrix.size(), n = matrix[0].size();
        vector&lt;int&gt; heights(n, 0); // running heights of consecutive &#x27;1&#x27;s [web:81][web:82]
        int ans = 0;
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                heights[j] = (matrix[i][j] == &#x27;1&#x27;) ? heights[j] + 1 : 0; // build histogram [web:81][web:82]
            }
            ans = max(ans, largestRectangleArea(heights)); // per row histogram [web:81][web:82]
        }
        return ans; // maximal rectangle area [web:88][web:81]
    }
};
</code></pre></details></td></tr>
<tr><td>862</td><td><a href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/" target="_blank" rel="noopener">Link</a></td><td>Queue</td><td>Hard</td><td>178.0</td><td>105</td><td>O(n)</td><td>O(n)</td><td>27</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int shortestSubarray(vector&lt;int&gt;&amp; nums, int k) {
        deque&lt;int&gt;possibleLeftIndices;
        vector&lt;long long&gt;prefixSum(nums.size()+1,0);
        long long temp=0;
        for(int i=0;i&lt;nums.size();i++){            
            temp+=nums[i];
            prefixSum[i+1]=temp;
        }
        int ans=1e9;
        for(int i=0;i&lt;=nums.size();i++){
            if(i&lt;nums.size()&amp;&amp;nums[i]&gt;=k)return 1;            
            if(!possibleLeftIndices.empty()){
                while(!possibleLeftIndices.empty()&amp;&amp;prefixSum[i]&lt;=prefixSum[possibleLeftIndices.back()])
                    possibleLeftIndices.pop_back();
                while(!possibleLeftIndices.empty()&amp;&amp;prefixSum[i]-prefixSum[possibleLeftIndices.front()]&gt;=k){
                    ans=min(ans,i-possibleLeftIndices.front());
                    possibleLeftIndices.pop_front();
                }
            }
            possibleLeftIndices.push_back(i);
        }
        return ans&gt;nums.size()?-1:ans;
    }
};</code></pre></details></td><td>15</td><td>109</td><td>O(n)</td><td>O(n)</td><td>26</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int shortestSubarray(vector&lt;int&gt;&amp; nums, int k) {
        int n = nums.size();
        vector&lt;long long&gt; prefix(n + 1, 0);
        for (int i = 0; i &lt; n; ++i) prefix[i + 1] = prefix[i] + nums[i]; // build prefix sums [web:229]

        deque&lt;int&gt; dq; // indices with increasing prefix values [web:229]
        int ans = n + 1;

        for (int i = 0; i &lt;= n; ++i) {
            // try to shrink from left while current prefix - oldest prefix &gt;= k
            while (!dq.empty() &amp;&amp; prefix[i] - prefix[dq.front()] &gt;= k) {
                ans = min(ans, i - dq.front());
                dq.pop_front();
            }
            // maintain increasing prefix: drop larger/equal tails
            while (!dq.empty() &amp;&amp; prefix[i] &lt;= prefix[dq.back()]) dq.pop_back();
            dq.push_back(i);
        }
        return ans &lt;= n ? ans : -1;
    }
};
</code></pre></details></td></tr>
<tr><td>87</td><td><a href="https://leetcode.com/problems/scramble-string/description/" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Hard</td><td>25.0</td><td>6.13</td><td>O(n^4)</td><td>O(n^3)</td><td>29</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool isScramble(string s1, string s2) {
        int n=s1.length();
        bool dp[n+1][n][n];
        for(int i=1;i&lt;=n;i++){
            for(int j=0;j&lt;n;j++){
                for(int k=0;k&lt;n;k++){
                    dp[i][j][k]=0;
                    if(i==1){
                        if(s1[j]==s2[k]){
                            dp[i][j][k]=1;
                        }
                    }
                    else if(i+j-1&lt;n&amp;&amp;i+k-1&lt;n){
                        for(int m=1;m&lt;i;m++){
                            dp[i][j][k]|=dp[m][j][k]&amp;&amp;dp[i-m][j+m][k+m];
                            dp[i][j][k]|=dp[m][j][k+i-m]&amp;&amp;dp[i-m][j+m][k];
                            // dp[i][j][k]|=dp[m][j+i-m][k]&amp;&amp;dp[i-m][j][k+m];
                        }
                    }
                }
            }
        }
        return dp[n][0][0];
    }
};</code></pre></details></td><td>Time Limit Exceeded</td><td>Time Limit Exceeded</td><td>O(2^(n)^2)</td><td>O(n)</td><td>32</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool isScramble(string s1, string s2) {
        if (s1.length() != s2.length()) return false;
        if (s1 == s2) return true;
        string t1 = s1, t2 = s2;
        sort(t1.begin(), t1.end());
        sort(t2.begin(), t2.end());
        if (t1 != t2) return false;

        int n = s1.length();
        for (int i = 1; i &lt; n; i++) {
            // Case 1: No swap
            if (isScramble(s1.substr(0, i), s2.substr(0, i)) &amp;&amp;
                isScramble(s1.substr(i), s2.substr(i))) {
                return true;
            }
            // Case 2: Swap
            if (isScramble(s1.substr(0, i), s2.substr(n - i)) &amp;&amp;
                isScramble(s1.substr(i), s2.substr(0, n - i))) {
                return true;
            }
        }
        return false;
    }
};
</code></pre></details></td></tr>
<tr><td>895</td><td><a href="https://leetcode.com/problems/maximum-frequency-stack/description/" target="_blank" rel="noopener">Link</a></td><td>Stack</td><td>Hard</td><td>196.0</td><td>124.22</td><td>0(1)</td><td>O(n)</td><td>44</td><td><details class="code"><summary>View</summary><pre><code>
class FreqStack {
public:
    int maxFrequency;            //current maximum frequency
    vector&lt;stack&lt;int&gt;&gt;order;     //order[i] -&gt; store relative ordering of insertion(lifo) for i(th) occurrence of element 
    map&lt;int,int&gt;frequency;       //store frequency count of elements
                                   
    FreqStack() {
        maxFrequency=0;
        order = vector&lt;stack&lt;int&gt;&gt;(1);
    }
    
    void push(int val) {
        int curFrequency = frequency[val]++;
        maxFrequency = max(maxFrequency, curFrequency); 
        if(curFrequency+1&gt;order.size()){
            stack&lt;int&gt;temp;
            order.push_back(temp);
        }
        order[curFrequency].push(val);       
    }

    
    int pop() {
        int popped = order[maxFrequency].top();
        order[maxFrequency].pop();
        frequency[popped]--;
        if(order[maxFrequency].empty())
            maxFrequency--;
        return popped;
    }
};

/**
 * Your FreqStack object will be instantiated and called as such:
 * FreqStack* obj = new FreqStack();
 * obj-&gt;push(val);
 * int param_2 = obj-&gt;pop();
 */</code></pre></details></td><td>72</td><td>100</td><td>0(1)</td><td>O(n)</td><td>29</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

class FreqStack {
    unordered_map&lt;int,int&gt; freq;           // val -&gt; frequency [web:190][web:187]
    unordered_map&lt;int, vector&lt;int&gt;&gt; group; // f -&gt; stack of vals (use vector as stack) [web:197][web:190]
    int maxFreq = 0;                       // current maximum frequency [web:197][web:186]
public:
    FreqStack() {}

    void push(int val) {
        int f = ++freq[val];               // increment frequency [web:190][web:197]
        if (f &gt; maxFreq) maxFreq = f;      // update max frequency [web:197][web:186]
        group[f].push_back(val);           // push into group for this frequency [web:197][web:190]
    }

    int pop() {
        auto&amp; stk = group[maxFreq];        // get stack at max frequency [web:197][web:186]
        int val = stk.back();              // most recent among most frequent [web:197][web:186]
        stk.pop_back();
        if (stk.empty()) {                 // if no more at this freq, drop maxFreq [web:197][web:190]
            group.erase(maxFreq);
            --maxFreq;
        }
        --freq[val];                       // decrement value frequency [web:197][web:190]
        if (freq[val] == 0) freq.erase(val);
        return val;                        // return popped value [web:187]
    }
};
</code></pre></details></td></tr>
<tr><td>943</td><td><a href="https://leetcode.com/problems/find-the-shortest-superstring/description/" target="_blank" rel="noopener">Link</a></td><td>Bit Manipulation</td><td>Hard</td><td>22.0</td><td>8.23</td><td>O(2^n)</td><td>O(2^n)</td><td>79</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    string shortestSuperstring(vector&lt;string&gt;&amp; words) {
        int n=words.size();
        int dp[(1&lt;&lt;n)][n];
        int arr[n][n];
        for(int i=0;i&lt;n;i++){
            for(int j=0;j&lt;n;j++){
                arr[i][j]=0;
                for(int k=0;k&lt;words[j].length();k++){
                    int m=k;
                    int l=words[i].length()-1;
                    while(m&gt;=0&amp;&amp;l&gt;=0&amp;&amp;words[j][m]==words[i][l]){
                        l--;m--;
                    }
                    if(m==-1)
                        arr[i][j]=max(arr[i][j],k-m);
                }
            }
        }
        string ans;
        for(int i=0;i&lt;(1&lt;&lt;n);i++){
            for(int j=0;j&lt;n;j++){
                dp[i][j]=0;
                int temp=i;
                if(i&gt;&gt;j&amp;1){
                    temp-=1&lt;&lt;j;
                    dp[i][j]=0;
                    for(int k=0;k&lt;n;k++){
                        if(temp&gt;&gt;k&amp;1)
                        dp[i][j]=max(dp[i][j],dp[temp][k]+arr[k][j]);
                    }
                }
            }
        }
        int temp=(1&lt;&lt;n)-1,prev,prevval;
        for(int i=0;i&lt;n;i++){
            int ind=0,cur=-1111111;
            for(int j=0;j&lt;n;j++){         
                if(temp==(1&lt;&lt;n)-1&amp;&amp;(temp&gt;&gt;j&amp;1)&amp;&amp;dp[temp][j]&gt;=cur){
                    cur=dp[temp][j];
                    ind=j;
                }       
                else if((temp&gt;&gt;j&amp;1)&amp;&amp;dp[temp][j]&gt;=cur&amp;&amp;prevval-arr[j][prev]==dp[temp][j]){
                    cur=dp[temp][j];
                    ind=j;
                }
            }
            if(temp==(1&lt;&lt;n)-1)
                ans=words[ind];
            else{
                string x=&quot;&quot;;
                for(int j=0;j&lt;words[ind].length()-arr[ind][prev];j++){
                    x+=words[ind][j];
                }
                ans=x+ans;
            }
            temp-=(1&lt;&lt;ind);
            prev=ind;
            prevval=cur;
            // cout&lt;&lt;endl;
        }
        
        return ans;
        
    }
};</code></pre></details></td><td>51</td><td>24.1</td><td>O(2^n)</td><td>O(2^n)</td><td>79</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    string shortestSuperstring(vector&lt;string&gt;&amp; words) {
        int n = words.size();

        // Compute overlap: overlap[i][j] = max L such that suffix of words[i] of length L equals prefix of words[j]
        vector&lt;vector&lt;int&gt;&gt; overlap(n, vector&lt;int&gt;(n, 0));
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; n; ++j) if (i != j) {
                int L = min(words[i].size(), words[j].size());
                for (int k = L; k &gt;= 1; --k) {
                    if (words[i].substr(words[i].size() - k) == words[j].substr(0, k)) {
                        overlap[i][j] = k;
                        break;
                    }
                }
            }
        }

        int Nmask = 1 &lt;&lt; n;
        vector&lt;vector&lt;int&gt;&gt; dp(Nmask, vector&lt;int&gt;(n, -1));
        vector&lt;vector&lt;int&gt;&gt; parent(Nmask, vector&lt;int&gt;(n, -1));

        // Initialize singletons
        for (int i = 0; i &lt; n; ++i) dp[1 &lt;&lt; i][i] = 0;

        // DP over masks
        for (int mask = 1; mask &lt; Nmask; ++mask) {
            for (int last = 0; last &lt; n; ++last) {
                if (dp[mask][last] &lt; 0) continue;
                for (int nxt = 0; nxt &lt; n; ++nxt) {
                    if (mask &amp; (1 &lt;&lt; nxt)) continue;
                    int nmask = mask | (1 &lt;&lt; nxt);
                    int cand = dp[mask][last] + overlap[last][nxt];
                    if (cand &gt; dp[nmask][nxt]) {
                        dp[nmask][nxt] = cand;
                        parent[nmask][nxt] = last;
                    }
                }
            }
        }

        // Find best end
        int full = Nmask - 1, last = 0, best = -1;
        for (int i = 0; i &lt; n; ++i) {
            if (dp[full][i] &gt; best) {
                best = dp[full][i];
                last = i;
            }
        }

        // Reconstruct order
        vector&lt;int&gt; order;
        int mask = full;
        while (last != -1) {
            order.push_back(last);
            int prev = parent[mask][last];
            mask ^= 1 &lt;&lt; last;
            last = prev;
        }
        reverse(order.begin(), order.end());

        // Append any missing strings (shouldn&#x27;t happen if DP fills properly)
        vector&lt;bool&gt; used(n, false);
        for (int x : order) used[x] = true;
        for (int i = 0; i &lt; n; ++i) if (!used[i]) order.push_back(i);

        // Build result using overlaps
        string res = words[order[0]];
        for (int t = 1; t &lt; (int)order.size(); ++t) {
            int i = order[t - 1], j = order[t];
            int k = overlap[i][j];
            res += words[j].substr(k);
        }
        return res;
    }
};
</code></pre></details></td></tr>
<tr><td>105</td><td><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" target="_blank" rel="noopener">Link</a></td><td>Trees</td><td>Medium</td><td>4.0</td><td>29.82</td><td>O(n)</td><td>O(n)</td><td>42</td><td><details class="code"><summary>View</summary><pre><code>TreeNode * createSubtree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder, int&amp; ind, map&lt;int, int&gt;&amp; postindexOf, map&lt;int, int&gt;&amp; preindexOf){
  if(ind &gt;= preorder.size()) return nullptr;
  int curElement = preorder[ind];
  TreeNode* node = new TreeNode(preorder[ind++]);
  if(ind&lt;preorder.size() &amp;&amp; postindexOf[preorder[ind]]&lt;postindexOf[curElement]){
    node-&gt;left = createSubtree(preorder, postorder, ind, postindexOf, preindexOf);
  }
  if(ind&lt;preorder.size() &amp;&amp; postindexOf[preorder[ind]]&lt;postindexOf[curElement]){
    node-&gt;right = createSubtree(preorder, postorder, ind, postindexOf, preindexOf);
  }
  return node;
}

void dfs(TreeNode* temp){
  if(!temp)return;
  cout&lt;&lt;temp-&gt;val&lt;&lt;&quot; &quot;;
  dfs(temp-&gt;left);
  dfs(temp-&gt;right);
  return;
}

class Solution {
public:
    TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder) {
      map&lt;int, int&gt; postindexOf, preindexOf;
      for(int i = 0; i&lt;postorder.size(); i++){
        postindexOf[postorder[i]] = i;
        preindexOf[preorder[i]] = i;
      }
      int ind = 0;
      TreeNode* root = createSubtree(preorder, postorder, ind, postindexOf, preindexOf);
      // dfs(root);
      return root;
    }
};</code></pre></details></td><td>0</td><td>28.73</td><td>O(n)</td><td>O(n)</td><td>35</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder) {
        unordered_map&lt;int, int&gt; postIndex;
        for (int i = 0; i &lt; postorder.size(); i++) {
            postIndex[postorder[i]] = i;
        }
        int preIndex = 0;
        return build(preorder, postorder, postIndex, preIndex, 0, postorder.size() - 1);
    }

private:
    TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder, unordered_map&lt;int,int&gt;&amp; postIndex,
                    int&amp; preIndex, int left, int right) {
        if (preIndex &gt;= preorder.size() || left &gt; right) return nullptr;
        TreeNode* root = new TreeNode(preorder[preIndex++]);
        if (left == right) return root;

        int postPos = postIndex[preorder[preIndex]];
        if (postPos &lt;= right) {
            root-&gt;left = build(preorder, postorder, postIndex, preIndex, left, postPos);
            root-&gt;right = build(preorder, postorder, postIndex, preIndex, postPos + 1, right - 1);
        }

        return root;
    }
};
</code></pre></details></td></tr>
<tr><td>11</td><td><a href="https://leetcode.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Medium</td><td>4.0</td><td>63.1</td><td>O(n)</td><td>O(1)</td><td>17</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
        int left = 0, right = height.size()-1;
        int ans = 0;
        while(left&lt;right){
            ans = max(ans, min(height[left], height[right]) * (right - left));
            if(height[left]&lt;height[right]){
                left++;
            }
            else
                right--;
        }
        return ans;
    }
};</code></pre></details></td><td>0</td><td>63.05</td><td>O(n)</td><td>O(1)</td><td>18</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
        int left = 0, right = height.size() - 1;
        int max_area = 0;
        
        while (left &lt; right) {
            int h = min(height[left], height[right]);
            int w = right - left;
            max_area = max(max_area, h * w);
            
            if (height[left] &lt; height[right]) 
                left++;
            else 
                right--;
        }
        
        return max_area;
    }
};
</code></pre></details></td></tr>
<tr><td>122</td><td><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Medium</td><td>9.0</td><td>12.99</td><td>O(n)</td><td>O(1)</td><td>12</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int  mini=prices[0];int ans=0;
        for(int i=1;i&lt;prices.size();i++){
            if(mini&lt;prices[i]){
                ans=max(ans,prices[i]-mini);
            }
            mini=min(mini,prices[i]-ans);
        }
        return ans;
    }
};</code></pre></details></td><td>0</td><td>17.17</td><td>O(n)</td><td>O(1)</td><td>16</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int profit = 0;
        for (int i = 1; i &lt; (int)prices.size(); ++i) {
            if (prices[i] &gt; prices[i - 1]) profit += prices[i] - prices[i - 1];
        }
        return profit;
    }
};
</code></pre></details></td></tr>
<tr><td>137</td><td><a href="https://leetcode.com/problems/single-number-ii/description/" target="_blank" rel="noopener">Link</a></td><td>Bit Manipulation</td><td>Medium</td><td>0.0</td><td>9.43</td><td>O(n)</td><td>O(1)</td><td>18</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        int arr[32]={};
        for(int i=0;i&lt;nums.size();i++){
            for(int j=0;j&lt;32;j++){
                arr[j]+=(nums[i]&gt;&gt;j)&amp;1;
            }
        }
        int ans=0;
        for(int i=0;i&lt;32;i++){  
            if(arr[i]%3)ans|=1&lt;&lt;i;
        }
        return ans;
    }
};</code></pre></details></td><td>0</td><td>13.36</td><td>O(n)</td><td>O(1)</td><td>20</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        int ans = 0;
        for (int b = 0; b &lt; 32; ++b) {
            int cnt = 0;
            for (int x : nums) cnt += (x &gt;&gt; b) &amp; 1;
            if (cnt % 3) ans |= (1 &lt;&lt; b);
        }
        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>139</td><td><a href="https://leetcode.com/problems/word-break/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Medium</td><td>8.0</td><td>9.84</td><td>0(n^2)</td><td>O(n)</td><td>50</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    struct Trie{
        unordered_map&lt;char,Trie*&gt;child;
        bool exists=0;
    };

    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {
        Trie * head=new Trie;
        for(string str:wordDict){
            Trie*cur=head;
            for(char c:str){
                if(cur-&gt;child.find(c)!=cur-&gt;child.end()){
                    cur=cur-&gt;child[c];
                }  
                else{
                    cur-&gt;child[c]=new Trie;
                    cur=cur-&gt;child[c];
                }                 
            }
            cur-&gt;exists=1;
        }
        vector&lt;bool&gt;dp(s.length()+1,0);
        dp[0]=1;
        for(int i=0;i&lt;s.length();i++){
            Trie *cur = head;
            for(int j=i;j&lt;s.length();j++){
                if(cur-&gt;child.find(s[j])!=cur-&gt;child.end()){
                    cur=cur-&gt;child[s[j]];
                    if(cur-&gt;exists)
                        dp[j+1]=dp[j+1]|dp[i];
                }
                else{
                    break;
                }
            }
        }
        return dp[s.length()];
    }
};</code></pre></details></td><td>13</td><td>16.19</td><td>0(n^2)</td><td>O(n)</td><td>26</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {
        unordered_set&lt;string&gt; dict(wordDict.begin(), wordDict.end());
        int n = s.size();
        vector&lt;int&gt; dp(n + 1, 0);
        dp[0] = 1; // empty prefix is valid

        for (int i = 1; i &lt;= n; ++i) {
            for (int j = 0; j &lt; i; ++j) {
                if (dp[j] &amp;&amp; dict.count(s.substr(j, i - j))) {
                    dp[i] = 1;
                    break;
                }
            }
        }
        return dp[n];
    }
};
</code></pre></details></td></tr>
<tr><td>1441</td><td><a href="https://leetcode.com/problems/build-an-array-with-stack-operations/description/" target="_blank" rel="noopener">Link</a></td><td>Stack</td><td>Medium</td><td>5.0</td><td>8.28</td><td>0(1)</td><td>O(n)</td><td>29</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) {
        int curNum = 0;
        vector&lt;string&gt; ans;
        for(int i = 0; i&lt;target.size(); i++){
            while(++curNum != target[i]){
                ans.push_back(&quot;Push&quot;);
                ans.push_back(&quot;Pop&quot;);
            }
            ans.push_back(&quot;Push&quot;);
        }
        return ans;
    }
};</code></pre></details></td><td>Error</td><td>error</td><td>0(1)</td><td>O(n)</td><td>21</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) {
        vector&lt;string&gt; ops;
        int cur = 1;
        for (int x : target) {
            while (cur &lt; x) {          // numbers to skip
                ops.push_back(&quot;Push&quot;);
                ops.push_back(&quot;Pop&quot;);
                ++cur;
            }
            ops.push_back(&quot;Push&quot;);     // keep x
            ++cur;
        }
        return ops;
    }
};
</code></pre></details></td></tr>
<tr><td>146</td><td><a href="https://leetcode.com/problems/lru-cache/description/" target="_blank" rel="noopener">Link</a></td><td>Linked List</td><td>Medium</td><td>332.0</td><td>164.7</td><td>O(1)</td><td>
O(N)</td><td>56</td><td><details class="code"><summary>View</summary><pre><code>struct node{
    int val=-1,ind=-1;
    node * prev = nullptr;
    node * next = nullptr;
};

class LRUCache {
    node * * arr=new node *[1e4+1];
    node * head=nullptr;
    node * tail =nullptr;    
    int capacity;    
    int size=0;
    public:
    LRUCache(int capacity) {
        this-&gt;capacity=capacity;
        for(int i=0;i&lt;1e4+1;i++)arr[i]=NULL;
        head=new node;
        tail=new node;
        head-&gt;next=tail;
        tail-&gt;prev=head;
    }
    
    void remove(node * ptr){
        ptr-&gt;next-&gt;prev=ptr-&gt;prev;
        ptr-&gt;prev-&gt;next=ptr-&gt;next;
    }

    void update(node * ptr){
        head-&gt;next-&gt;prev=ptr;
        ptr-&gt;next=head-&gt;next;
        ptr-&gt;prev=head;
        head-&gt;next=ptr;
    }


    int get(int key) {  
        if(arr[key]==nullptr)return -1;
        remove(arr[key]);
        update(arr[key]);
        return arr[key]-&gt;val;             
    }
    
    void put(int key, int value) {
        if(arr[key]!=nullptr){
            remove(arr[key]);
            update(arr[key]);
            arr[key]-&gt;val=value;
            return;
        }
        capacity--;
        if(capacity&lt;0){     
            int temp=tail-&gt;prev-&gt;ind;
            cout&lt;&lt;temp&lt;&lt;&quot; &quot;;
            remove(tail-&gt;prev);
            delete arr[temp];
            arr[temp]=nullptr;              
        }
        arr[key]=new node;
        update(arr[key]);
        arr[key]-&gt;val=value;
        arr[key]-&gt;ind=key;
        return;         
    }
};</code></pre></details></td><td>74</td><td>173</td><td>O(1)</td><td>O(n)</td><td>53</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;unordered_map&gt;

class LRUCache {
    struct Node {
        int key, value;
        Node* prev;
        Node* next;
        Node(int k, int v): key(k), value(v), prev(nullptr), next(nullptr) {}
    };

    int capacity;
    std::unordered_map&lt;int, Node*&gt; cacheMap;
    Node* head; // dummy head
    Node* tail; // dummy tail

    void removeNode(Node* node) {
        node-&gt;prev-&gt;next = node-&gt;next;
        node-&gt;next-&gt;prev = node-&gt;prev;
    }

    void addNodeToFront(Node* node) {
        node-&gt;next = head-&gt;next;
        node-&gt;prev = head;
        head-&gt;next-&gt;prev = node;
        head-&gt;next = node;
    }

    void moveToHead(Node* node) {
        removeNode(node);
        addNodeToFront(node);
    }

    Node* removeTail() {
        Node* node = tail-&gt;prev;
        removeNode(node);
        return node;
    }

public:
    LRUCache(int capacity) : capacity(capacity) {
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head-&gt;next = tail;
        tail-&gt;prev = head;
    }
    
    int get(int key) {
        if (cacheMap.find(key) == cacheMap.end())
            return -1;
        Node* node = cacheMap[key];
        moveToHead(node);
        return node-&gt;value;
    }
    
    void put(int key, int value) {
        if (cacheMap.find(key) != cacheMap.end()) {
            Node* node = cacheMap[key];
            node-&gt;value = value;
            moveToHead(node);
        } else {
            Node* newNode = new Node(key, value);
            cacheMap[key] = newNode;
            addNodeToFront(newNode);
            if (cacheMap.size() &gt; capacity) {
                Node* tailNode = removeTail();
                cacheMap.erase(tailNode-&gt;key);
                delete tailNode;
            }
        }
    }

    ~LRUCache() {
        Node* current = head;
        while(current) {
            Node* nextNode = current-&gt;next;
            delete current;
            current = nextNode;
        }
    }
};
</code></pre></details></td></tr>
<tr><td>198</td><td><a href="https://leetcode.com/problems/house-robber/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Medium</td><td>0.0</td><td>7.56</td><td>O(n)</td><td>O(n)</td><td>17</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int dp[2][nums.size()];
        for(int i=0;i&lt;nums.size();i++){
            dp[0][i]=0;
            dp[1][i]=nums[i];
            if(i&gt;0){
                dp[0][i]=max(dp[0][i-1],dp[1][i-1]);
                dp[1][i]=dp[0][i-1]+nums[i];
            }
        }
        return max(dp[0][nums.size()-1],dp[1][nums.size()-1]);
    }
};</code></pre></details></td><td>0</td><td>10</td><td>O(n)</td><td>O(1)</td><td>20</td><td><details class="code"><summary>View</summary><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int take = 0, skip = 0;                  // take: rob current; skip: don&#x27;t rob current [web:441]
        for (int x : nums) {
            int newTake = skip + x;              // must have skipped previous to take current [web:441]
            int newSkip = max(skip, take);       // choose best if skipping current [web:441]
            take = newTake;
            skip = newSkip;
        }
        return max(take, skip);                   // best at the end [web:441]
    }
};
</code></pre></details></td></tr>
<tr><td>2</td><td><a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">Link</a></td><td>Linked List</td><td>Medium</td><td>27.0</td><td>71.73</td><td>O(max(n,m))</td><td>O(max(n,m))</td><td>27</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode * head = nullptr;
        ListNode * temp = nullptr;
        bool carry = false;
        while(l1 || l2 || carry){
            if(!head){
                temp = new ListNode;
                head = temp;
            }else{
                temp-&gt;next = new ListNode;
                temp = temp-&gt;next;
            }
            int val=0;
            if(carry)
                val++;
            if(l1){
                val+=l1-&gt;val;
                l1 = l1-&gt;next;
            }
            if(l2){
                val+=l2-&gt;val;
                l2 = l2-&gt;next;
            }
            if(val&gt;=10)
                carry = true;
            else
                carry = false;

            temp-&gt;val = val%10;
            
        }
        return head;
    }
};</code></pre></details></td><td>0</td><td>76.98</td><td>O(max(n,m))</td><td>O(max(n,m))</td><td>24</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;
        int carry = 0;

        while (l1 || l2 || carry) {
            int val1 = (l1) ? l1-&gt;val : 0;
            int val2 = (l2) ? l2-&gt;val : 0;
            int total = val1 + val2 + carry;
            carry = total / 10;
            current-&gt;next = new ListNode(total % 10);
            current = current-&gt;next;

            if (l1) l1 = l1-&gt;next;
            if (l2) l2 = l2-&gt;next;
        }
        return dummy-&gt;next;
    }
};
</code></pre></details></td></tr>
<tr><td>207</td><td><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">Link</a></td><td>Graph</td><td>Medium</td><td>23.0</td><td>13.32</td><td>O(n)</td><td>O(n)</td><td>35</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; pre) {
        vector&lt;vector&lt;int&gt;&gt;adj(numCourses);
        for(vector&lt;int&gt; &amp;i:pre){
            adj[i[1]].push_back(i[0]);
        }
        int indegree[numCourses];
        memset(indegree,0,sizeof(indegree));
        for(int i=0;i&lt;numCourses;i++){
            for(int j:adj[i]){
                if(j==i)return 0;
                indegree[j]++;
            }
        }   
        queue&lt;int&gt;bfs;int count=0;
        for(int i=0;i&lt;numCourses;i++){
            if(indegree[i]==0){
                bfs.push(i);count++;
            }
        }
        while(!bfs.empty()){
            int node=bfs.front();
            bfs.pop();
            for(int i:adj[node]){
                indegree[i]--;
                if(indegree[i]==0){
                    count++;
                    bfs.push(i);
                }
            }
        }
        if(count!=numCourses)
            return 0;
        return 1;
    }
};</code></pre></details></td><td>10</td><td>19.1</td><td>O(n)</td><td>O(n)</td><td>25</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {
        vector&lt;vector&lt;int&gt;&gt; adj(numCourses);
        vector&lt;int&gt; indeg(numCourses, 0);

        // Build graph: edge b -&gt; a (take b before a)
        for (const auto&amp; p : prerequisites) {
            int a = p[0], b = p[1];
            adj[b].push_back(a);
            indeg[a]++;
        }

        queue&lt;int&gt; q;
        // Start with courses having no prerequisites
        for (int i = 0; i &lt; numCourses; ++i)
            if (indeg[i] == 0) q.push(i);

        int taken = 0;
        // Kahn&#x27;s algorithm (BFS)
        while (!q.empty()) {
            int u = q.front(); q.pop();
            taken++;
            for (int v : adj[u]) {
                if (--indeg[v] == 0) q.push(v);
            }
        }
        return taken == numCourses;
    }
};
</code></pre></details></td></tr>
<tr><td>210</td><td><a href="https://leetcode.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener">Link</a></td><td>Graph</td><td>Medium</td><td>19.0</td><td>13.4</td><td>O(n)</td><td>O(n)</td><td>32</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; pre) {
        vector&lt;vector&lt;int&gt;&gt;adj(numCourses);
        for(vector&lt;int&gt; &amp;i:pre){
            adj[i[1]].push_back(i[0]);
        }
        int indegree[numCourses];
        memset(indegree,0,sizeof(indegree));
        for(int i=0;i&lt;numCourses;i++){
            for(int j:adj[i]){
                indegree[j]++;
            }
        }   
        queue&lt;int&gt;bfs;
        vector&lt;int&gt;toposort;
        for(int i=0;i&lt;numCourses;i++){
            if(indegree[i]==0){
                bfs.push(i);toposort.push_back(i);
            }
        }
        while(!bfs.empty()){
            int node=bfs.front();
            bfs.pop();
            for(int i:adj[node]){
                indegree[i]--;
                if(indegree[i]==0){
                    bfs.push(i);toposort.push_back(i);
                }
            }
        }
        if(toposort.size()!=numCourses)
            toposort.clear();
        return toposort;    
    }
};</code></pre></details></td><td>4</td><td>18.08</td><td>O(n)</td><td>O(n)</td><td>28</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {
        vector&lt;vector&lt;int&gt;&gt; adj(numCourses);
        vector&lt;int&gt; indeg(numCourses, 0);

        // Build graph: edge b -&gt; a (b is prerequisite of a)
        for (const auto&amp; p : prerequisites) {
            int a = p[0], b = p[1];
            adj[b].push_back(a);
            indeg[a]++;
        }

        queue&lt;int&gt; q;
        vector&lt;int&gt; order;
        // Seed with nodes having no prerequisites
        for (int i = 0; i &lt; numCourses; ++i)
            if (indeg[i] == 0) { q.push(i); }

        // Kahn&#x27;s algorithm
        while (!q.empty()) {
            int u = q.front(); q.pop();
            order.push_back(u);
            for (int v : adj[u]) {
                if (--indeg[v] == 0) q.push(v);
            }
        }

        if ((int)order.size() != numCourses) return {};
        return order;
    }
};
</code></pre></details></td></tr>
<tr><td>22</td><td><a href="https://leetcode.com/problems/generate-parentheses/description/" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Medium</td><td>8.0</td><td>13.7</td><td>O(C 
n
 )</td><td>O(n×C 
n
 )</td><td>22</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    void getstrings(int n,int left,int ind,vector&lt;string&gt;&amp;ans,string curans){
        if(ind==n){
            ans.emplace_back(curans);
            return;
        }
        if(left&lt;n/2){
            getstrings(n,left+1,ind+1,ans,curans+&#x27;(&#x27;);
        }
        if(ind-left&lt;left){
            getstrings(n,left,ind+1,ans,curans+&#x27;)&#x27;);
        }
        return;
    }

    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;string&gt; ans;
        string x;
        getstrings(2*n,0,0,ans,x);
        return ans;
    }
};</code></pre></details></td><td>2</td><td>13.1</td><td>O(C 
n
 )</td><td>O(n×C 
n
 )</td><td>28</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    void backtrack(int open, int close, int maxPairs, string &amp;current, vector&lt;string&gt; &amp;result) {
        if (current.length() == maxPairs * 2) {
            result.push_back(current);
            return;
        }

        if (open &lt; maxPairs) {
            current.push_back(&#x27;(&#x27;);
            backtrack(open + 1, close, maxPairs, current, result);
            current.pop_back();
        }

        if (close &lt; open) {
            current.push_back(&#x27;)&#x27;);
            backtrack(open, close + 1, maxPairs, current, result);
            current.pop_back();
        }
    }

    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;string&gt; result;
        string current;
        backtrack(0, 0, n, current, result);
        return result;
    }
};
</code></pre></details></td></tr>
<tr><td>22</td><td><a href="https://leetcode.com/problems/generate-parentheses/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Medium</td><td>8.0</td><td>13</td><td>O(4^n / ?n)</td><td> O(n)</td><td>30</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    void getstrings(int n,int left,int ind,vector&lt;string&gt;&amp;ans,string curans){
        if(ind==n){
            ans.emplace_back(curans);
            return;
        }
        if(left&lt;n/2){
            getstrings(n,left+1,ind+1,ans,curans+&#x27;(&#x27;);
        }
        if(ind-left&lt;left){
            getstrings(n,left,ind+1,ans,curans+&#x27;)&#x27;);
        }
        return;
    }

    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;string&gt; ans;
        string x;
        getstrings(2*n,0,0,ans,x);
        return ans;
    }
};</code></pre></details></td><td>4</td><td>14.04</td><td>O(4^n / ?n)</td><td> O(n)</td><td>23</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;string&gt; res;
        string cur;
        function&lt;void(int,int)&gt; dfs = [&amp;](int open, int close) {
            if ((int)cur.size() == 2 * n) { res.push_back(cur); return; }          // complete [web:305]
            if (open &lt; n) { cur.push_back(&#x27;(&#x27;); dfs(open + 1, close); cur.pop_back(); }   // add &#x27;(&#x27; [web:305]
            if (close &lt; open) { cur.push_back(&#x27;)&#x27;); dfs(open, close + 1); cur.pop_back(); } // add &#x27;)&#x27; [web:305]
        };
        dfs(0, 0);
        return res;
    }
};

</code></pre></details></td></tr>
<tr><td>236</td><td><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener">Link</a></td><td>Trees</td><td>Medium</td><td>14.0</td><td>14.74</td><td>O(n)</td><td>O(h) (h is height of the tree)</td><td>12</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root == p || root ==q )return root;
        TreeNode * left = lowestCommonAncestor(root-&gt;left, p , q);
        TreeNode * right = lowestCommonAncestor(root-&gt;right, p, q);
        if(left &amp;&amp; right)
            return root;
        if(left)
            return left;
        if(right)
            return right;
        return nullptr;
    }
};</code></pre></details></td><td>8</td><td>17.51</td><td>O(n)</td><td>O(h) (h is height of the tree)</td><td>15</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) return nullptr;
        if (root == p || root == q) return root;
        
        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
        
        if (left &amp;&amp; right) return root;
        return left ? left : right;
    }
};
</code></pre></details></td></tr>
<tr><td>237</td><td><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/description/" target="_blank" rel="noopener">Link</a></td><td>Linked List</td><td>Medium</td><td>3.0</td><td>11.45</td><td>O(1)</td><td>O(1)</td><td>8</td><td><details class="code"><summary>View</summary><pre><code>
class Solution {
public:
    void deleteNode(ListNode* node) {
        ListNode* tmp = node-&gt;next;
        node-&gt;val = node-&gt;next-&gt;val;
        node-&gt;next = node-&gt;next-&gt;next;
        delete tmp;
        return;
    }
};</code></pre></details></td><td>9</td><td>12.25</td><td>O(1)</td><td>O(1)</td><td>8</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    void deleteNode(ListNode* node) {
        ListNode* tmp = node-&gt;next;
        node-&gt;val = node-&gt;next-&gt;val; // Copy value from next node
        node-&gt;next = node-&gt;next-&gt;next; // Link to next&#x27;s next node
        delete tmp;  // Free memory of next node
    }
};
</code></pre></details></td></tr>
<tr><td>2415</td><td><a href="https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/description/" target="_blank" rel="noopener">Link</a></td><td>Trees</td><td>Medium</td><td>3.0</td><td>77.1</td><td>O(n)</td><td>O(h)</td><td>15</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    void reverseTree(TreeNode* root1, TreeNode* root2, int level){
      if(!root1) return;
      if(level%2){
        swap(root1-&gt;val, root2-&gt;val);
      }
      reverseTree(root1-&gt;left, root2-&gt;right, level+1);
      if(root1 != root2)
        reverseTree(root1-&gt;right, root2-&gt;left, level+1);
      return;
    }

    TreeNode* reverseOddLevels(TreeNode* root) {
      this-&gt;reverseTree(root, root, 0);
      return root;
    }
};</code></pre></details></td><td>5</td><td>84.18</td><td>O(n)</td><td>O(n)</td><td>30</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    TreeNode* reverseOddLevels(TreeNode* root) {
        if (!root) return nullptr;

        std::queue&lt;TreeNode*&gt; q;
        q.push(root);
        int level = 0;

        while (!q.empty()) {
            int size = q.size();
            std::vector&lt;TreeNode*&gt; currentLevelNodes;

            for (int i = 0; i &lt; size; ++i) {
                TreeNode* node = q.front();
                q.pop();
                currentLevelNodes.push_back(node);

                if (node-&gt;left) q.push(node-&gt;left);
                if (node-&gt;right) q.push(node-&gt;right);
            }

            if (level % 2 == 1) {
                int left = 0, right = (int)currentLevelNodes.size() - 1;
                while (left &lt; right) {
                    std::swap(currentLevelNodes[left]-&gt;val, currentLevelNodes[right]-&gt;val);
                    ++left;
                    --right;
                }
            }
            ++level;
        }

        return root;
    }
};</code></pre></details></td></tr>
<tr><td>2425</td><td><a href="https://leetcode.com/problems/bitwise-xor-of-all-pairings/description/" target="_blank" rel="noopener">Link</a></td><td>Bit Manipulation</td><td>Medium</td><td>0.0</td><td>64.81</td><td>O(n)</td><td>O(1)</td><td>19</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int xorAllNums(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
      int ans = 0;
      if(nums1.size()%2){
        for(int i = 0; i&lt;nums2.size(); i++){
          ans ^= nums2[i];
        }
      }
      if(nums2.size()%2){
        for(int i = 0; i&lt;nums1.size(); i++){
          ans ^= nums1[i];
        }
      }
      return ans;
    }
};</code></pre></details></td><td>1</td><td>64.38</td><td>O(n)</td><td>O(n)</td><td>20</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int xorAllNums(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int ans = 0;
        if (nums2.size() % 2 == 1) {
            for (int x : nums1) ans ^= x;   // each nums1[i] appears |nums2| times
        }
        if (nums1.size() % 2 == 1) {
            for (int y : nums2) ans ^= y;   // each nums2[j] appears |nums1| times
        }
        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>2762</td><td><a href="https://leetcode.com/problems/continuous-subarrays/description/" target="_blank" rel="noopener">Link</a></td><td>Queue</td><td>Medium</td><td>251.0</td><td>155</td><td>O(nlogn)</td><td>O(n)</td><td>41</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    long long continuousSubarrays(vector&lt;int&gt;&amp; nums) {
      int left = 0, right = 0;
      long long ans = 0;
      multiset&lt;int&gt; window;
      while(left&lt;nums.size()){
        if(!window.empty()){
          if(right&lt;nums.size()){
            int mini = *(window.begin());
            int maxi = *(window.rbegin());
            mini = min(mini, nums[right]);
            maxi = max(maxi, nums[right]);
            if(maxi - mini &lt;= 2){
              window.insert(nums[right]);
              right++;
            }
            else{
              ans += window.size();
              window.erase(window.find(nums[left]));
              left++;
            }
          }
          else{
            ans += window.size();
            window.erase(window.find(nums[left]));
            left++;
          }
        }
        else{
          window.insert(nums[right]);
          right++;
        }
        // cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;
      }
      return ans;
    }
};</code></pre></details></td><td>225</td><td>156.26</td><td>O(nlogn)</td><td>O(n)</td><td>22</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    long long continuousSubarrays(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int left = 0;
        multiset&lt;int&gt; win;           // keeps elements in sorted order
        long long ans = 0;

        for (int right = 0; right &lt; n; ++right) {
            win.insert(nums[right]);
            while (!win.empty() &amp;&amp; *win.rbegin() - *win.begin() &gt; 2) {
                win.erase(win.find(nums[left]));
                ++left;
            }
            ans += (right - left + 1); // all subarrays ending at right and starting in [left..right]
        }
        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>2997</td><td><a href="https://leetcode.com/problems/minimum-number-of-operations-to-make-array-xor-equal-to-k/description/" target="_blank" rel="noopener">Link</a></td><td>Bit Manipulation</td><td>Medium</td><td>116.0</td><td>94</td><td>O(n)</td><td>O(1)</td><td>14</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int minOperations(vector&lt;int&gt;&amp; nums, int k) {
        for(int i = 0; i&lt;nums.size(); i++)
            k = k^nums[i];
        int ans= 0;
        for(int i = 0; i&lt;31; i++)
            if((k&gt;&gt;i)&amp;1)
                ans++;
        return ans;
    }
};</code></pre></details></td><td>110</td><td>92.25</td><td>O(n)</td><td>O(1)</td><td>17</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int minOperations(vector&lt;int&gt;&amp; nums, int k) {
        int x = 0;
        for (int v : nums) x ^= v;        // current XOR of array [web:510][web:511]
        int y = x ^ k;                    // bits that must change [web:510][web:511]
        return __builtin_popcount((unsigned)y);  // count differing bits [web:511][web:503]
    }
};
</code></pre></details></td></tr>
<tr><td>31</td><td><a href="https://leetcode.com/problems/next-permutation/description/" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Medium</td><td>3.0</td><td>12.2</td><td>O(n)</td><td>O(1)</td><td>26</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    void nextPermutation(vector&lt;int&gt;&amp; nums) {
        int i=int(nums.size())-1;
        for(;i&gt;0;i--){
            if(nums[i]&gt;nums[i-1]){
                break;
            }
        }
        if(i&gt;0){
            int temp=i;
            for(int j=i+1;j&lt;int(nums.size());j++){
                if(nums[j]&gt;nums[i-1]){
                    if(nums[temp]&gt;=nums[j])
                        temp=j;
                }
            }
            swap(nums[temp],nums[i-1]);
        }
        for(int j=0;j&lt;nums.size();j++)cout&lt;&lt;nums[j]&lt;&lt;&quot; &quot;;
        for(int j=i;j&lt;i+(int(nums.size())-i)/2;j++){
            if(nums[j]&gt;nums[int(nums.size()-1)-j+i])
            swap(nums[j],nums[int(nums.size()-1)-j+i]);
        }
    }
};</code></pre></details></td><td>0</td><td>15.54</td><td>O(n)</td><td>O(1)</td><td>18</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    void nextPermutation(vector&lt;int&gt;&amp; nums) {
        int i = nums.size() - 2;
        // Find first decreasing element from right
        while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) i--;
        
        if (i &gt;= 0) {
            int j = nums.size() - 1;
            // Find element just larger than nums[i] from right
            while (nums[j] &lt;= nums[i]) j--;
            swap(nums[i], nums[j]);
        }
        // Reverse the elements after index i
        reverse(nums.begin() + i + 1, nums.end());
    }
};
</code></pre></details></td></tr>
<tr><td>3191</td><td><a href="https://leetcode.com/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/description/" target="_blank" rel="noopener">Link</a></td><td>Queue</td><td>Medium</td><td>112.0</td><td>138</td><td>O(n)</td><td>O(1)</td><td>27</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int minOperations(vector&lt;int&gt;&amp; nums) {
        int ans = 0;
        for(int i = 0; i&lt;nums.size()-2; i++){
            if(nums[i] == 0){
                ans++;
                for(int j = i; j&lt;i+3; j++){
                    nums[j]  = !nums[j];
                }
            }
        }
        for(int i = 0; i&lt;nums.size(); i++){
            if(!nums[i])
                return -1;
        }
        return ans;
    }
};</code></pre></details></td><td>8</td><td>140</td><td>O(n)</td><td>O(1)</td><td>26</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int minOperations(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int ops = 0;
        for (int i = 0; i + 2 &lt; n; ++i) {
            if (nums[i] == 0) {
                // flip nums[i], nums[i+1], nums[i+2]
                nums[i]   ^= 1;
                nums[i+1] ^= 1;
                nums[i+2] ^= 1;
                ++ops;
            }
        }
        // verify the array is all ones
        for (int x : nums) if (x == 0) return -1;
        return ops;
    }
};
</code></pre></details></td></tr>
<tr><td>3191</td><td><a href="https://leetcode.com/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/description/" target="_blank" rel="noopener">Link</a></td><td>Bit Manipulation</td><td>Medium</td><td>112.0</td><td>138</td><td>O(n)</td><td>O(1)</td><td>19</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int minOperations(vector&lt;int&gt;&amp; nums) {
        int ans = 0;
        for(int i = 0; i&lt;nums.size()-2; i++){
            if(nums[i] == 0){
                ans++;
                for(int j = i; j&lt;i+3; j++){
                    nums[j]  = !nums[j];
                }
            }
        }
        for(int i = 0; i&lt;nums.size(); i++){
            if(!nums[i])
                return -1;
        }
        return ans;
    }
};</code></pre></details></td><td>11</td><td>140</td><td>O(n)</td><td>O(1)</td><td>27</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int minOperations(vector&lt;int&gt;&amp; nums) {
        int n = nums.size(), ops = 0;
        for (int i = 0; i &lt;= n - 3; ++i) {
            if (nums[i] == 0) {
                ++ops;
                nums[i]   ^= 1;
                nums[i+1] ^= 1;
                nums[i+2] ^= 1;
            }
        }
        for (int i = n - 2; i &lt; n; ++i) {
            if (i &gt;= 0 &amp;&amp; nums[i] == 0) return -1;
        }
        return ops;
    }
};
</code></pre></details></td></tr>
<tr><td>430</td><td><a href="https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/description/" target="_blank" rel="noopener">Link</a></td><td>Linked List</td><td>Medium</td><td>5.0</td><td>7.48</td><td>O(n)</td><td>
O(1)</td><td>43</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    Node* flatten(Node* head) {

        Node * child=nullptr;
        Node * prevtail=nullptr;
        Node * itr=head;
        bool levelTraversed=true;

        while(!levelTraversed||itr!=nullptr){

            if(itr-&gt;child)
                child=itr;
           
            if(itr-&gt;child!=nullptr&amp;&amp;levelTraversed){

                prevtail=itr-&gt;next;
                itr-&gt;next=itr-&gt;child;
                itr-&gt;child-&gt;prev=itr;
                itr-&gt;child=nullptr;
                levelTraversed=false;
                child=nullptr;
                
            }

            if(itr-&gt;next==nullptr&amp;&amp;!levelTraversed){

                if(prevtail)
                    prevtail-&gt;prev=itr;
                itr-&gt;next=prevtail;
                levelTraversed=true;
                itr=child;
                continue;

            }

            itr=itr-&gt;next;
        }
       
        
        return head;

    }
};</code></pre></details></td><td>0</td><td>11.78</td><td>O(n)</td><td>O(1) </td><td>28</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    Node* flatten(Node* head) {
        if (!head) return head;
        
        Node* curr = head;
        while (curr) {
            if (curr-&gt;child) {
                Node* child = curr-&gt;child;
                Node* next = curr-&gt;next;
                
                // Attach child list after curr
                curr-&gt;next = child;
                child-&gt;prev = curr;
                curr-&gt;child = nullptr;
                
                // Find tail of child list
                Node* tail = child;
                while (tail-&gt;next) {
                    tail = tail-&gt;next;
                }
                
                // Reconnect the next pointer after tail
                if (next) {
                    tail-&gt;next = next;
                    next-&gt;prev = tail;
                }
            }
            curr = curr-&gt;next;
        }
        return head;
    }
};
</code></pre></details></td></tr>
<tr><td>464</td><td><a href="https://leetcode.com/problems/can-i-win/description/" target="_blank" rel="noopener">Link</a></td><td>Bit Manipulation</td><td>Medium</td><td>257.0</td><td>15.27</td><td>O(2^n)</td><td>O(2^n)</td><td>33</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int dp[2097153];
    bool recur(int vis,int m,int d){
        if(d&lt;=0)return 0;
        if(dp[vis]!=-1)
            return dp[vis];
        for(int i=1;i&lt;=m;i++){
            if(((vis&gt;&gt;i)&amp;1)==0){
                if(recur(vis+(1&lt;&lt;i),m,d-i)==0)
                    return dp[vis]=1;
            }
        }
        return dp[vis]=0;
    }
    bool canIWin(int m, int d) {
        for(int i=0;i&lt;2097153;i++){
            dp[i]=-1;
        }
        if(d==0)return 1;
        if(m*(m+1)/2&lt;d)return 0;
        return recur(0,m,d);
    }
};</code></pre></details></td><td>604</td><td>93.15</td><td>O(2^n)</td><td>O(2^n)</td><td>34</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool canIWin(int maxChoosableInteger, int desiredTotal) {
        if (desiredTotal &lt;= 0) return true;                                  // win trivially [web:566][web:576]
        int maxSum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;
        if (maxSum &lt; desiredTotal) return false;                             // impossible to reach target [web:566][web:576]

        unordered_map&lt;int, bool&gt; memo;                                       // mask -&gt; win/lose [web:576]
        function&lt;bool(int,int)&gt; dfs = [&amp;](int mask, int need) -&gt; bool {
            auto it = memo.find(mask);
            if (it != memo.end()) return it-&gt;second;                         // memoized state [web:566]
            for (int x = 1; x &lt;= maxChoosableInteger; ++x) {
                if ((mask &gt;&gt; x) &amp; 1) continue;                               // used already [web:566]
                if (x &gt;= need) return memo[mask] = true;                     // take x and win now [web:566]
                int nextMask = mask | (1 &lt;&lt; x);
                if (!dfs(nextMask, need - x))                                // opponent loses -&gt; current wins [web:566]
                    return memo[mask] = true;
            }
            return memo[mask] = false;                                       // no winning move [web:566]
        };

        return dfs(0, desiredTotal);
    }
};
</code></pre></details></td></tr>
<tr><td>48</td><td><a href="https://leetcode.com/problems/rotate-image/description/" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Medium</td><td>0.0</td><td>10.1</td><td>O(n^2)</td><td>O(1)</td><td>18</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        for(int i = 0; i&lt;matrix.size(); i++){
            for(int j = 0; j&lt;i; j++){
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        for(int i = 0; i&lt;matrix[0].size()/2; i++){
            int ind = matrix[0].size()-1-i;
            for(int j = 0; j&lt;matrix.size(); j++){
                swap(matrix[j][i], matrix[j][ind]);
            }
        }
        return;
    }
};</code></pre></details></td><td>0</td><td>10.02</td><td>O(n^2)</td><td>O(1)</td><td>21</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        
        // Transpose the matrix
        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt; n; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }

        // Reverse each row
        for (int i = 0; i &lt; n; i++) {
            int left = 0, right = n - 1;
            while (left &lt; right) {
                swap(matrix[i][left], matrix[i][right]);
                left++;
                right--;
            }
        }
    }
};
</code></pre></details></td></tr>
<tr><td>5</td><td><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Medium</td><td>91.0</td><td>8.82</td><td>O(n)</td><td>O(n)</td><td>42</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    string manacher(string &amp;str){
  
        string tweakedStr;
        vector&lt;int&gt;maxPalindrome((2*str.length())+1,0);

        tweakedStr+=&#x27;*&#x27;; 
        for(int i=0;i&lt;str.length();i++){
            tweakedStr+=str[i];
            tweakedStr+=&#x27;*&#x27;; 
        }

        int ans = 0, mid = 1, right = 1;
        for(int i=0;i&lt;tweakedStr.length();i++)cout&lt;&lt;tweakedStr[i]&lt;&lt;&quot; &quot;;
        cout&lt;&lt;endl;
        for(int i=0;i&lt;tweakedStr.length();i++)
        {     
            maxPalindrome[i]=max(0,min(maxPalindrome[mid-(i-mid)],right-i));
            int ind = maxPalindrome[i];
            while(i-ind-1&gt;=0&amp;&amp;i+ind+1&lt;tweakedStr.length()&amp;&amp;tweakedStr[i-ind-1]==tweakedStr[i+ind+1]){
                ind++;
            }
            maxPalindrome[i] = ind;
            if(maxPalindrome[i]&gt;maxPalindrome[ans]){
                ans=i;
            }            
            if( i+ind &gt;= right ){                        //upadte bounding box
                right = i+ind;
                mid = i;
            }
            cout&lt;&lt;maxPalindrome[i]&lt;&lt;&quot; &quot;;
        }

        string maxPalin;
        for(int i=ans-maxPalindrome[ans];i&lt;=ans+maxPalindrome[ans];i++)
            if(tweakedStr[i]!=&#x27;*&#x27;)
                maxPalin+=tweakedStr[i];
        return maxPalin;
    }

    string longestPalindrome(string s) {
        return manacher(s);
    }
};</code></pre></details></td><td>7</td><td>9.4</td><td>O(n^2)</td><td>O(1)</td><td>24</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    string longestPalindrome(string s) {
        if (s.length() &lt; 2) return s;

        int start = 0, maxLength = 1;

        for (int i = 0; i &lt; s.size(); i++) {
            expandAroundCenter(s, i, i, start, maxLength);       // odd length palindromes
            expandAroundCenter(s, i, i + 1, start, maxLength);   // even length palindromes
        }

        return s.substr(start, maxLength);
    }

    void expandAroundCenter(const string&amp; s, int left, int right, int&amp; start, int&amp; maxLength) {
        while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) {
            left--;
            right++;
        }
        int length = right - left - 1;
        if (length &gt; maxLength) {
            maxLength = length;
            start = left + 1;
        }
    }
};
</code></pre></details></td></tr>
<tr><td>5</td><td><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">Link</a></td><td>Dynamic Programming</td><td>Medium</td><td>0.0</td><td>9.05</td><td>O(n)</td><td>O(n)</td><td>55</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    string manacher(string &amp;str){
  
        string tweakedStr;
        vector&lt;int&gt;maxPalindrome((2*str.length())+1,0);

        tweakedStr+=&#x27;*&#x27;; 
        for(int i=0;i&lt;str.length();i++){
            tweakedStr+=str[i];
            tweakedStr+=&#x27;*&#x27;; 
        }

        int ans = 0, mid = 1, right = 1;

        for(int i=0;i&lt;tweakedStr.length();i++)
        {     
            maxPalindrome[i]=max(0,min(maxPalindrome[2*mid-i],right-i));
            int ind = maxPalindrome[i];
            while(i-ind-1&gt;=0&amp;&amp;i+ind+1&lt;tweakedStr.length()&amp;&amp;tweakedStr[i-ind-1]==tweakedStr[i+ind+1]){
                ind++;
            }
            maxPalindrome[i] = ind;
            if(maxPalindrome[i]&gt;maxPalindrome[ans]){
                ans=i;
            }            
            if( i+ind &gt;= right ){
                right = i+ind;
                mid = i;
            }
        }

        string maxPalin;
        for(int i=ans-maxPalindrome[ans];i&lt;=ans+maxPalindrome[ans];i++)
            if(tweakedStr[i]!=&#x27;*&#x27;)
                maxPalin+=tweakedStr[i];
        return maxPalin;
    }

    string longestPalindrome(string s) {
        return manacher(s);
    }
};</code></pre></details></td><td>error</td><td>error</td><td>O(n)</td><td>O(n)</td><td>39</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty()) return &quot;&quot;;
        // Transform: add separators to handle even-length palindromes uniformly
        string t = &quot;^&quot;;
        for (char c : s) { t += &quot;#&quot;; t += c; }
        t += &quot;#$&quot;;

        int n = t.size();
        vector&lt;int&gt; p(n, 0); // palindrome radius at each center
        int center = 0, right = 0;
        int bestLen = 0, bestCenter = 0;

        for (int i = 1; i &lt; n - 1; ++i) {
            int mirror = 2*center - i;
            if (i &lt; right) p[i] = min(right - i, p[mirror]);

            // expand around i
            while (t[i + 1 + p[i]] == t[i - 1 - p[i]]) ++p[i];

            // update center/right
            if (i + p[i] &gt; right) {
                center = i;
                right = i + p[i];
            }
            if (p[i] &gt; bestLen) {
                bestLen = p[i];
                bestCenter = i;
            }
        }
        int start = (bestCenter - bestLen) / 2; // map back to s
        return s.substr(start, bestLen);
    }
};
</code></pre></details></td></tr>
<tr><td>547</td><td><a href="https://leetcode.com/problems/number-of-provinces/description/" target="_blank" rel="noopener">Link</a></td><td>Graph</td><td>Medium</td><td>13.0</td><td>15.31</td><td>O(n^2)</td><td>O(n)</td><td>65</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

class UnionFind{

        public:

        vector&lt;int&gt;parent;
        vector&lt;int&gt;size;
        int maxsize;
        
        UnionFind(int size){

            parent.resize(size);
            this-&gt;size.resize(size);

            clear();

        }

        void clear(){

            for(int i=0;i&lt;parent.size();i++)parent[i]=i;
            for(int i=0;i&lt;this-&gt;size.size();i++)size[i]=1;
            maxsize=0;

        }

        void Union(int node1,int node2){
            node1=find(node1);
            node2=find(node2);
            if(node1==node2){
                return;
            }
            if(size[node1]&lt;size[node2]){
                swap(node1,node2);
            }
            parent[node2]=node1;
            size[node1]+=size[node2];
            maxsize=max(maxsize,size[node1]);
        }

        int find(int node1){
            if(parent[node1]==node1)
                return node1;
            return parent[node1]=find(parent[node1]);
        }

        int noofsets(){
            int sets=0;
            for(int i=0;i&lt;parent.size();i++){
                if(parent[i]==i)
                    sets++;
            }
            return sets;
        }

    };

    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) {
        int n=isConnected.size();
        UnionFind UF = UnionFind(n);
        for(int i=0;i&lt;n;i++){
            for(int j=i+1;j&lt;n;j++){
                if(isConnected[i][j])
                    UF.Union(i,j);
            }
        }
        return UF.noofsets();
    }
};</code></pre></details></td><td>0</td><td>19.69</td><td>O(n^2)</td><td>O(n)</td><td>27</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) {
        int n = (int)isConnected.size();
        vector&lt;char&gt; vis(n, 0);

        function&lt;void(int)&gt; dfs = [&amp;](int u) {
            vis[u] = 1;
            for (int v = 0; v &lt; n; ++v) {
                if (!vis[v] &amp;&amp; isConnected[u][v] == 1) {
                    dfs(v);
                }
            }
        };

        int provinces = 0;
        for (int i = 0; i &lt; n; ++i) {
            if (!vis[i]) {
                dfs(i);
                ++provinces;
            }
        }
        return provinces;
    }
};
</code></pre></details></td></tr>
<tr><td>55</td><td><a href="https://leetcode.com/problems/jump-game/description/" target="_blank" rel="noopener">Link</a></td><td>Array</td><td>Medium</td><td>60.0</td><td>48.61</td><td>O(n)</td><td>O(1)</td><td>14</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
        cin.tie(0);
        ios_base::sync_with_stdio(false);
        int ind=1;
        int curlim=nums[0];
        while(ind&lt;nums.size()-1&amp;&amp;ind&lt;=curlim){
            curlim=max(curlim,ind+nums[ind]);
            ind++;                
        }              
        if(curlim&lt;nums.size()-1)            
            return false;
        return true;
    }
};
   </code></pre></details></td><td>0</td><td>52.34</td><td>O(n)</td><td>O(1)</td><td>12</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
        int maxReach = 0;
        int n = nums.size();
        for (int i = 0; i &lt; n; i++) {
            if (i &gt; maxReach) return false;
            maxReach = max(maxReach, i + nums[i]);
            if (maxReach &gt;= n - 1) return true;
        }
        return false;
    }
};
</code></pre></details></td></tr>
<tr><td>6</td><td><a href="https://leetcode.com/problems/zigzag-conversion/description/" target="_blank" rel="noopener">Link</a></td><td>String</td><td>Medium</td><td>10.0</td><td>13.95</td><td>O(n)</td><td>O(n)</td><td>27</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows == 1)
            return s;
        vector&lt;string&gt; matrix(numRows);
        int ind = 0;
        string ans;
        bool traverseDown = true;
        for(int i = 0; i&lt;s.length(); i++){
            matrix[ind] += s[i];
            if(traverseDown &amp;&amp; ind == numRows-1){
                traverseDown = !traverseDown;
            }
            if(!traverseDown &amp;&amp; ind == 0){
                traverseDown = !traverseDown;
            }
            if(traverseDown){
                ind++;
            }
            else{
                ind--;
            }
        }   
        for(int i = 0; i&lt;numRows; i++){
            ans += matrix[i];
        }
        return ans;
    }
};</code></pre></details></td><td>3</td><td>14.1</td><td>O(n)</td><td>O(n)</td><td>22</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    string convert(string s, int numRows) {
        if (numRows == 1) return s;

        vector&lt;string&gt; rows(min(numRows, int(s.size())));
        int curRow = 0;
        bool goingDown = false;

        for (char c : s) {
            rows[curRow] += c;
            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;
            curRow += goingDown ? 1 : -1;
        }

        string result;
        for (string &amp;row : rows) {
            result += row;
        }

        return result;
    }
};
</code></pre></details></td></tr>
<tr><td>684</td><td><a href="https://leetcode.com/problems/redundant-connection/description/" target="_blank" rel="noopener">Link</a></td><td>Graph</td><td>Medium</td><td>3.0</td><td>8.9</td><td>O(n)</td><td>O(n)</td><td>66</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    class UnionFind{

        public:

        vector&lt;int&gt;parent;
        vector&lt;int&gt;size;
        int maxsize;
        
        UnionFind(int size){

            parent.resize(size);
            this-&gt;size.resize(size);

            clear();

        }

        void clear(){

            for(int i=0;i&lt;parent.size();i++)parent[i]=i;
            for(int i=0;i&lt;this-&gt;size.size();i++)size[i]=1;
            maxsize=0;

        }

        void Union(int node1,int node2){
            node1=find(node1);
            node2=find(node2);
            if(node1==node2){
                return;
            }
            if(size[node1]&lt;size[node2]){
                swap(node1,node2);
            }
            parent[node2]=node1;
            size[node1]+=size[node2];
            maxsize=max(maxsize,size[node1]);
        }

        int find(int node1){
            if(parent[node1]==node1)
                return node1;
            return parent[node1]=find(parent[node1]);
        }

        int noofsets(){
            int sets=0;
            for(int i=0;i&lt;parent.size();i++){
                if(parent[i]==i)
                    sets++;
            }
            return sets;
        }

    };    

    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        UnionFind UF(edges.size()+1);
        for(int i=0;i&lt;edges.size();i++){
            if(UF.find(edges[i][0])==UF.find(edges[i][1]))
                return edges[i];
            UF.Union(edges[i][1],edges[i][0]);
        }
        return {0,0};
    }
};</code></pre></details></td><td>error</td><td>error</td><td>O(n)</td><td>O(n)</td><td>25</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        int n = edges.size();
        vector&lt;int&gt; parent(n + 1), rank_(n + 1, 0);
        iota(parent.begin(), parent.end(), 0);

        function&lt;int(int)&gt; find = [&amp;](int x) {
            if (parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        };

        auto unite = [&amp;](int a, int b) {
            int ra = find(a), rb = find(b);
            if (ra == rb) return false;
            if (rank_[ra] &lt; rank_[rb]) swap(ra, rb);
            parent[rb] = ra;
            if (rank_[ra] == rank_[rb]) rank_[ra]++;
            return true;
        };

        for (auto &amp;e : edges) {
            int a = e, b = e[1];
            if (!unite(a, b)) return e;
        }
        return {};
    }
};
</code></pre></details></td></tr>
<tr><td>739</td><td><a href="https://leetcode.com/problems/daily-temperatures/description/" target="_blank" rel="noopener">Link</a></td><td>Stack</td><td>Medium</td><td>102.0</td><td>103</td><td>O(n)</td><td>O(n)</td><td>17</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) {
        vector&lt;int&gt; st;
        vector&lt;int&gt; ans(temperatures.size(), 0);
        for(int i = 0; i&lt;temperatures.size(); i++){
            while(!st.empty() &amp;&amp; temperatures[st.back()]&lt;temperatures[i]){
                ans[st.back()] = i - st.back();
                st.pop_back();
            }
            st.push_back(i);
        }
        return ans;
    }
};</code></pre></details></td><td>13</td><td>105</td><td>O(n)</td><td>O(n)</td><td>20</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) {
        int n = temperatures.size();
        vector&lt;int&gt; ans(n, 0);
        vector&lt;int&gt; st; // stack of indices, temperatures strictly decreasing from bottom to top
        for (int i = 0; i &lt; n; ++i) {
            while (!st.empty() &amp;&amp; temperatures[st.back()] &lt; temperatures[i]) {
                int j = st.back();
                st.pop_back();
                ans[j] = i - j;
            }
            st.push_back(i);
        }
        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>769</td><td><a href="https://leetcode.com/problems/max-chunks-to-make-sorted/description/" target="_blank" rel="noopener">Link</a></td><td>Stack</td><td>Medium</td><td>0.0</td><td>9.15</td><td>0(n^2)</td><td>O(1)</td><td>23</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int maxChunksToSorted(vector&lt;int&gt;&amp; arr) {
      int ans = 0;
      int prev = 0;
      for(int i = 0; i&lt;arr.size(); i++){
        int size = 0;
        for(int j = prev; j&lt;=i; j++){
          if(arr[j] &lt;= i &amp;&amp; arr[i]&gt;=prev)
            size++;
        }
        if(size == i-prev+1){
          ans++;
          prev = i;
        }
      }
      return ans;
    }
};</code></pre></details></td><td>0</td><td>9.14</td><td>O(n)</td><td>O(1)</td><td>16</td><td><details class="code"><summary>View</summary><pre><code>
class Solution {
public:
    int maxChunksToSorted(vector&lt;int&gt;&amp; arr) {
        int ans = 0, mx = INT_MIN;
        for (int i = 0; i &lt; (int)arr.size(); ++i) {
            mx = max(mx, arr[i]);
            if (mx == i) ++ans;
        }
        return ans;
    }
};
</code></pre></details></td></tr>
<tr><td>78</td><td><a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="noopener">Link</a></td><td>Bit Manipulation</td><td>Medium</td><td>0.0</td><td>11.21</td><td>O(2^n)</td><td>O(n)</td><td>31</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    void recur(int ind, vector&lt;int&gt;&amp;nums, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; comb){
        if(ind == nums.size()){
            ans.push_back(comb);
        }
        else{
            recur(ind+1, nums, ans, comb);
            comb.push_back(nums[ind]);
            recur(ind+1, nums, ans, comb);
            comb.pop_back();
        }
        return;
    }

    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; ans;
        vector&lt;int&gt; comb;
        recur(0, nums, ans, comb);        
        return ans;
    }
};</code></pre></details></td><td>0</td><td>12.49</td><td>O(2^n)</td><td>O(n)</td><td>26</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    void dfs(int i, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res) {
        if (i == (int)nums.size()) { res.push_back(cur); return; }
        dfs(i + 1, nums, cur, res);        // skip
        cur.push_back(nums[i]);            // take
        dfs(i + 1, nums, cur, res);
        cur.pop_back();
    }

    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; cur;
        dfs(0, nums, cur, res);
        return res;
    }
};
</code></pre></details></td></tr>
<tr><td>785</td><td><a href="https://leetcode.com/problems/is-graph-bipartite/description/" target="_blank" rel="noopener">Link</a></td><td>Graph</td><td>Medium</td><td>23.0</td><td>13.44</td><td>O(V+E)</td><td>O(V)</td><td>24</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
        short  n=graph.size();
        vector&lt;short&gt;visited(n,-1);
        queue&lt;short&gt;bfs;
        for(short i=0;i&lt;n;i++){
            if(visited[i]!=-1)continue;
            bfs.push(i);
            visited[i]=1;
            while(!bfs.empty()){
                short node=bfs.front();
                bfs.pop();
                for(short child:graph[node]){
                    if(visited[child]==-1){
                        visited[child]=1-visited[node];
                        bfs.push(child);
                    }
                    else{
                        if(visited[child]==visited[node])
                            return 0;
                    }
                }
            }
        }
        return 1;
    }
};</code></pre></details></td><td>0</td><td>17.64</td><td>O(V+E)</td><td>O(V)</td><td>24</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
        int n = graph.size();
        vector&lt;int&gt; color(n, 0); // 0 = uncolored, 1 and -1 are the two colors

        for (int start = 0; start &lt; n; ++start) {
            if (color[start] != 0) continue; // already visited in some component
            queue&lt;int&gt; q;
            q.push(start);
            color[start] = 1;

            while (!q.empty()) {
                int u = q.front(); q.pop();
                for (int v : graph[u]) {
                    if (color[v] == 0) {
                        color[v] = -color[u];
                        q.push(v);
                    } else if (color[v] == color[u]) {
                        return false; // conflict found
                    }
                }
            }
        }
        return true;
    }
};
</code></pre></details></td></tr>
<tr><td>787</td><td><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/description/" target="_blank" rel="noopener">Link</a></td><td>Graph</td><td>Medium</td><td>25.0</td><td>13.14</td><td>O(k·E)</td><td>O(V + E)</td><td>60</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) {
        vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt;adj(n);
        for(int i=0;i&lt;flights.size();i++){
            adj[flights[i][0]].push_back({flights[i][1],flights[i][2]});
        }
        vector&lt;int&gt;dist(n,1e7);        
        int i=1;
        vector&lt;int&gt;prev(n,1e7);
        for(auto it:adj[src]){
            prev[it.first]=it.second;
        }
        int ans=1e7;
        ans=min(ans,prev[dst]);
        
        while(i&lt;=k){
            for(int j=0;j&lt;n;j++){
                if(prev[j]&gt;=1e7)continue;
                for(auto it:adj[j]){
                    dist[it.first]=min(dist[it.first],prev[j]+it.second);
                }
            }
            ans=min(ans,dist[dst]);
            swap(prev,dist);
            dist=vector&lt;int&gt;(n,1e7);
            i++;
        }


        //for &quot;atleast k&quot; variation maybe

        // int ext=0;
        // if(prev[dst]&gt;=1e7){
        //     vector&lt;int&gt;mindist(n,1e7);
        //     set&lt;pair&lt;int,int&gt;&gt;dij;

        //     for(int i=0;i&lt;n;i++){
        //         if(prev[i]&lt;1e7){
        //             dij.insert({prev[i],i});        
        //         }
        //     }

        //     while(!dij.empty()){
        //         int node=(*dij.begin()).second;
        //         int di=(*dij.begin()).first;
        //         dij.erase(dij.begin());
        //         if(mindist[node]&lt;1e7)continue;
        //         mindist[node]=di;                
        //         for(auto it:adj[node]){
        //             if(mindist[it.first]&gt;=1e7)
        //                 dij.insert({di+it.second,it.first});
        //         }
        //     }

        //     ext=mindist[dst];

        // }
        // if(prev[dst]&lt;1e7)
        //     return prev[dst];
        // if(ext&lt;1e7)
        //     return ext;            
        // return -1;
        if(ans&lt;1e7)return ans;
        return -1;
    }
};</code></pre></details></td><td>error</td><td>error</td><td></td><td></td><td>20</td><td><details class="code"><summary>View</summary><pre><code>
class Solution {
public:
    int findCheapestPrice(int n, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; flights,
                          int src, int dst, int k) {
        const int INF = 1e9;
        // dist_prev holds costs using up to t edges; dist_curr computes t+1
        std::vector&lt;int&gt; dist_prev(n, INF), dist_curr(n, INF);
        dist_prev[src] = 0;

        // Relax edges up to k+1 times (paths with at most k stops have at most k+1 edges)
        for (int t = 0; t &lt;= k; ++t) {
            dist_curr = dist_prev; // start from previous layer
            for (const auto&amp; e : flights) {
                int u = e, v = e[21], w = e[22];
                if (dist_prev[u] == INF) continue;
                dist_curr[v] = std::min(dist_curr[v], dist_prev[u] + w);
            }
            dist_prev.swap(dist_curr);
        }

        return dist_prev[dst] &gt;= INF ? -1 : dist_prev[dst];
    }
};
</code></pre></details></td></tr>
<tr><td>802</td><td><a href="https://leetcode.com/problems/find-eventual-safe-states/description/" target="_blank" rel="noopener">Link</a></td><td>Graph</td><td>Medium</td><td>166.0</td><td>46.79</td><td>O(V+E)</td><td>O(V+E)</td><td>35</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
    public:

    bool dfs(vector&lt;vector&lt;int&gt;&gt;&amp;graph,vector&lt;bool&gt;&amp;visited,vector&lt;bool&gt;&amp;path,vector&lt;bool&gt;&amp;cyclic,int node){
        if(visited[node])return cyclic[node];
        bool is_safe=1;
        for(int i:graph[node]){
            if(path[i]==1){
                is_safe=0;                
            }
            else{
                path[i]=1;
                is_safe&amp;=dfs(graph,visited,path,cyclic,i);
                path[i]=0;
            }
        }
        visited[node]=1;
        return cyclic[node]=is_safe;
    }
    
    vector&lt;int&gt; eventualSafeNodes(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
        vector&lt;bool&gt;visited(graph.size(),0);
        vector&lt;bool&gt;path(graph.size(),0);
        vector&lt;bool&gt;cyclic(graph.size(),0);
        vector&lt;int&gt;ans;
        for(int i=0;i&lt;graph.size();i++){
            if(dfs(graph,visited,path,cyclic,i))
                ans.emplace_back(i);
        }
        return ans;
    }
};</code></pre></details></td><td>54</td><td>66.74</td><td>O(V+E)</td><td>O(V+E)</td><td>35</td><td><details class="code"><summary>View</summary><pre><code>
class Solution {
public:
    std::vector&lt;int&gt; eventualSafeNodes(std::vector&lt;std::vector&lt;int&gt;&gt;&amp; graph) {
        int n = (int)graph.size();
        std::vector&lt;std::vector&lt;int&gt;&gt; rev(n);
        std::vector&lt;int&gt; outdeg(n, 0);

        for (int u = 0; u &lt; n; ++u) {
            outdeg[u] = (int)graph[u].size();
            for (int v : graph[u]) rev[v].push_back(u); // reverse edge
        }

        std::queue&lt;int&gt; q;
        for (int i = 0; i &lt; n; ++i)
            if (outdeg[i] == 0) q.push(i); // terminal nodes are safe

        std::vector&lt;int&gt; safe(n, 0);
        while (!q.empty()) {
            int u = q.front(); q.pop();
            safe[u] = 1;
            for (int p : rev[u]) {
                if (--outdeg[p] == 0) q.push(p);
            }
        }

        std::vector&lt;int&gt; ans;
        for (int i = 0; i &lt; n; ++i)
            if (safe[i]) ans.push_back(i);
        // already ascending by construction
        return ans;
    }
};</code></pre></details></td></tr>
<tr><td>95</td><td><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/description/" target="_blank" rel="noopener">Link</a></td><td>Trees</td><td>Medium</td><td>12.0</td><td>16.12</td><td>0(4^n/n^(3/2))</td><td>O(n * Cn)</td><td>24</td><td><details class="code"><summary>View</summary><pre><code>vector&lt;TreeNode*&gt; tree(int n,int left,int right){
    vector&lt;TreeNode*&gt; ans;
    if(n==0){
        ans.push_back(NULL);
        return ans;
    }    
    for(int i=left;i&lt;=right;i++){
        vector&lt;TreeNode*&gt; leftnode=tree(i-left,left,i-1);
        vector&lt;TreeNode*&gt; rightnode=tree(right-i,i+1,right);
        for(auto &amp;leftsub:leftnode){
            for(auto &amp;rightsub:rightnode){
                TreeNode* ptr=new TreeNode(i,leftsub,rightsub);
                ans.emplace_back(ptr);
            }
        }
    }
    return ans;
}

class Solution {
public:
    vector&lt;TreeNode*&gt; generateTrees(int n) {
        return tree(n,1,n);
    }
};</code></pre></details></td><td>1</td><td>19.16</td><td>0(4^n/n^(3/2))</td><td>0(4^n/n^(3/2)) + O(n)</td><td>21</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    vector&lt;TreeNode*&gt; generateTrees(int n) {
        if (n == 0) return {};
        return generate(1, n);
    }

private:
    vector&lt;TreeNode*&gt; generate(int start, int end) {
        vector&lt;TreeNode*&gt; all_trees;
        if (start &gt; end) {
            all_trees.push_back(nullptr);
            return all_trees;
        }

        for (int i = start; i &lt;= end; ++i) {
            vector&lt;TreeNode*&gt; left_trees = generate(start, i - 1);
            vector&lt;TreeNode*&gt; right_trees = generate(i + 1, end);
            for (auto left : left_trees) {
                for (auto right : right_trees) {
                    TreeNode* root = new TreeNode(i);
                    root-&gt;left = left;
                    root-&gt;right = right;
                    all_trees.push_back(root);
                }
            }
        }
        return all_trees;
    }
};
</code></pre></details></td></tr>
<tr><td>951</td><td><a href="https://leetcode.com/problems/flip-equivalent-binary-trees/description/" target="_blank" rel="noopener">Link</a></td><td>Trees</td><td>Medium</td><td>0.0</td><td>12.53</td><td>O(n+m) </td><td>O(h)</td><td>26</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:

    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p==nullptr&amp;&amp;q==nullptr)  return true;
        if(p==nullptr||q==nullptr)  return false;
        if(p-&gt;val!=q-&gt;val)  return false;
        return isSameTree(p-&gt;right, q-&gt;right)&amp;&amp;isSameTree(p-&gt;left, q-&gt;left);
    }

    void sortTree(TreeNode * p){
        if(!p)return;
        if(!p-&gt;right)swap(p-&gt;right, p-&gt;left);
        if(p-&gt;left&amp;&amp;p-&gt;right){
            if(p-&gt;left-&gt;val&gt;p-&gt;right-&gt;val)
                swap(p-&gt;right,p-&gt;left);
        }
        if(p-&gt;right)  sortTree(p-&gt;right);
        if(p-&gt;left)  sortTree(p-&gt;left);
        return;
    }

    bool flipEquiv(TreeNode* root1, TreeNode* root2) {
        sortTree(root1);
        sortTree(root2);
        return isSameTree(root1,root2);
    }
};</code></pre></details></td><td>0</td><td>15.47</td><td>O(n)</td><td>O(h)</td><td>12</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    bool flipEquiv(TreeNode* root1, TreeNode* root2) {
        if (!root1 &amp;&amp; !root2) return true;
        if (!root1 || !root2) return false;
        if (root1-&gt;val != root2-&gt;val) return false;
        bool noFlip = flipEquiv(root1-&gt;left, root2-&gt;left) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;right);
        bool flip = flipEquiv(root1-&gt;left, root2-&gt;right) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;left);
        return noFlip || flip;
    }
};
</code></pre></details></td></tr>
<tr><td>96</td><td><a href="https://leetcode.com/problems/unique-binary-search-trees/description/" target="_blank" rel="noopener">Link</a></td><td>Trees</td><td>Medium</td><td>0.0</td><td>6</td><td>O(n^2)</td><td>O(n)</td><td>14</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int numTrees(int n) {
        int dp[n];
        dp[0]=1;
        for(int i=1;i&lt;n;i++){
            dp[i]=0;
            for(int j=0;j&lt;=i;j++){
                int ans=1;
                if(j-1&gt;=0)
                ans*=dp[j-1];
                if(i-j-1&gt;=0)
                ans*=dp[i-j-1];
                dp[i]+=ans;
            }

        }
        return dp[n-1];
    }
};</code></pre></details></td><td>0</td><td>7.74</td><td>O(n^2)</td><td>O(n)</td><td>16</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int numTrees(int n) {
        int dp[n+1];
        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i &lt;= n; ++i) {
            dp[i] = 0;
            for (int j = 1; j &lt;= i; ++j) {
                dp[i] += dp[j-1] * dp[i-j];
            }
        }

        return dp[n];
    }
};
</code></pre></details></td></tr>
<tr><td>979</td><td><a href="https://leetcode.com/problems/distribute-coins-in-binary-tree/description/" target="_blank" rel="noopener">Link</a></td><td>Trees</td><td>Medium</td><td>0.0</td><td>15.6</td><td>O(n)</td><td>O(h)</td><td>17</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int moves;
    int helper(TreeNode* cur){
        if(!cur) return 0;
        int left = helper(cur-&gt;left);
        int right = helper(cur-&gt;right);
        moves += abs(left + right + cur-&gt;val - 1);
        return left + right + cur-&gt;val - 1;
    }
    int distributeCoins(TreeNode* root) {
        moves = 0;
        helper(root);
        return moves;  
    }    
};</code></pre></details></td><td>0</td><td>16.53</td><td>O(n)</td><td>O(h)</td><td>25</td><td><details class="code"><summary>View</summary><pre><code>class Solution {
public:
    int distributeCoins(TreeNode* root) {
        int result = 0;
        dfs(root, result);
        return result;
    }
private:
    int dfs(TreeNode* node, int&amp; result) {
        if (node == nullptr) return 0;
        
        // Calculate the excess coins from left subtree
        int leftExcess = dfs(node-&gt;left, result);
        // Calculate the excess coins from right subtree
        int rightExcess = dfs(node-&gt;right, result);
        
        // The total number of moves is the sum of absolute value of excess coins moved from left and right children
        result += abs(leftExcess) + abs(rightExcess);
        
        // Calculate and return the net excess coins at current node
        // node-&gt;val - 1: coins in current node minus exactly one coin that should remain
        // Positive means coins to give away, negative means coins needed
        return node-&gt;val + leftExcess + rightExcess - 1;
    }
};
</code></pre></details></td></tr>
        </tbody>
      </table>
    </div>
    </section>

<div class="foot">
  Tip: Use the search box above each table to filter by Problem ID, Domain, or Level.
</div>
</body>
</html>
